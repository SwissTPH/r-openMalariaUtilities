"""Provides autogenerated classes for OpenMalaria XML schema V47.

Manual changes will be overwritten!.
"""

from nodes import AttributeNode, ElementNode, Node
from lxml import etree


class OM0Scenario(Node):
    """Generated class for 'scenario'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='scenario', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of scenario
name:	Scenario"""
        self._metadata: dict = {'children_metadata': {'ordered': 'all', 'order': ['demography', 'monitoring', 'interventions', 'healthSystem', 'entomology', 'parasiteGenetics', 'pharmacology', 'diagnostics', 'model']}, 'attributes': {'schemaVersion': 'required', 'analysisNo': 'optional', 'name': 'required', 'wuID': 'optional'}, 'children': {'demography': {'minOccurs': '1', 'maxOccurs': '1'}, 'monitoring': {'minOccurs': '1', 'maxOccurs': '1'}, 'interventions': {'minOccurs': '1', 'maxOccurs': '1'}, 'healthSystem': {'minOccurs': '1', 'maxOccurs': '1'}, 'entomology': {'minOccurs': '1', 'maxOccurs': '1'}, 'parasiteGenetics': {'minOccurs': '0', 'maxOccurs': '1'}, 'pharmacology': {'minOccurs': '0', 'maxOccurs': '1'}, 'diagnostics': {'minOccurs': '0', 'maxOccurs': '1'}, 'model': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.schemaVersion: OM0Scenario._SchemaVersion = self._SchemaVersion(xml_tree=xml_tree, parent=self)
        self.analysisNo: OM0Scenario._AnalysisNo = self._AnalysisNo(xml_tree=xml_tree, parent=self)
        self.name: OM0Scenario._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.wuID: OM0Scenario._WuID = self._WuID(xml_tree=xml_tree, parent=self)
        self._demography: OM1Demography | None = None
        self._monitoring: OM2Monitoring | None = None
        self._interventions: OM3Interventions | None = None
        self._healthSystem: OM4HealthSystem | None = None
        self._entomology: OM5Entomology | None = None
        self._parasiteGenetics: OM6ParasiteGenetics | None = None
        self._pharmacology: OM7Pharmacology | None = None
        self._diagnostics: OM8Diagnostics | None = None
        self._model: OM9Model | None = None

    @property
    def demography(self) -> 'OM1Demography':
        """Initialize 'demography'."""
        if self._demography is None:
            self._demography = OM1Demography(xml_tree=self.xml_tree, parent=self)
        return self._demography

    @property
    def monitoring(self) -> 'OM2Monitoring':
        """Initialize 'monitoring'."""
        if self._monitoring is None:
            self._monitoring = OM2Monitoring(xml_tree=self.xml_tree, parent=self)
        return self._monitoring

    @property
    def interventions(self) -> 'OM3Interventions':
        """Initialize 'interventions'."""
        if self._interventions is None:
            self._interventions = OM3Interventions(xml_tree=self.xml_tree, parent=self)
        return self._interventions

    @property
    def healthSystem(self) -> 'OM4HealthSystem':
        """Initialize 'healthSystem'."""
        if self._healthSystem is None:
            self._healthSystem = OM4HealthSystem(xml_tree=self.xml_tree, parent=self)
        return self._healthSystem

    @property
    def entomology(self) -> 'OM5Entomology':
        """Initialize 'entomology'."""
        if self._entomology is None:
            self._entomology = OM5Entomology(xml_tree=self.xml_tree, parent=self)
        return self._entomology

    @property
    def parasiteGenetics(self) -> 'OM6ParasiteGenetics':
        """Initialize 'parasiteGenetics'."""
        if self._parasiteGenetics is None:
            self._parasiteGenetics = OM6ParasiteGenetics(xml_tree=self.xml_tree, parent=self)
        return self._parasiteGenetics

    @property
    def pharmacology(self) -> 'OM7Pharmacology':
        """Initialize 'pharmacology'."""
        if self._pharmacology is None:
            self._pharmacology = OM7Pharmacology(xml_tree=self.xml_tree, parent=self)
        return self._pharmacology

    @property
    def diagnostics(self) -> 'OM8Diagnostics':
        """Initialize 'diagnostics'."""
        if self._diagnostics is None:
            self._diagnostics = OM8Diagnostics(xml_tree=self.xml_tree, parent=self)
        return self._diagnostics

    @property
    def model(self) -> 'OM9Model':
        """Initialize 'model'."""
        if self._model is None:
            self._model = OM9Model(xml_tree=self.xml_tree, parent=self)
        return self._model

    class _SchemaVersion(AttributeNode):
        """Generated class for 'schemaVersion'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='schemaVersion', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Version of xml schema. If not equal to the current version
an error is thrown. Use SchemaTranslator to update xml files.

name:	Version of the xml schema
exposed:	false"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _AnalysisNo(AttributeNode):
        """Generated class for 'analysisNo'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='analysisNo', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Unique identifier of scenario

units:	 Number
min:	1
max:	100000000
name:	Reference number of the analysis
exposed:	false"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of intervention

name:	Name of intervention"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _WuID(AttributeNode):
        """Generated class for 'wuID'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='wuID', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Work unit ID. Obselete and no longer required.

units:	Number
name:	Work unit identifier
exposed:	false"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM1Demography(Node):
    """Generated class for 'demography'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='demography', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of demography

name:	Human age distribution"""
        self._metadata: dict = {'type': 'om:Demography', 'children_metadata': {'ordered': 'sequence', 'order': ['ageGroup']}, 'attributes': {'name': 'required', 'popSize': 'required', 'maximumAgeYrs': 'required', 'growthRate': 'optional'}, 'children': {'ageGroup': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM1Demography._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.popSize: OM1Demography._PopSize = self._PopSize(xml_tree=xml_tree, parent=self)
        self.maximumAgeYrs: OM1Demography._MaximumAgeYrs = self._MaximumAgeYrs(xml_tree=xml_tree, parent=self)
        self.growthRate: OM1Demography._GrowthRate = self._GrowthRate(xml_tree=xml_tree, parent=self)
        self._ageGroup: OM294AgeGroup | None = None

    @property
    def ageGroup(self) -> 'OM294AgeGroup':
        """Initialize 'ageGroup'."""
        if self._ageGroup is None:
            self._ageGroup = OM294AgeGroup(xml_tree=self.xml_tree, parent=self)
        return self._ageGroup

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of demography data

name:	Name of demography data"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _PopSize(AttributeNode):
        """Generated class for 'popSize'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='popSize', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Population size
units:	Count
min:	1
max:	100000
name:	Population size"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _MaximumAgeYrs(AttributeNode):
        """Generated class for 'maximumAgeYrs'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='maximumAgeYrs', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Maximum age of simulated humans in years

units:	Years
min:	0
max:	100
name:	Maximum age of simulated humans"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _GrowthRate(AttributeNode):
        """Generated class for 'growthRate'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='growthRate', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Growth rate of human population.
(we should be able to implement this with non-zero values)

units:	Number
min:	0
max:	0
name:	Growth rate of human population"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM2Monitoring(Node):
    """Generated class for 'monitoring'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='monitoring', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of surveys

name:	Measures to be reported"""
        self._metadata: dict = {'type': 'om:Monitoring', 'children_metadata': {'ordered': 'sequence', 'order': ['continuous', 'SurveyOptions', 'surveys', 'ageGroup', 'cohorts']}, 'attributes': {'name': 'required', 'startDate': 'optional'}, 'children': {'continuous': {'minOccurs': '0', 'maxOccurs': '1'}, 'SurveyOptions': {'minOccurs': '1', 'maxOccurs': '1'}, 'surveys': {'minOccurs': '1', 'maxOccurs': '1'}, 'ageGroup': {'minOccurs': '1', 'maxOccurs': '1'}, 'cohorts': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self.name: OM2Monitoring._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.startDate: OM2Monitoring._StartDate = self._StartDate(xml_tree=xml_tree, parent=self)
        self._continuous: OM123Continuous | None = None
        self._SurveyOptions: OM124SurveyOptions | None = None
        self._surveys: OM125Surveys | None = None
        self._ageGroup: OM127AgeGroup | None = None
        self._cohorts: OM128Cohorts | None = None

    @property
    def continuous(self) -> 'OM123Continuous':
        """Initialize 'continuous'."""
        if self._continuous is None:
            self._continuous = OM123Continuous(xml_tree=self.xml_tree, parent=self)
        return self._continuous

    @property
    def SurveyOptions(self) -> 'OM124SurveyOptions':
        """Initialize 'SurveyOptions'."""
        if self._SurveyOptions is None:
            self._SurveyOptions = OM124SurveyOptions(xml_tree=self.xml_tree, parent=self)
        return self._SurveyOptions

    @property
    def surveys(self) -> 'OM125Surveys':
        """Initialize 'surveys'."""
        if self._surveys is None:
            self._surveys = OM125Surveys(xml_tree=self.xml_tree, parent=self)
        return self._surveys

    @property
    def ageGroup(self) -> 'OM127AgeGroup':
        """Initialize 'ageGroup'."""
        if self._ageGroup is None:
            self._ageGroup = OM127AgeGroup(xml_tree=self.xml_tree, parent=self)
        return self._ageGroup

    @property
    def cohorts(self) -> 'OM128Cohorts':
        """Initialize 'cohorts'."""
        if self._cohorts is None:
            self._cohorts = OM128Cohorts(xml_tree=self.xml_tree, parent=self)
        return self._cohorts

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of monitoring settings

name:	Name of monitoring settings"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _StartDate(AttributeNode):
        """Generated class for 'startDate'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='startDate', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional date for the start of monitoring. If given, dates may be
used to specify when other events (surveys, intervention deployments)
occur; alternately times relative to the start of the intervention
period may be used to specify event times.
Setting this to 1st January of some year might simplify usage of
dates, and putting the start a couple of years before the start of
intervention deployment (along with some extra surveys) may be useful
to check transmission stabilises to the expected pre-intervention
levels.
As an example, if this date is set to 2000-01-01, then the following
event times are equivalent (assuming 1t=5d):
15t, 75d, 0.2y, 2000-03-16.
Must be in the form YYYY-MM-DD, e.g. 2003-01-01.

name:	Start of monitoring"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM3Interventions(Node):
    """Generated class for 'interventions'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='interventions', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
List of interventions. Generally these are either point-time
distributions of something to some subset of the population, or
continuous-time distribution targetting individuals when they
reach a certain age.

name:	Preventative interventions"""
        self._metadata: dict = {'type': 'om:Interventions', 'children_metadata': {'ordered': 'all', 'order': ['changeHS', 'changeEIR', 'importedInfections', 'insertR_0Case', 'uninfectVectors', 'vectorPop', 'vectorTrap', 'nonHumanHostsModifications', 'addNonHumanHosts', 'human']}, 'attributes': {'name': 'required'}, 'children': {'changeHS': {'minOccurs': '0', 'maxOccurs': '1'}, 'changeEIR': {'minOccurs': '0', 'maxOccurs': '1'}, 'importedInfections': {'minOccurs': '0', 'maxOccurs': '1'}, 'insertR_0Case': {'minOccurs': '0', 'maxOccurs': '1'}, 'uninfectVectors': {'minOccurs': '0', 'maxOccurs': '1'}, 'vectorPop': {'minOccurs': '0', 'maxOccurs': '1'}, 'vectorTrap': {'minOccurs': '0', 'maxOccurs': '1'}, 'nonHumanHostsModifications': {'minOccurs': '0', 'maxOccurs': '1'}, 'addNonHumanHosts': {'minOccurs': '0', 'maxOccurs': '1'}, 'human': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self.name: OM3Interventions._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._changeHS: OM132ChangeHS | None = None
        self._changeEIR: OM134ChangeEIR | None = None
        self._importedInfections: OM136ImportedInfections | None = None
        self._insertR_0Case: OM139InsertR_0Case | None = None
        self._uninfectVectors: OM141UninfectVectors | None = None
        self._vectorPop: OM143VectorPop | None = None
        self._vectorTrap: OM145VectorTrap | None = None
        self._nonHumanHostsModifications: OM147NonHumanHostsModifications | None = None
        self._addNonHumanHosts: OM149AddNonHumanHosts | None = None
        self._human: OM151Human | None = None

    @property
    def changeHS(self) -> 'OM132ChangeHS':
        """Initialize 'changeHS'."""
        if self._changeHS is None:
            self._changeHS = OM132ChangeHS(xml_tree=self.xml_tree, parent=self)
        return self._changeHS

    @property
    def changeEIR(self) -> 'OM134ChangeEIR':
        """Initialize 'changeEIR'."""
        if self._changeEIR is None:
            self._changeEIR = OM134ChangeEIR(xml_tree=self.xml_tree, parent=self)
        return self._changeEIR

    @property
    def importedInfections(self) -> 'OM136ImportedInfections':
        """Initialize 'importedInfections'."""
        if self._importedInfections is None:
            self._importedInfections = OM136ImportedInfections(xml_tree=self.xml_tree, parent=self)
        return self._importedInfections

    @property
    def insertR_0Case(self) -> 'OM139InsertR_0Case':
        """Initialize 'insertR_0Case'."""
        if self._insertR_0Case is None:
            self._insertR_0Case = OM139InsertR_0Case(xml_tree=self.xml_tree, parent=self)
        return self._insertR_0Case

    @property
    def uninfectVectors(self) -> 'OM141UninfectVectors':
        """Initialize 'uninfectVectors'."""
        if self._uninfectVectors is None:
            self._uninfectVectors = OM141UninfectVectors(xml_tree=self.xml_tree, parent=self)
        return self._uninfectVectors

    @property
    def vectorPop(self) -> 'OM143VectorPop':
        """Initialize 'vectorPop'."""
        if self._vectorPop is None:
            self._vectorPop = OM143VectorPop(xml_tree=self.xml_tree, parent=self)
        return self._vectorPop

    @property
    def vectorTrap(self) -> 'OM145VectorTrap':
        """Initialize 'vectorTrap'."""
        if self._vectorTrap is None:
            self._vectorTrap = OM145VectorTrap(xml_tree=self.xml_tree, parent=self)
        return self._vectorTrap

    @property
    def nonHumanHostsModifications(self) -> 'OM147NonHumanHostsModifications':
        """Initialize 'nonHumanHostsModifications'."""
        if self._nonHumanHostsModifications is None:
            self._nonHumanHostsModifications = OM147NonHumanHostsModifications(xml_tree=self.xml_tree, parent=self)
        return self._nonHumanHostsModifications

    @property
    def addNonHumanHosts(self) -> 'OM149AddNonHumanHosts':
        """Initialize 'addNonHumanHosts'."""
        if self._addNonHumanHosts is None:
            self._addNonHumanHosts = OM149AddNonHumanHosts(xml_tree=self.xml_tree, parent=self)
        return self._addNonHumanHosts

    @property
    def human(self) -> 'OM151Human':
        """Initialize 'human'."""
        if self._human is None:
            self._human = OM151Human(xml_tree=self.xml_tree, parent=self)
        return self._human

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of set of interventions
name:	Name of intervention set"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM4HealthSystem(Node):
    """Generated class for 'healthSystem'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='healthSystem', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Description of health system.

name:	Health system description
Type:
Description of case management system, used to specify the initial model
or a replacement (an intervention). Encompasses case management
data and some other data required to derive case outcomes.
Contains a sub-element describing the particular health-system in use.
Health system data is here defined as data used to decide on a treatment
strategy, given a case requiring treatment.

name:	Case management system"""
        self._metadata: dict = {'type': 'om:HealthSystem', 'children_metadata': {'ordered': 'sequence', 'order': [['EventScheduler', 'ImmediateOutcomes', 'DecisionTree5Day'], 'CFR', 'pSequelaeInpatient']}, 'attributes': {}, 'children': {'EventScheduler': {'minOccurs': '1', 'maxOccurs': '1'}, 'ImmediateOutcomes': {'minOccurs': '1', 'maxOccurs': '1'}, 'DecisionTree5Day': {'minOccurs': '1', 'maxOccurs': '1'}, 'CFR': {'minOccurs': '1', 'maxOccurs': '1'}, 'pSequelaeInpatient': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._EventScheduler: OM28EventScheduler | None = None
        self._ImmediateOutcomes: OM29ImmediateOutcomes | None = None
        self._DecisionTree5Day: OM30DecisionTree5Day | None = None
        self._CFR: OM31CFR | None = None
        self._pSequelaeInpatient: OM32PSequelaeInpatient | None = None

    @property
    def EventScheduler(self) -> 'OM28EventScheduler':
        """Initialize 'EventScheduler'."""
        if self._EventScheduler is None:
            self._EventScheduler = OM28EventScheduler(xml_tree=self.xml_tree, parent=self)
        return self._EventScheduler

    @property
    def ImmediateOutcomes(self) -> 'OM29ImmediateOutcomes':
        """Initialize 'ImmediateOutcomes'."""
        if self._ImmediateOutcomes is None:
            self._ImmediateOutcomes = OM29ImmediateOutcomes(xml_tree=self.xml_tree, parent=self)
        return self._ImmediateOutcomes

    @property
    def DecisionTree5Day(self) -> 'OM30DecisionTree5Day':
        """Initialize 'DecisionTree5Day'."""
        if self._DecisionTree5Day is None:
            self._DecisionTree5Day = OM30DecisionTree5Day(xml_tree=self.xml_tree, parent=self)
        return self._DecisionTree5Day

    @property
    def CFR(self) -> 'OM31CFR':
        """Initialize 'CFR'."""
        if self._CFR is None:
            self._CFR = OM31CFR(xml_tree=self.xml_tree, parent=self)
        return self._CFR

    @property
    def pSequelaeInpatient(self) -> 'OM32PSequelaeInpatient':
        """Initialize 'pSequelaeInpatient'."""
        if self._pSequelaeInpatient is None:
            self._pSequelaeInpatient = OM32PSequelaeInpatient(xml_tree=self.xml_tree, parent=self)
        return self._pSequelaeInpatient


class OM5Entomology(Node):
    """Generated class for 'entomology'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='entomology', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of entomological data

name:	Transmission and vector bionomics"""
        self._metadata: dict = {'type': 'om:Entomology', 'children_metadata': {'ordered': 'sequence', 'order': [['nonVector', 'vector']]}, 'attributes': {'name': 'required', 'mode': 'required', 'scaledAnnualEIR': 'optional'}, 'children': {'nonVector': {'minOccurs': '1', 'maxOccurs': '1'}, 'vector': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM5Entomology._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.mode: OM5Entomology._Mode = self._Mode(xml_tree=xml_tree, parent=self)
        self.scaledAnnualEIR: OM5Entomology._ScaledAnnualEIR = self._ScaledAnnualEIR(xml_tree=xml_tree, parent=self)
        self._nonVector: OM308NonVector | None = None
        self._vector: OM309Vector | None = None

    @property
    def nonVector(self) -> 'OM308NonVector':
        """Initialize 'nonVector'."""
        if self._nonVector is None:
            self._nonVector = OM308NonVector(xml_tree=self.xml_tree, parent=self)
        return self._nonVector

    @property
    def vector(self) -> 'OM309Vector':
        """Initialize 'vector'."""
        if self._vector is None:
            self._vector = OM309Vector(xml_tree=self.xml_tree, parent=self)
        return self._vector

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of entomology data

name:	Entomology dataset name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Mode(AttributeNode):
        """Generated class for 'mode'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mode', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Transmission simulation mode: may be forced (in which case interventions
and changes to human infectiousness cannot affect EIR) or dynamic (in
which the above can affect EIR). The full vector model is only used in
dynamic mode. This can not be changed by interventions, except for the
changeEIR intervention for the non-vector model which replaces the EIR
with a new description (used in forced mode).

name:	Transmission model mode"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['forced', 'dynamic']}, 'type': 'xs:string'}

    class _ScaledAnnualEIR(AttributeNode):
        """Generated class for 'scaledAnnualEIR'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='scaledAnnualEIR', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If set, the annual EIR (for all species of vector) is scaled to this
level; can be omitted if not needed.

units:	Infectious bites per adult per year
name:	Override annual EIR"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM6ParasiteGenetics(Node):
    """Generated class for 'parasiteGenetics'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='parasiteGenetics', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A specification of genotypes of infection parasites.
May be omitted; in this case there is no modelling of genetic
differences of infections (resistance, fitness).

name:	Parasite genetics"""
        self._metadata: dict = {'type': 'om:ParasiteGenetics', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['locus']}, 'attributes': {'samplingMode': 'required'}, 'children': {'locus': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.samplingMode: OM6ParasiteGenetics._SamplingMode = self._SamplingMode(xml_tree=xml_tree, parent=self)
        self._locus: OM18Locus | None = None

    @property
    def locus(self) -> 'OM18Locus':
        """Initialize 'locus'."""
        if self._locus is None:
            self._locus = OM18Locus(xml_tree=self.xml_tree, parent=self)
        return self._locus

    class _SamplingMode(AttributeNode):
        """Generated class for 'samplingMode'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='samplingMode', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
This controls how genotypes are determined for new infections during
the intervention period. Prior to this (in initialisation phases),
genotypes are always sampled using the specified initial frequencies.
Mode "initial" continues to sample genotypes using initial
frequencies (i.e. independent of the success of parent generations of
parasites).
Mode "tracking" samples genotypes based on the success parent
generations of parasites have in infecting mosquitoes, tracked per
genotype.
It is possible that in the future a recombination option will be
added to this list, however designing a suitable model is not
trivial.

Name:	Sampling mode"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['initial', 'tracking']}, 'type': 'xs:string'}


class OM7Pharmacology(Node):
    """Generated class for 'pharmacology'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pharmacology', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Drug model parameters and drug usage parameters

name:	Drug parameters (PK, PD and usage)
Type:
A library of drug related data for the PK/PD model.

name:	Pharmacology library"""
        self._metadata: dict = {'type': 'om:Pharmacology', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['treatments', 'drugs']}, 'attributes': {}, 'children': {'treatments': {'minOccurs': '1', 'maxOccurs': '1'}, 'drugs': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._treatments: OM255Treatments | None = None
        self._drugs: OM258Drugs | None = None

    @property
    def treatments(self) -> 'OM255Treatments':
        """Initialize 'treatments'."""
        if self._treatments is None:
            self._treatments = OM255Treatments(xml_tree=self.xml_tree, parent=self)
        return self._treatments

    @property
    def drugs(self) -> 'OM258Drugs':
        """Initialize 'drugs'."""
        if self._drugs is None:
            self._drugs = OM258Drugs(xml_tree=self.xml_tree, parent=self)
        return self._drugs


class OM8Diagnostics(Node):
    """Generated class for 'diagnostics'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='diagnostics', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Diagnostic model parameters

name:	Diagnostic parameters"""
        self._metadata: dict = {'type': 'om:Diagnostics', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['diagnostic']}, 'attributes': {}, 'children': {'diagnostic': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self._diagnostic: OM20Diagnostic | None = None

    @property
    def diagnostic(self) -> 'OM20Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM20Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic


class OM9Model(Node):
    """Generated class for 'model'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='model', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Encapsulation of all parameters which describe the model according
to which fitting is done.

name:	Model options and parameters"""
        self._metadata: dict = {'children_metadata': {'ordered': 'all', 'order': ['ModelOptions', 'clinical', 'human', 'vivax', 'parameters']}, 'attributes': {}, 'children': {'ModelOptions': {'minOccurs': '1', 'maxOccurs': '1'}, 'clinical': {'minOccurs': '1', 'maxOccurs': '1'}, 'human': {'minOccurs': '1', 'maxOccurs': '1'}, 'vivax': {'minOccurs': '0', 'maxOccurs': '1'}, 'parameters': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._ModelOptions: OM10ModelOptions | None = None
        self._clinical: OM11Clinical | None = None
        self._human: OM12Human | None = None
        self._vivax: OM13Vivax | None = None
        self._parameters: OM14Parameters | None = None

    @property
    def ModelOptions(self) -> 'OM10ModelOptions':
        """Initialize 'ModelOptions'."""
        if self._ModelOptions is None:
            self._ModelOptions = OM10ModelOptions(xml_tree=self.xml_tree, parent=self)
        return self._ModelOptions

    @property
    def clinical(self) -> 'OM11Clinical':
        """Initialize 'clinical'."""
        if self._clinical is None:
            self._clinical = OM11Clinical(xml_tree=self.xml_tree, parent=self)
        return self._clinical

    @property
    def human(self) -> 'OM12Human':
        """Initialize 'human'."""
        if self._human is None:
            self._human = OM12Human(xml_tree=self.xml_tree, parent=self)
        return self._human

    @property
    def vivax(self) -> 'OM13Vivax':
        """Initialize 'vivax'."""
        if self._vivax is None:
            self._vivax = OM13Vivax(xml_tree=self.xml_tree, parent=self)
        return self._vivax

    @property
    def parameters(self) -> 'OM14Parameters':
        """Initialize 'parameters'."""
        if self._parameters is None:
            self._parameters = OM14Parameters(xml_tree=self.xml_tree, parent=self)
        return self._parameters


class OM10ModelOptions(Node):
    """Generated class for 'ModelOptions'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='ModelOptions', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
All model options (bug fixes, choices between models, etc.).                    
The list of recognised options can be found in the code at:
model/util/ModelOptions.h and should also be in the wiki.

name:	Model Options"""
        self._metadata: dict = {'type': 'om:OptionSet', 'children_metadata': {'ordered': 'sequence', 'order': ['option']}, 'attributes': {}, 'children': {'option': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self._option: OM290Option | None = None

    @property
    def option(self) -> 'OM290Option':
        """Initialize 'option'."""
        if self._option is None:
            self._option = OM290Option(xml_tree=self.xml_tree, parent=self)
        return self._option


class OM11Clinical(Node):
    """Generated class for 'clinical'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='clinical', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of clinical parameters that are related to the health-system description, but which contain data
that cannot be changed as part of an intervention and that are not restricted to treatment.

name:	Description of clinical parameters"""
        self._metadata: dict = {'type': 'om:Clinical', 'children_metadata': {'ordered': 'all', 'order': ['NeonatalMortality', 'NonMalariaFevers']}, 'attributes': {'healthSystemMemory': 'required'}, 'children': {'NeonatalMortality': {'minOccurs': '0', 'maxOccurs': '1'}, 'NonMalariaFevers': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self.healthSystemMemory: OM11Clinical._HealthSystemMemory = self._HealthSystemMemory(xml_tree=xml_tree, parent=self)
        self._NeonatalMortality: OM23NeonatalMortality | None = None
        self._NonMalariaFevers: OM24NonMalariaFevers | None = None

    @property
    def NeonatalMortality(self) -> 'OM23NeonatalMortality':
        """Initialize 'NeonatalMortality'."""
        if self._NeonatalMortality is None:
            self._NeonatalMortality = OM23NeonatalMortality(xml_tree=self.xml_tree, parent=self)
        return self._NeonatalMortality

    @property
    def NonMalariaFevers(self) -> 'OM24NonMalariaFevers':
        """Initialize 'NonMalariaFevers'."""
        if self._NonMalariaFevers is None:
            self._NonMalariaFevers = OM24NonMalariaFevers(xml_tree=self.xml_tree, parent=self)
        return self._NonMalariaFevers

    class _HealthSystemMemory(AttributeNode):
        """Generated class for 'healthSystemMemory'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='healthSystemMemory', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Follow-up period during which a recurrence is
considered to be a treatment failure
Can be specified in steps (e.g. 6t) or days (e.g. 28d).

units:	User-defined (defaults to steps)

          name:	Follow-up period during which recurrence is considered a treatment failure"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM12Human(Node):
    """Generated class for 'human'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='human', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Parameters of host models.

name:	Human"""
        self._metadata: dict = {'type': 'om:Human', 'children_metadata': {'ordered': 'sequence', 'order': ['availabilityToMosquitoes', 'weight']}, 'attributes': {}, 'children': {'availabilityToMosquitoes': {'minOccurs': '1', 'maxOccurs': '1'}, 'weight': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self._availabilityToMosquitoes: OM16AvailabilityToMosquitoes | None = None
        self._weight: OM17Weight | None = None

    @property
    def availabilityToMosquitoes(self) -> 'OM16AvailabilityToMosquitoes':
        """Initialize 'availabilityToMosquitoes'."""
        if self._availabilityToMosquitoes is None:
            self._availabilityToMosquitoes = OM16AvailabilityToMosquitoes(xml_tree=self.xml_tree, parent=self)
        return self._availabilityToMosquitoes

    @property
    def weight(self) -> 'OM17Weight':
        """Initialize 'weight'."""
        if self._weight is None:
            self._weight = OM17Weight(xml_tree=self.xml_tree, parent=self)
        return self._weight


class OM13Vivax(Node):
    """Generated class for 'vivax'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='vivax', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
This describes Vivax model parameters, and is required when using the
VIVAX_SIMPLE_MODEL model option.

name:	Vivax model parameters"""
        self._metadata: dict = {'type': 'om:Vivax', 'minOccurs': '0', 'children_metadata': {'ordered': 'all', 'order': ['probBloodStageInfectiousToMosq', 'hypnozoiteRelease', 'bloodStageProtectionLatency', 'bloodStageLengthDays', 'clinicalEvents']}, 'attributes': {}, 'children': {'probBloodStageInfectiousToMosq': {'minOccurs': '1', 'maxOccurs': '1'}, 'hypnozoiteRelease': {'minOccurs': '1', 'maxOccurs': '1'}, 'bloodStageProtectionLatency': {'minOccurs': '1', 'maxOccurs': '1'}, 'bloodStageLengthDays': {'minOccurs': '1', 'maxOccurs': '1'}, 'clinicalEvents': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._probBloodStageInfectiousToMosq: OM296ProbBloodStageInfectiousToMosq | None = None
        self._hypnozoiteRelease: OM297HypnozoiteRelease | None = None
        self._bloodStageProtectionLatency: OM298BloodStageProtectionLatency | None = None
        self._bloodStageLengthDays: OM299BloodStageLengthDays | None = None
        self._clinicalEvents: OM300ClinicalEvents | None = None

    @property
    def probBloodStageInfectiousToMosq(self) -> 'OM296ProbBloodStageInfectiousToMosq':
        """Initialize 'probBloodStageInfectiousToMosq'."""
        if self._probBloodStageInfectiousToMosq is None:
            self._probBloodStageInfectiousToMosq = OM296ProbBloodStageInfectiousToMosq(xml_tree=self.xml_tree, parent=self)
        return self._probBloodStageInfectiousToMosq

    @property
    def hypnozoiteRelease(self) -> 'OM297HypnozoiteRelease':
        """Initialize 'hypnozoiteRelease'."""
        if self._hypnozoiteRelease is None:
            self._hypnozoiteRelease = OM297HypnozoiteRelease(xml_tree=self.xml_tree, parent=self)
        return self._hypnozoiteRelease

    @property
    def bloodStageProtectionLatency(self) -> 'OM298BloodStageProtectionLatency':
        """Initialize 'bloodStageProtectionLatency'."""
        if self._bloodStageProtectionLatency is None:
            self._bloodStageProtectionLatency = OM298BloodStageProtectionLatency(xml_tree=self.xml_tree, parent=self)
        return self._bloodStageProtectionLatency

    @property
    def bloodStageLengthDays(self) -> 'OM299BloodStageLengthDays':
        """Initialize 'bloodStageLengthDays'."""
        if self._bloodStageLengthDays is None:
            self._bloodStageLengthDays = OM299BloodStageLengthDays(xml_tree=self.xml_tree, parent=self)
        return self._bloodStageLengthDays

    @property
    def clinicalEvents(self) -> 'OM300ClinicalEvents':
        """Initialize 'clinicalEvents'."""
        if self._clinicalEvents is None:
            self._clinicalEvents = OM300ClinicalEvents(xml_tree=self.xml_tree, parent=self)
        return self._clinicalEvents


class OM14Parameters(Node):
    """Generated class for 'parameters'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='parameters', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Parameters of the epidemiological model

name:	Parameters of the model of epidemiology"""
        self._metadata: dict = {'type': 'om:Parameters', 'children_metadata': {'ordered': 'sequence', 'order': ['parameter']}, 'attributes': {'interval': 'required', 'iseed': 'required', 'latentp': 'required'}, 'children': {'parameter': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.interval: OM14Parameters._Interval = self._Interval(xml_tree=xml_tree, parent=self)
        self.iseed: OM14Parameters._Iseed = self._Iseed(xml_tree=xml_tree, parent=self)
        self.latentp: OM14Parameters._Latentp = self._Latentp(xml_tree=xml_tree, parent=self)
        self._parameter: OM15Parameter | None = None

    @property
    def parameter(self) -> 'OM15Parameter':
        """Initialize 'parameter'."""
        if self._parameter is None:
            self._parameter = OM15Parameter(xml_tree=self.xml_tree, parent=self)
        return self._parameter

    class _Interval(AttributeNode):
        """Generated class for 'interval'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interval', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Simulation step
units:	Days
name:	Simulation step"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Iseed(AttributeNode):
        """Generated class for 'iseed'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='iseed', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Seed for RNG
units:	Number
name:	Random number seed
sweepable:	true"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Latentp(AttributeNode):
        """Generated class for 'latentp'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='latentp', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Pre-erythrocytic latent period
Can be specified in steps (e.g. 3t) or days (e.g. 15d).

units:	User defined (default:	 steps)
min:	0
max:	20
name:	Pre-erythrocytic latent period"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM15Parameter(Node):
    """Generated class for 'parameter'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='parameter', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'type': 'om:Parameter', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'name': 'optional', 'number': 'required', 'value': 'required', 'include': 'optional'}, 'children': {}}
        self.name: OM15Parameter._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.number: OM15Parameter._Number = self._Number(xml_tree=xml_tree, parent=self)
        self.value: OM15Parameter._Value = self._Value(xml_tree=xml_tree, parent=self)
        self.include: OM15Parameter._Include = self._Include(xml_tree=xml_tree, parent=self)

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of parameter
units:	string
name:	Name of parameter"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Number(AttributeNode):
        """Generated class for 'number'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='number', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Reference number of input parameter

units:	Number
min:	1
max:	100
name:	Parameter number
exposed:	false"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Parameter value
units:	Number
min:	0
name:	Parameter value
sweepable:	true"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Include(AttributeNode):
        """Generated class for 'include'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='include', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
True if parameter is to be sampled in optimization
runs. Not used in simulator app.

units:	Number
min:	0
max:	1
name:	Sampling indicator
exposed:	false"""
            self._metadata: dict = {'type': 'xs:boolean', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM16AvailabilityToMosquitoes(Node):
    """Generated class for 'availabilityToMosquitoes'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='availabilityToMosquitoes', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Availability of humans to mosquitoes relative to an adult, categorized by age group

name:	Availability to mosquitoes
units:	None
min:	0
max:	1"""
        self._metadata: dict = {'type': 'om:AgeGroupValues', 'children_metadata': {'ordered': 'sequence', 'order': ['group']}, 'attributes': {'interpolation': 'optional'}, 'children': {'group': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.interpolation: OM16AvailabilityToMosquitoes._Interpolation = self._Interpolation(xml_tree=xml_tree, parent=self)
        self._group: OM293Group | None = None

    @property
    def group(self) -> 'OM293Group':
        """Initialize 'group'."""
        if self._group is None:
            self._group = OM293Group(xml_tree=self.xml_tree, parent=self)
        return self._group

    class _Interpolation(AttributeNode):
        """Generated class for 'interpolation'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interpolation', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Interpolation algorithm. Normally it is desirable for age-based
values to be continuous w.r.t. age. By default linear interpolation
is used.
With all algorithms except "none", the age groups are converted to a
set of points centred within each age range. Extra
points are added at each end (zero and infinity) to keep value
constant at both ends of the function. A zero-length age group may
be used as a kind of barrier to adjust the distribution; e.g. with
age group boundaries at 15, 20 and 25 years, a (linear) spline would
be drawn between ages 17.5 and 22.5, whereas with boundaries at
15, 20 and 20 years, a spline would be drawn between ages 17.5 and 20
years (may be desired if individuals are assumed to reach adult size
at 20).
Algorithms:
1. none: input values are used directly
2. linear: straight lines (on an age vs. value graph) are used to
interpolate data points.

name:	interpolation"""
            self._metadata: dict = {'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['none', 'linear']}, 'type': 'xs:string'}


class OM17Weight(Node):
    """Generated class for 'weight'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='weight', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
By age group data on human weight (mass).

name:	Weight
units:	kg
min:	0"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['group']}, 'type': 'om:AgeGroupValues', 'attributes': {'multStdDev': 'required', 'interpolation': 'optional'}, 'children': {'group': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.multStdDev: OM17Weight._MultStdDev = self._MultStdDev(xml_tree=xml_tree, parent=self)
        self.interpolation: OM17Weight._Interpolation = self._Interpolation(xml_tree=xml_tree, parent=self)
        self._group: OM293Group | None = None

    @property
    def group(self) -> 'OM293Group':
        """Initialize 'group'."""
        if self._group is None:
            self._group = OM293Group(xml_tree=self.xml_tree, parent=self)
        return self._group

    class _MultStdDev(AttributeNode):
        """Generated class for 'multStdDev'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='multStdDev', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Each human is assigned a weight multiplier from a normal distribution
with mean 1 and this standard deviation at birth. His/her weight
is this multiplier times the mean from age distribution.
A standard deviation of zero for no heterogeneity is valid; a rough
value from Tanzanian data is 0.14.

name:	Standard deviation
units:	None
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Interpolation(AttributeNode):
        """Generated class for 'interpolation'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interpolation', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Element:
Interpolation algorithm. Normally it is desirable for age-based
values to be continuous w.r.t. age. By default linear interpolation
is used.
With all algorithms except "none", the age groups are converted to a
set of points centred within each age range. Extra
points are added at each end (zero and infinity) to keep value
constant at both ends of the function. A zero-length age group may
be used as a kind of barrier to adjust the distribution; e.g. with
age group boundaries at 15, 20 and 25 years, a (linear) spline would
be drawn between ages 17.5 and 22.5, whereas with boundaries at
15, 20 and 20 years, a spline would be drawn between ages 17.5 and 20
years (may be desired if individuals are assumed to reach adult size
at 20).
Algorithms:
1. none: input values are used directly
2. linear: straight lines (on an age vs. value graph) are used to
interpolate data points.

name:	interpolation
Type:
Interpolation algorithm. Normally it is desirable for age-based
values to be continuous w.r.t. age. By default linear interpolation
is used.
With all algorithms except "none", the age groups are converted to a
set of points centred within each age range. Extra
points are added at each end (zero and infinity) to keep value
constant at both ends of the function. A zero-length age group may
be used as a kind of barrier to adjust the distribution; e.g. with
age group boundaries at 15, 20 and 25 years, a (linear) spline would
be drawn between ages 17.5 and 22.5, whereas with boundaries at
15, 20 and 20 years, a spline would be drawn between ages 17.5 and 20
years (may be desired if individuals are assumed to reach adult size
at 20).
Algorithms:
1. none: input values are used directly
2. linear: straight lines (on an age vs. value graph) are used to
interpolate data points.

name:	interpolation"""
            self._metadata: dict = {'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['none', 'linear']}, 'type': 'xs:string'}


class OM18Locus(Node):
    """Generated class for 'locus'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='locus', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes a locus, or a point at which an infection may
vary. The genotype of an infection is determined by
choosing one allele at each locus. Initial frequencies of
alleles are specified independently for each locus, but
subsequent infections are selected according to success of
genotypes.
Alleles at loci can affect fitness and resistance to any
number of drugs.

name:	Locus"""
        self._metadata: dict = {'type': 'om:ParasiteLocus', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': ['allele']}, 'attributes': {'name': 'required'}, 'children': {'allele': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.name: OM18Locus._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._allele: OM19Allele | None = None

    @property
    def allele(self) -> 'OM19Allele':
        """Initialize 'allele'."""
        if self._allele is None:
            self._allele = OM19Allele(xml_tree=self.xml_tree, parent=self)
        return self._allele

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of the Locus
name:	Name of locus"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM19Allele(Node):
    """Generated class for 'allele'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='allele', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes an allele, or one possible genetic option
of multiple at one point of variance.

name:	Allele"""
        self._metadata: dict = {'type': 'om:ParasiteAllele', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'name': 'required', 'initialFrequency': 'required', 'fitness': 'required', 'hrp2_deletion': ''}, 'children': {}}
        self.name: OM19Allele._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.initialFrequency: OM19Allele._InitialFrequency = self._InitialFrequency(xml_tree=xml_tree, parent=self)
        self.fitness: OM19Allele._Fitness = self._Fitness(xml_tree=xml_tree, parent=self)
        self.hrp2_deletion: OM19Allele._Hrp2_deletion = self._Hrp2_deletion(xml_tree=xml_tree, parent=self)

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of the allele; used to refer to it elsewhere.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InitialFrequency(AttributeNode):
        """Generated class for 'initialFrequency'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initialFrequency', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Specification of how commonly this allele occurs during warmup
relative to other alleles of the same locus.
During the simulation's initialisation phases, the frequency at which
each allele of each locus occurs is fixed. After the initialisation
phase, frequency of alleles is modelled as an emergent property of
the success of genotypes.

name:	Initial frequency"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Fitness(AttributeNode):
        """Generated class for 'fitness'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='fitness', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Fitness factor of the allele. This is multiplication factor used to
speed up or slow down replication of parasites.
For example, if a genotype has an allele with a fitness factor of 1
at one locus and another allele with a fitness factor of 0.8 at a
second locus, then the parasites with the genotype will replicate 20%
slower than the baseline.

name:	Fitness factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Hrp2_deletion(AttributeNode):
        """Generated class for 'hrp2_deletion'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='hrp2_deletion', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If true, marks this allele as having deleted HRP2.
The effect on the simulation is that any diagnostic dependent on HRP2
behaves as if infections with deleted HRP2 have density 0.
A diagnostic MUST explicitly set mechanism="HRP2" for this to have any
effect.

name:	HRP2 deletion"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}


class OM20Diagnostic(Node):
    """Generated class for 'diagnostic'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='diagnostic', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'type': 'om:Diagnostic', 'maxOccurs': 'unbounded', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': [['deterministic', 'stochastic']]}, 'attributes': {'name': 'required', 'units': 'optional', 'mechanism': ''}, 'children': {'deterministic': {'minOccurs': '1', 'maxOccurs': '1'}, 'stochastic': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM20Diagnostic._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.units: OM20Diagnostic._Units = self._Units(xml_tree=xml_tree, parent=self)
        self.mechanism: OM20Diagnostic._Mechanism = self._Mechanism(xml_tree=xml_tree, parent=self)
        self._deterministic: OM21Deterministic | None = None
        self._stochastic: OM22Stochastic | None = None

    @property
    def deterministic(self) -> 'OM21Deterministic':
        """Initialize 'deterministic'."""
        if self._deterministic is None:
            self._deterministic = OM21Deterministic(xml_tree=self.xml_tree, parent=self)
        return self._deterministic

    @property
    def stochastic(self) -> 'OM22Stochastic':
        """Initialize 'stochastic'."""
        if self._stochastic is None:
            self._stochastic = OM22Stochastic(xml_tree=self.xml_tree, parent=self)
        return self._stochastic

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of this diagnostic (parameterisation). May be used elsewhere in
the XML document to refer to this set of diagnostic parameters.

name:	Name of diagnostic"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Units(AttributeNode):
        """Generated class for 'units'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='units', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Parasite densities, as estimated according to standard microscopy
methods, the Garki method, and as derived from Malariatherapy data
are not equivalent. Internally, a "bias" factor is used to convert
values estimated by one methods to values comparable with another
(see AJTMHv75 supplement 2 pp20-21).
This option allows specification of which methodology the density
given in the diagnostic specification is measured with. Values
allowed are: Malariatherapy, Garki and Other. If not specified,
Other is assumed, unless the GARKI_DENSITY_BIAS model option is used,
in which case this option must be specified.

name:	Parasite density units / methodology"""
            self._metadata: dict = {'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['Other', 'Garki', 'Malariatherapy']}, 'type': 'xs:string'}

    class _Mechanism(AttributeNode):
        """Generated class for 'mechanism'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mechanism', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Mechanism by which this diagnostic functions.
Possible values are: HRP2, Other. In the case of HRP2, infections with
an hrp2_deletion will be invisible to this diagnostic. In the case of
Other, the diagnostic is unaffected by infection genome.
The diagnostic used for monitoring cannot use HRP2. (This is a
restriction made to simplify implementation.)

name:	Mechanism"""
            self._metadata: dict = {'default': 'Other', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['Other', 'HRP2']}, 'type': 'xs:string'}


class OM21Deterministic(Node):
    """Generated class for 'deterministic'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='deterministic', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Specify that an artificial deterministic test is used: outcome is
positive if parasite density is at least the minimum given.

name:	Deterministic detection"""
        self._metadata: dict = {'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'minDensity': 'required'}, 'children': {}}
        self.minDensity: OM21Deterministic._MinDensity = self._MinDensity(xml_tree=xml_tree, parent=self)

    class _MinDensity(AttributeNode):
        """Generated class for 'minDensity'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='minDensity', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The minimum density at which parasites can be detected. If 0,
the test outcome is always positive.

name:	Minimum detectible density
units:	parasites/microlitre
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM22Stochastic(Node):
    """Generated class for 'stochastic'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='stochastic', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
An improved model of detection which is non-deterministic, including
false positive results as well as false negatives.
The probability of a positive outcome is modelled as 1 + s(x/(x+d) - 1)
where x is the parasite density, d is the density at which the test outcome
has a 50% chance of being positive, and s is the probability of a positive
outcome given no parasites (the specificity).
Some parameterisations:
Microscopy sensitivity/specificity data in Africa;
Source: expert opinion  Allan Schapira
dens_50 = 20.0
specificity = .75
RDT sensitivity/specificity for Plasmodium falciparum in Africa
Source: Murray et al (Clinical Microbiological Reviews, Jan. 2008)
dens_50 = 50.0;
specificity = .942;

name:	Non-deterministic detection"""
        self._metadata: dict = {'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'dens_50': 'required', 'specificity': 'required'}, 'children': {}}
        self.dens_50: OM22Stochastic._Dens_50 = self._Dens_50(xml_tree=xml_tree, parent=self)
        self.specificity: OM22Stochastic._Specificity = self._Specificity(xml_tree=xml_tree, parent=self)

    class _Dens_50(AttributeNode):
        """Generated class for 'dens_50'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='dens_50', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The density at which the test outcome has a 50% chance of being positive.

name:	Density 50
units:	parasites/microlitre
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Specificity(AttributeNode):
        """Generated class for 'specificity'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='specificity', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The probability of a positive test outcome in the absense of parasites.

units:	Dimensionless
name:	Specificity
min:	0
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM23NeonatalMortality(Node):
    """Generated class for 'NeonatalMortality'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='NeonatalMortality', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """name:	Neonatal mortality parameters"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'diagnostic': 'required'}, 'children': {}}
        self.diagnostic: OM23NeonatalMortality._Diagnostic = self._Diagnostic(xml_tree=xml_tree, parent=self)

    class _Diagnostic(AttributeNode):
        """Generated class for 'diagnostic'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='diagnostic', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The name of a diagnostic used to parameterise the model.
Neonatal mortality is derived from malaria patency of a certain
sub-population of humans. This is the diagnostic used to asses
patency for this purpose.
If this is not specified, the monitoring diagnostic is used.

name:	Diagnostic used to parameterise model"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM24NonMalariaFevers(Node):
    """Generated class for 'NonMalariaFevers'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='NonMalariaFevers', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['incidence', 'prNeedTreatmentNMF', 'prNeedTreatmentMF']}, 'attributes': {}, 'children': {'incidence': {'minOccurs': '1', 'maxOccurs': '1'}, 'prNeedTreatmentNMF': {'minOccurs': '0', 'maxOccurs': '1'}, 'prNeedTreatmentMF': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self._incidence: OM25Incidence | None = None
        self._prNeedTreatmentNMF: OM26PrNeedTreatmentNMF | None = None
        self._prNeedTreatmentMF: OM27PrNeedTreatmentMF | None = None

    @property
    def incidence(self) -> 'OM25Incidence':
        """Initialize 'incidence'."""
        if self._incidence is None:
            self._incidence = OM25Incidence(xml_tree=self.xml_tree, parent=self)
        return self._incidence

    @property
    def prNeedTreatmentNMF(self) -> 'OM26PrNeedTreatmentNMF':
        """Initialize 'prNeedTreatmentNMF'."""
        if self._prNeedTreatmentNMF is None:
            self._prNeedTreatmentNMF = OM26PrNeedTreatmentNMF(xml_tree=self.xml_tree, parent=self)
        return self._prNeedTreatmentNMF

    @property
    def prNeedTreatmentMF(self) -> 'OM27PrNeedTreatmentMF':
        """Initialize 'prNeedTreatmentMF'."""
        if self._prNeedTreatmentMF is None:
            self._prNeedTreatmentMF = OM27PrNeedTreatmentMF(xml_tree=self.xml_tree, parent=self)
        return self._prNeedTreatmentMF


class OM25Incidence(Node):
    """Generated class for 'incidence'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='incidence', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that a non-malaria fever occurs given that no concurrent
malaria fever occurs.

name:	P(NMF)
 units:	Dimensionless
min:	0.0
max:	1.0"""
        self._metadata: dict = {'type': 'om:AgeGroupValues', 'children_metadata': {'ordered': 'sequence', 'order': ['group']}, 'attributes': {'interpolation': 'optional'}, 'children': {'group': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.interpolation: OM25Incidence._Interpolation = self._Interpolation(xml_tree=xml_tree, parent=self)
        self._group: OM293Group | None = None

    @property
    def group(self) -> 'OM293Group':
        """Initialize 'group'."""
        if self._group is None:
            self._group = OM293Group(xml_tree=self.xml_tree, parent=self)
        return self._group

    class _Interpolation(AttributeNode):
        """Generated class for 'interpolation'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interpolation', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Interpolation algorithm. Normally it is desirable for age-based
values to be continuous w.r.t. age. By default linear interpolation
is used.
With all algorithms except "none", the age groups are converted to a
set of points centred within each age range. Extra
points are added at each end (zero and infinity) to keep value
constant at both ends of the function. A zero-length age group may
be used as a kind of barrier to adjust the distribution; e.g. with
age group boundaries at 15, 20 and 25 years, a (linear) spline would
be drawn between ages 17.5 and 22.5, whereas with boundaries at
15, 20 and 20 years, a spline would be drawn between ages 17.5 and 20
years (may be desired if individuals are assumed to reach adult size
at 20).
Algorithms:
1. none: input values are used directly
2. linear: straight lines (on an age vs. value graph) are used to
interpolate data points.

name:	interpolation"""
            self._metadata: dict = {'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['none', 'linear']}, 'type': 'xs:string'}


class OM26PrNeedTreatmentNMF(Node):
    """Generated class for 'prNeedTreatmentNMF'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='prNeedTreatmentNMF', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that a non-malarial fever requires treatment with
antibiotics (assuming fever is not induced by malaria, although
concurrent parasites may be present).

name:	P(need treatment | NMF)
units:	Dimensionless
min:	0
max:	1"""
        self._metadata: dict = {'type': 'om:AgeGroupValues', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['group']}, 'attributes': {'interpolation': 'optional'}, 'children': {'group': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.interpolation: OM26PrNeedTreatmentNMF._Interpolation = self._Interpolation(xml_tree=xml_tree, parent=self)
        self._group: OM293Group | None = None

    @property
    def group(self) -> 'OM293Group':
        """Initialize 'group'."""
        if self._group is None:
            self._group = OM293Group(xml_tree=self.xml_tree, parent=self)
        return self._group

    class _Interpolation(AttributeNode):
        """Generated class for 'interpolation'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interpolation', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Interpolation algorithm. Normally it is desirable for age-based
values to be continuous w.r.t. age. By default linear interpolation
is used.
With all algorithms except "none", the age groups are converted to a
set of points centred within each age range. Extra
points are added at each end (zero and infinity) to keep value
constant at both ends of the function. A zero-length age group may
be used as a kind of barrier to adjust the distribution; e.g. with
age group boundaries at 15, 20 and 25 years, a (linear) spline would
be drawn between ages 17.5 and 22.5, whereas with boundaries at
15, 20 and 20 years, a spline would be drawn between ages 17.5 and 20
years (may be desired if individuals are assumed to reach adult size
at 20).
Algorithms:
1. none: input values are used directly
2. linear: straight lines (on an age vs. value graph) are used to
interpolate data points.

name:	interpolation"""
            self._metadata: dict = {'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['none', 'linear']}, 'type': 'xs:string'}


class OM27PrNeedTreatmentMF(Node):
    """Generated class for 'prNeedTreatmentMF'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='prNeedTreatmentMF', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that a malaria fever needs treatment with
antibiotics (assuming fever is induced by malaria, although
concurrent bacteria may be present).
Meaning partially overlaps with separate model for comorbidity
given malaria.

name:	P(need treatment | MF)
units:	Dimensionless
min:	0
max:	1"""
        self._metadata: dict = {'type': 'om:AgeGroupValues', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['group']}, 'attributes': {'interpolation': 'optional'}, 'children': {'group': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.interpolation: OM27PrNeedTreatmentMF._Interpolation = self._Interpolation(xml_tree=xml_tree, parent=self)
        self._group: OM293Group | None = None

    @property
    def group(self) -> 'OM293Group':
        """Initialize 'group'."""
        if self._group is None:
            self._group = OM293Group(xml_tree=self.xml_tree, parent=self)
        return self._group

    class _Interpolation(AttributeNode):
        """Generated class for 'interpolation'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interpolation', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Interpolation algorithm. Normally it is desirable for age-based
values to be continuous w.r.t. age. By default linear interpolation
is used.
With all algorithms except "none", the age groups are converted to a
set of points centred within each age range. Extra
points are added at each end (zero and infinity) to keep value
constant at both ends of the function. A zero-length age group may
be used as a kind of barrier to adjust the distribution; e.g. with
age group boundaries at 15, 20 and 25 years, a (linear) spline would
be drawn between ages 17.5 and 22.5, whereas with boundaries at
15, 20 and 20 years, a spline would be drawn between ages 17.5 and 20
years (may be desired if individuals are assumed to reach adult size
at 20).
Algorithms:
1. none: input values are used directly
2. linear: straight lines (on an age vs. value graph) are used to
interpolate data points.

name:	interpolation"""
            self._metadata: dict = {'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['none', 'linear']}, 'type': 'xs:string'}


class OM28EventScheduler(Node):
    """Generated class for 'EventScheduler'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='EventScheduler', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'type': 'om:HSEventScheduler', 'children_metadata': {'ordered': 'sequence', 'order': ['uncomplicated', 'complicated', 'ClinicalOutcomes', 'NonMalariaFevers']}, 'attributes': {}, 'children': {'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'complicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'ClinicalOutcomes': {'minOccurs': '1', 'maxOccurs': '1'}, 'NonMalariaFevers': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self._uncomplicated: OM69Uncomplicated | None = None
        self._complicated: OM70Complicated | None = None
        self._ClinicalOutcomes: OM71ClinicalOutcomes | None = None
        self._NonMalariaFevers: OM72NonMalariaFevers | None = None

    @property
    def uncomplicated(self) -> 'OM69Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM69Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def complicated(self) -> 'OM70Complicated':
        """Initialize 'complicated'."""
        if self._complicated is None:
            self._complicated = OM70Complicated(xml_tree=self.xml_tree, parent=self)
        return self._complicated

    @property
    def ClinicalOutcomes(self) -> 'OM71ClinicalOutcomes':
        """Initialize 'ClinicalOutcomes'."""
        if self._ClinicalOutcomes is None:
            self._ClinicalOutcomes = OM71ClinicalOutcomes(xml_tree=self.xml_tree, parent=self)
        return self._ClinicalOutcomes

    @property
    def NonMalariaFevers(self) -> 'OM72NonMalariaFevers':
        """Initialize 'NonMalariaFevers'."""
        if self._NonMalariaFevers is None:
            self._NonMalariaFevers = OM72NonMalariaFevers(xml_tree=self.xml_tree, parent=self)
        return self._NonMalariaFevers


class OM29ImmediateOutcomes(Node):
    """Generated class for 'ImmediateOutcomes'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='ImmediateOutcomes', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of "immediate outcomes" health system:
Tediosi et al case management model (Case management as
described in AJTMH 75 (suppl 2) pp90-103).

name:	Case Management (Tediosi et al)"""
        self._metadata: dict = {'type': 'om:HSImmediateOutcomes', 'children_metadata': {'ordered': 'all', 'order': ['drugRegimen', 'initialACR', 'compliance', 'nonCompliersEffective', 'treatmentActions', 'pSeekOfficialCareUncomplicated1', 'pSelfTreatUncomplicated', 'pSeekOfficialCareUncomplicated2', 'pSeekOfficialCareSevere', 'liverStageDrug']}, 'attributes': {'name': 'optional', 'useDiagnosticUC': ''}, 'children': {'drugRegimen': {'minOccurs': '1', 'maxOccurs': '1'}, 'initialACR': {'minOccurs': '1', 'maxOccurs': '1'}, 'compliance': {'minOccurs': '1', 'maxOccurs': '1'}, 'nonCompliersEffective': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatmentActions': {'minOccurs': '1', 'maxOccurs': '1'}, 'pSeekOfficialCareUncomplicated1': {'minOccurs': '1', 'maxOccurs': '1'}, 'pSelfTreatUncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'pSeekOfficialCareUncomplicated2': {'minOccurs': '1', 'maxOccurs': '1'}, 'pSeekOfficialCareSevere': {'minOccurs': '1', 'maxOccurs': '1'}, 'liverStageDrug': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self.name: OM29ImmediateOutcomes._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.useDiagnosticUC: OM29ImmediateOutcomes._UseDiagnosticUC = self._UseDiagnosticUC(xml_tree=xml_tree, parent=self)
        self._drugRegimen: OM37DrugRegimen | None = None
        self._initialACR: OM38InitialACR | None = None
        self._compliance: OM39Compliance | None = None
        self._nonCompliersEffective: OM40NonCompliersEffective | None = None
        self._treatmentActions: OM41TreatmentActions | None = None
        self._pSeekOfficialCareUncomplicated1: OM48PSeekOfficialCareUncomplicated1 | None = None
        self._pSelfTreatUncomplicated: OM49PSelfTreatUncomplicated | None = None
        self._pSeekOfficialCareUncomplicated2: OM50PSeekOfficialCareUncomplicated2 | None = None
        self._pSeekOfficialCareSevere: OM51PSeekOfficialCareSevere | None = None
        self._liverStageDrug: OM52LiverStageDrug | None = None

    @property
    def drugRegimen(self) -> 'OM37DrugRegimen':
        """Initialize 'drugRegimen'."""
        if self._drugRegimen is None:
            self._drugRegimen = OM37DrugRegimen(xml_tree=self.xml_tree, parent=self)
        return self._drugRegimen

    @property
    def initialACR(self) -> 'OM38InitialACR':
        """Initialize 'initialACR'."""
        if self._initialACR is None:
            self._initialACR = OM38InitialACR(xml_tree=self.xml_tree, parent=self)
        return self._initialACR

    @property
    def compliance(self) -> 'OM39Compliance':
        """Initialize 'compliance'."""
        if self._compliance is None:
            self._compliance = OM39Compliance(xml_tree=self.xml_tree, parent=self)
        return self._compliance

    @property
    def nonCompliersEffective(self) -> 'OM40NonCompliersEffective':
        """Initialize 'nonCompliersEffective'."""
        if self._nonCompliersEffective is None:
            self._nonCompliersEffective = OM40NonCompliersEffective(xml_tree=self.xml_tree, parent=self)
        return self._nonCompliersEffective

    @property
    def treatmentActions(self) -> 'OM41TreatmentActions':
        """Initialize 'treatmentActions'."""
        if self._treatmentActions is None:
            self._treatmentActions = OM41TreatmentActions(xml_tree=self.xml_tree, parent=self)
        return self._treatmentActions

    @property
    def pSeekOfficialCareUncomplicated1(self) -> 'OM48PSeekOfficialCareUncomplicated1':
        """Initialize 'pSeekOfficialCareUncomplicated1'."""
        if self._pSeekOfficialCareUncomplicated1 is None:
            self._pSeekOfficialCareUncomplicated1 = OM48PSeekOfficialCareUncomplicated1(xml_tree=self.xml_tree, parent=self)
        return self._pSeekOfficialCareUncomplicated1

    @property
    def pSelfTreatUncomplicated(self) -> 'OM49PSelfTreatUncomplicated':
        """Initialize 'pSelfTreatUncomplicated'."""
        if self._pSelfTreatUncomplicated is None:
            self._pSelfTreatUncomplicated = OM49PSelfTreatUncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._pSelfTreatUncomplicated

    @property
    def pSeekOfficialCareUncomplicated2(self) -> 'OM50PSeekOfficialCareUncomplicated2':
        """Initialize 'pSeekOfficialCareUncomplicated2'."""
        if self._pSeekOfficialCareUncomplicated2 is None:
            self._pSeekOfficialCareUncomplicated2 = OM50PSeekOfficialCareUncomplicated2(xml_tree=self.xml_tree, parent=self)
        return self._pSeekOfficialCareUncomplicated2

    @property
    def pSeekOfficialCareSevere(self) -> 'OM51PSeekOfficialCareSevere':
        """Initialize 'pSeekOfficialCareSevere'."""
        if self._pSeekOfficialCareSevere is None:
            self._pSeekOfficialCareSevere = OM51PSeekOfficialCareSevere(xml_tree=self.xml_tree, parent=self)
        return self._pSeekOfficialCareSevere

    @property
    def liverStageDrug(self) -> 'OM52LiverStageDrug':
        """Initialize 'liverStageDrug'."""
        if self._liverStageDrug is None:
            self._liverStageDrug = OM52LiverStageDrug(xml_tree=self.xml_tree, parent=self)
        return self._liverStageDrug

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of health system

name:	Name of case management parameterisation"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _UseDiagnosticUC(AttributeNode):
        """Generated class for 'useDiagnosticUC'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='useDiagnosticUC', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}


class OM30DecisionTree5Day(Node):
    """Generated class for 'DecisionTree5Day'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='DecisionTree5Day', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of the health system using the 5-day timestep with decision
tree model: access is configured as in the Tediosi et al case
management model (Case management as described in AJTMH 75 (suppl 2)
pp90-103) while treatment decisions are configured via decision trees.
Besides greater flexibility, this allows treatment via PK/PD models.

name:	Case Management (Tediosi et al with programmable decision trees)"""
        self._metadata: dict = {'type': 'om:HSDT5Day', 'children_metadata': {'ordered': 'all', 'order': ['pSeekOfficialCareUncomplicated1', 'pSelfTreatUncomplicated', 'pSeekOfficialCareUncomplicated2', 'pSeekOfficialCareSevere', 'liverStageDrug', 'treeUCOfficial', 'treeUCSelfTreat', 'cureRateSevere', 'treatmentSevere']}, 'attributes': {'name': 'optional'}, 'children': {'pSeekOfficialCareUncomplicated1': {'minOccurs': '1', 'maxOccurs': '1'}, 'pSelfTreatUncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'pSeekOfficialCareUncomplicated2': {'minOccurs': '1', 'maxOccurs': '1'}, 'pSeekOfficialCareSevere': {'minOccurs': '1', 'maxOccurs': '1'}, 'liverStageDrug': {'minOccurs': '0', 'maxOccurs': '1'}, 'treeUCOfficial': {'minOccurs': '1', 'maxOccurs': '1'}, 'treeUCSelfTreat': {'minOccurs': '1', 'maxOccurs': '1'}, 'cureRateSevere': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatmentSevere': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM30DecisionTree5Day._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._pSeekOfficialCareUncomplicated1: OM48PSeekOfficialCareUncomplicated1 | None = None
        self._pSelfTreatUncomplicated: OM49PSelfTreatUncomplicated | None = None
        self._pSeekOfficialCareUncomplicated2: OM50PSeekOfficialCareUncomplicated2 | None = None
        self._pSeekOfficialCareSevere: OM51PSeekOfficialCareSevere | None = None
        self._liverStageDrug: OM52LiverStageDrug | None = None
        self._treeUCOfficial: OM65TreeUCOfficial | None = None
        self._treeUCSelfTreat: OM66TreeUCSelfTreat | None = None
        self._cureRateSevere: OM67CureRateSevere | None = None
        self._treatmentSevere: OM68TreatmentSevere | None = None

    @property
    def pSeekOfficialCareUncomplicated1(self) -> 'OM48PSeekOfficialCareUncomplicated1':
        """Initialize 'pSeekOfficialCareUncomplicated1'."""
        if self._pSeekOfficialCareUncomplicated1 is None:
            self._pSeekOfficialCareUncomplicated1 = OM48PSeekOfficialCareUncomplicated1(xml_tree=self.xml_tree, parent=self)
        return self._pSeekOfficialCareUncomplicated1

    @property
    def pSelfTreatUncomplicated(self) -> 'OM49PSelfTreatUncomplicated':
        """Initialize 'pSelfTreatUncomplicated'."""
        if self._pSelfTreatUncomplicated is None:
            self._pSelfTreatUncomplicated = OM49PSelfTreatUncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._pSelfTreatUncomplicated

    @property
    def pSeekOfficialCareUncomplicated2(self) -> 'OM50PSeekOfficialCareUncomplicated2':
        """Initialize 'pSeekOfficialCareUncomplicated2'."""
        if self._pSeekOfficialCareUncomplicated2 is None:
            self._pSeekOfficialCareUncomplicated2 = OM50PSeekOfficialCareUncomplicated2(xml_tree=self.xml_tree, parent=self)
        return self._pSeekOfficialCareUncomplicated2

    @property
    def pSeekOfficialCareSevere(self) -> 'OM51PSeekOfficialCareSevere':
        """Initialize 'pSeekOfficialCareSevere'."""
        if self._pSeekOfficialCareSevere is None:
            self._pSeekOfficialCareSevere = OM51PSeekOfficialCareSevere(xml_tree=self.xml_tree, parent=self)
        return self._pSeekOfficialCareSevere

    @property
    def liverStageDrug(self) -> 'OM52LiverStageDrug':
        """Initialize 'liverStageDrug'."""
        if self._liverStageDrug is None:
            self._liverStageDrug = OM52LiverStageDrug(xml_tree=self.xml_tree, parent=self)
        return self._liverStageDrug

    @property
    def treeUCOfficial(self) -> 'OM65TreeUCOfficial':
        """Initialize 'treeUCOfficial'."""
        if self._treeUCOfficial is None:
            self._treeUCOfficial = OM65TreeUCOfficial(xml_tree=self.xml_tree, parent=self)
        return self._treeUCOfficial

    @property
    def treeUCSelfTreat(self) -> 'OM66TreeUCSelfTreat':
        """Initialize 'treeUCSelfTreat'."""
        if self._treeUCSelfTreat is None:
            self._treeUCSelfTreat = OM66TreeUCSelfTreat(xml_tree=self.xml_tree, parent=self)
        return self._treeUCSelfTreat

    @property
    def cureRateSevere(self) -> 'OM67CureRateSevere':
        """Initialize 'cureRateSevere'."""
        if self._cureRateSevere is None:
            self._cureRateSevere = OM67CureRateSevere(xml_tree=self.xml_tree, parent=self)
        return self._cureRateSevere

    @property
    def treatmentSevere(self) -> 'OM68TreatmentSevere':
        """Initialize 'treatmentSevere'."""
        if self._treatmentSevere is None:
            self._treatmentSevere = OM68TreatmentSevere(xml_tree=self.xml_tree, parent=self)
        return self._treatmentSevere

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of health system

name:	Name of case management parameterisation"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM31CFR(Node):
    """Generated class for 'CFR'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='CFR', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Case fatality rate (probability of an inpatient fatality from a
bout of severe malaria, per age-group).

name:	Case fatality rate for inpatients"""
        self._metadata: dict = {'type': 'om:AgeGroupValues', 'children_metadata': {'ordered': 'sequence', 'order': ['group']}, 'attributes': {'interpolation': 'optional'}, 'children': {'group': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.interpolation: OM31CFR._Interpolation = self._Interpolation(xml_tree=xml_tree, parent=self)
        self._group: OM293Group | None = None

    @property
    def group(self) -> 'OM293Group':
        """Initialize 'group'."""
        if self._group is None:
            self._group = OM293Group(xml_tree=self.xml_tree, parent=self)
        return self._group

    class _Interpolation(AttributeNode):
        """Generated class for 'interpolation'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interpolation', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Interpolation algorithm. Normally it is desirable for age-based
values to be continuous w.r.t. age. By default linear interpolation
is used.
With all algorithms except "none", the age groups are converted to a
set of points centred within each age range. Extra
points are added at each end (zero and infinity) to keep value
constant at both ends of the function. A zero-length age group may
be used as a kind of barrier to adjust the distribution; e.g. with
age group boundaries at 15, 20 and 25 years, a (linear) spline would
be drawn between ages 17.5 and 22.5, whereas with boundaries at
15, 20 and 20 years, a spline would be drawn between ages 17.5 and 20
years (may be desired if individuals are assumed to reach adult size
at 20).
Algorithms:
1. none: input values are used directly
2. linear: straight lines (on an age vs. value graph) are used to
interpolate data points.

name:	interpolation"""
            self._metadata: dict = {'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['none', 'linear']}, 'type': 'xs:string'}


class OM32PSequelaeInpatient(Node):
    """Generated class for 'pSequelaeInpatient'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pSequelaeInpatient', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
List of age-specific probabilities of sequelae in inpatients,
during a severe bout of malaria.

units:	Dimensionless
name:	Probabilities of sequelae in inpatients"""
        self._metadata: dict = {'type': 'om:AgeGroupValues', 'children_metadata': {'ordered': 'sequence', 'order': ['group']}, 'attributes': {'interpolation': 'optional'}, 'children': {'group': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.interpolation: OM32PSequelaeInpatient._Interpolation = self._Interpolation(xml_tree=xml_tree, parent=self)
        self._group: OM293Group | None = None

    @property
    def group(self) -> 'OM293Group':
        """Initialize 'group'."""
        if self._group is None:
            self._group = OM293Group(xml_tree=self.xml_tree, parent=self)
        return self._group

    class _Interpolation(AttributeNode):
        """Generated class for 'interpolation'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interpolation', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Interpolation algorithm. Normally it is desirable for age-based
values to be continuous w.r.t. age. By default linear interpolation
is used.
With all algorithms except "none", the age groups are converted to a
set of points centred within each age range. Extra
points are added at each end (zero and infinity) to keep value
constant at both ends of the function. A zero-length age group may
be used as a kind of barrier to adjust the distribution; e.g. with
age group boundaries at 15, 20 and 25 years, a (linear) spline would
be drawn between ages 17.5 and 22.5, whereas with boundaries at
15, 20 and 20 years, a spline would be drawn between ages 17.5 and 20
years (may be desired if individuals are assumed to reach adult size
at 20).
Algorithms:
1. none: input values are used directly
2. linear: straight lines (on an age vs. value graph) are used to
interpolate data points.

name:	interpolation"""
            self._metadata: dict = {'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['none', 'linear']}, 'type': 'xs:string'}


class OM33PHumanCannotReceive(Node):
    """Generated class for 'pHumanCannotReceive'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pHumanCannotReceive', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Chance that a human is determined to be unable to receive liver-stage drug
treatment. Treatment is neither reported or given for such humans.
This is sampled once per human at birth.

units:	Probability
min:	0
max:	1

            name:	Probability that human is incompatible with liver-stage drug treatment"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM33PHumanCannotReceive._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM34IgnoreCannotReceive(Node):
    """Generated class for 'ignoreCannotReceive'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='ignoreCannotReceive', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
If true, ignore pHumanCannotReceive and consider all humans eligible
for treatment; if false (or not specified), do not treat those demed
incompatible with liver-stage drug treatment.
The point of this is that pHumanCannotReceive cannot be altered by
changeHS interventions, but this property can be.

name:	Ignore liver-stage drug treatment incompatibility"""
        self._metadata: dict = {'type': 'om:BooleanValue', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM34IgnoreCannotReceive._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A boolean value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:boolean', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM35PUseUncomplicated(Node):
    """Generated class for 'pUseUncomplicated'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pUseUncomplicated', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
This feature is deprecated; it is suggested to use the "simple
treatment" feature configured to clear liver-stage parasites,
leaving this option unset or zero.
Chance of liver-stage drug treatment being used for routine treatment of an
uncomplicated case.

units:	Probability
min:	0
max:	1
name:	Prob use in UC case"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM35PUseUncomplicated._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM36EffectivenessOnUse(Node):
    """Generated class for 'effectivenessOnUse'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='effectivenessOnUse', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Chance that liver-stage drug treatment is effective.
On application, a random variable is sampled against this probability.
If false, the treatment does nothing; if true, the treatment clears all
liver stage parasites. Where effectiveness is longer than a single
time step (prophylactic effect), this sample still only happens once
(thus either no effect or all liver stages cleared over multiple steps).

units:	Probability
min:	0
max:	1
name:	Effectiveness"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM36EffectivenessOnUse._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM37DrugRegimen(Node):
    """Generated class for 'drugRegimen'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='drugRegimen', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of drug regimen.

name:	Description of drug regimen"""
        self._metadata: dict = {'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'firstLine': 'required', 'secondLine': 'required', 'inpatient': 'required'}, 'children': {}}
        self.firstLine: OM37DrugRegimen._FirstLine = self._FirstLine(xml_tree=xml_tree, parent=self)
        self.secondLine: OM37DrugRegimen._SecondLine = self._SecondLine(xml_tree=xml_tree, parent=self)
        self.inpatient: OM37DrugRegimen._Inpatient = self._Inpatient(xml_tree=xml_tree, parent=self)

    class _FirstLine(AttributeNode):
        """Generated class for 'firstLine'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='firstLine', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Code for first line drug

units:	Drug code
name:	First line drug"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _SecondLine(AttributeNode):
        """Generated class for 'secondLine'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='secondLine', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Code for second line drug

units:	Drug code
name:	Second line drug"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Inpatient(AttributeNode):
        """Generated class for 'inpatient'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='inpatient', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Code for drug used for treating
inpatients

units:	Drug code
name:	Drug use for treating inpatients"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM38InitialACR(Node):
    """Generated class for 'initialACR'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='initialACR', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Initial cure rate

units:	Dimensionless
min:	0.0
max:	1.0
name:	Initial cure rate"""
        self._metadata: dict = {'type': 'om:TreatmentDetails', 'children_metadata': {'ordered': 'sequence', 'order': ['CQ', 'SP', 'AQ', 'SPAQ', 'ACT', 'QN', 'selfTreatment']}, 'attributes': {}, 'children': {'CQ': {'minOccurs': '0', 'maxOccurs': '1'}, 'SP': {'minOccurs': '0', 'maxOccurs': '1'}, 'AQ': {'minOccurs': '0', 'maxOccurs': '1'}, 'SPAQ': {'minOccurs': '0', 'maxOccurs': '1'}, 'ACT': {'minOccurs': '0', 'maxOccurs': '1'}, 'QN': {'minOccurs': '0', 'maxOccurs': '1'}, 'selfTreatment': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._CQ: OM53CQ | None = None
        self._SP: OM54SP | None = None
        self._AQ: OM55AQ | None = None
        self._SPAQ: OM56SPAQ | None = None
        self._ACT: OM57ACT | None = None
        self._QN: OM58QN | None = None
        self._selfTreatment: OM59SelfTreatment | None = None

    @property
    def CQ(self) -> 'OM53CQ':
        """Initialize 'CQ'."""
        if self._CQ is None:
            self._CQ = OM53CQ(xml_tree=self.xml_tree, parent=self)
        return self._CQ

    @property
    def SP(self) -> 'OM54SP':
        """Initialize 'SP'."""
        if self._SP is None:
            self._SP = OM54SP(xml_tree=self.xml_tree, parent=self)
        return self._SP

    @property
    def AQ(self) -> 'OM55AQ':
        """Initialize 'AQ'."""
        if self._AQ is None:
            self._AQ = OM55AQ(xml_tree=self.xml_tree, parent=self)
        return self._AQ

    @property
    def SPAQ(self) -> 'OM56SPAQ':
        """Initialize 'SPAQ'."""
        if self._SPAQ is None:
            self._SPAQ = OM56SPAQ(xml_tree=self.xml_tree, parent=self)
        return self._SPAQ

    @property
    def ACT(self) -> 'OM57ACT':
        """Initialize 'ACT'."""
        if self._ACT is None:
            self._ACT = OM57ACT(xml_tree=self.xml_tree, parent=self)
        return self._ACT

    @property
    def QN(self) -> 'OM58QN':
        """Initialize 'QN'."""
        if self._QN is None:
            self._QN = OM58QN(xml_tree=self.xml_tree, parent=self)
        return self._QN

    @property
    def selfTreatment(self) -> 'OM59SelfTreatment':
        """Initialize 'selfTreatment'."""
        if self._selfTreatment is None:
            self._selfTreatment = OM59SelfTreatment(xml_tree=self.xml_tree, parent=self)
        return self._selfTreatment


class OM39Compliance(Node):
    """Generated class for 'compliance'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='compliance', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Adherence to treatment

units:	Dimensionless
min:	0.0
max:	1.0
name:	Adherence to treatment"""
        self._metadata: dict = {'type': 'om:TreatmentDetails', 'children_metadata': {'ordered': 'sequence', 'order': ['CQ', 'SP', 'AQ', 'SPAQ', 'ACT', 'QN', 'selfTreatment']}, 'attributes': {}, 'children': {'CQ': {'minOccurs': '0', 'maxOccurs': '1'}, 'SP': {'minOccurs': '0', 'maxOccurs': '1'}, 'AQ': {'minOccurs': '0', 'maxOccurs': '1'}, 'SPAQ': {'minOccurs': '0', 'maxOccurs': '1'}, 'ACT': {'minOccurs': '0', 'maxOccurs': '1'}, 'QN': {'minOccurs': '0', 'maxOccurs': '1'}, 'selfTreatment': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._CQ: OM53CQ | None = None
        self._SP: OM54SP | None = None
        self._AQ: OM55AQ | None = None
        self._SPAQ: OM56SPAQ | None = None
        self._ACT: OM57ACT | None = None
        self._QN: OM58QN | None = None
        self._selfTreatment: OM59SelfTreatment | None = None

    @property
    def CQ(self) -> 'OM53CQ':
        """Initialize 'CQ'."""
        if self._CQ is None:
            self._CQ = OM53CQ(xml_tree=self.xml_tree, parent=self)
        return self._CQ

    @property
    def SP(self) -> 'OM54SP':
        """Initialize 'SP'."""
        if self._SP is None:
            self._SP = OM54SP(xml_tree=self.xml_tree, parent=self)
        return self._SP

    @property
    def AQ(self) -> 'OM55AQ':
        """Initialize 'AQ'."""
        if self._AQ is None:
            self._AQ = OM55AQ(xml_tree=self.xml_tree, parent=self)
        return self._AQ

    @property
    def SPAQ(self) -> 'OM56SPAQ':
        """Initialize 'SPAQ'."""
        if self._SPAQ is None:
            self._SPAQ = OM56SPAQ(xml_tree=self.xml_tree, parent=self)
        return self._SPAQ

    @property
    def ACT(self) -> 'OM57ACT':
        """Initialize 'ACT'."""
        if self._ACT is None:
            self._ACT = OM57ACT(xml_tree=self.xml_tree, parent=self)
        return self._ACT

    @property
    def QN(self) -> 'OM58QN':
        """Initialize 'QN'."""
        if self._QN is None:
            self._QN = OM58QN(xml_tree=self.xml_tree, parent=self)
        return self._QN

    @property
    def selfTreatment(self) -> 'OM59SelfTreatment':
        """Initialize 'selfTreatment'."""
        if self._selfTreatment is None:
            self._selfTreatment = OM59SelfTreatment(xml_tree=self.xml_tree, parent=self)
        return self._selfTreatment


class OM40NonCompliersEffective(Node):
    """Generated class for 'nonCompliersEffective'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='nonCompliersEffective', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effectiveness of treatment for non-compliant patients

units:	Dimensionless
min:	0.0
max:	1.0
name:	Effectiveness of treatment in non-adherent patients"""
        self._metadata: dict = {'type': 'om:TreatmentDetails', 'children_metadata': {'ordered': 'sequence', 'order': ['CQ', 'SP', 'AQ', 'SPAQ', 'ACT', 'QN', 'selfTreatment']}, 'attributes': {}, 'children': {'CQ': {'minOccurs': '0', 'maxOccurs': '1'}, 'SP': {'minOccurs': '0', 'maxOccurs': '1'}, 'AQ': {'minOccurs': '0', 'maxOccurs': '1'}, 'SPAQ': {'minOccurs': '0', 'maxOccurs': '1'}, 'ACT': {'minOccurs': '0', 'maxOccurs': '1'}, 'QN': {'minOccurs': '0', 'maxOccurs': '1'}, 'selfTreatment': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._CQ: OM53CQ | None = None
        self._SP: OM54SP | None = None
        self._AQ: OM55AQ | None = None
        self._SPAQ: OM56SPAQ | None = None
        self._ACT: OM57ACT | None = None
        self._QN: OM58QN | None = None
        self._selfTreatment: OM59SelfTreatment | None = None

    @property
    def CQ(self) -> 'OM53CQ':
        """Initialize 'CQ'."""
        if self._CQ is None:
            self._CQ = OM53CQ(xml_tree=self.xml_tree, parent=self)
        return self._CQ

    @property
    def SP(self) -> 'OM54SP':
        """Initialize 'SP'."""
        if self._SP is None:
            self._SP = OM54SP(xml_tree=self.xml_tree, parent=self)
        return self._SP

    @property
    def AQ(self) -> 'OM55AQ':
        """Initialize 'AQ'."""
        if self._AQ is None:
            self._AQ = OM55AQ(xml_tree=self.xml_tree, parent=self)
        return self._AQ

    @property
    def SPAQ(self) -> 'OM56SPAQ':
        """Initialize 'SPAQ'."""
        if self._SPAQ is None:
            self._SPAQ = OM56SPAQ(xml_tree=self.xml_tree, parent=self)
        return self._SPAQ

    @property
    def ACT(self) -> 'OM57ACT':
        """Initialize 'ACT'."""
        if self._ACT is None:
            self._ACT = OM57ACT(xml_tree=self.xml_tree, parent=self)
        return self._ACT

    @property
    def QN(self) -> 'OM58QN':
        """Initialize 'QN'."""
        if self._QN is None:
            self._QN = OM58QN(xml_tree=self.xml_tree, parent=self)
        return self._QN

    @property
    def selfTreatment(self) -> 'OM59SelfTreatment':
        """Initialize 'selfTreatment'."""
        if self._selfTreatment is None:
            self._selfTreatment = OM59SelfTreatment(xml_tree=self.xml_tree, parent=self)
        return self._selfTreatment


class OM41TreatmentActions(Node):
    """Generated class for 'treatmentActions'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='treatmentActions', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'children_metadata': {'ordered': 'all', 'order': ['CQ', 'SP', 'AQ', 'SPAQ', 'ACT', 'QN']}, 'attributes': {}, 'children': {'CQ': {'minOccurs': '0', 'maxOccurs': '1'}, 'SP': {'minOccurs': '0', 'maxOccurs': '1'}, 'AQ': {'minOccurs': '0', 'maxOccurs': '1'}, 'SPAQ': {'minOccurs': '0', 'maxOccurs': '1'}, 'ACT': {'minOccurs': '0', 'maxOccurs': '1'}, 'QN': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self._CQ: OM42CQ | None = None
        self._SP: OM43SP | None = None
        self._AQ: OM44AQ | None = None
        self._SPAQ: OM45SPAQ | None = None
        self._ACT: OM46ACT | None = None
        self._QN: OM47QN | None = None

    @property
    def CQ(self) -> 'OM42CQ':
        """Initialize 'CQ'."""
        if self._CQ is None:
            self._CQ = OM42CQ(xml_tree=self.xml_tree, parent=self)
        return self._CQ

    @property
    def SP(self) -> 'OM43SP':
        """Initialize 'SP'."""
        if self._SP is None:
            self._SP = OM43SP(xml_tree=self.xml_tree, parent=self)
        return self._SP

    @property
    def AQ(self) -> 'OM44AQ':
        """Initialize 'AQ'."""
        if self._AQ is None:
            self._AQ = OM44AQ(xml_tree=self.xml_tree, parent=self)
        return self._AQ

    @property
    def SPAQ(self) -> 'OM45SPAQ':
        """Initialize 'SPAQ'."""
        if self._SPAQ is None:
            self._SPAQ = OM45SPAQ(xml_tree=self.xml_tree, parent=self)
        return self._SPAQ

    @property
    def ACT(self) -> 'OM46ACT':
        """Initialize 'ACT'."""
        if self._ACT is None:
            self._ACT = OM46ACT(xml_tree=self.xml_tree, parent=self)
        return self._ACT

    @property
    def QN(self) -> 'OM47QN':
        """Initialize 'QN'."""
        if self._QN is None:
            self._QN = OM47QN(xml_tree=self.xml_tree, parent=self)
        return self._QN


class OM42CQ(Node):
    """Generated class for 'CQ'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='CQ', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes the effects of the treatment, assuming this
compliance/adherence/... option is selected. Effects are described
in terms of a list of options, each of which acts independently but
with all effects being activated simultaneously.

name:	Group (for compliance/adherence/drug effect)
Base Type:
Lists intervention components which are deployed according to some
external trigger (for example, screening with a negative patency
outcome or health-system treatment).
Components are referenced from one or more sub-lists. Each of these
lists is deployed independently if and only if its age constraints are
met by the human host and a random sample with the given probability of
a positive outcome is positive.

name:	Triggered intervention deployment"""
        self._metadata: dict = {'type': 'om:TreatmentOption', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['deploy']}, 'attributes': {'name': 'optional'}, 'children': {'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.name: OM42CQ._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._deploy: OM97Deploy | None = None

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Describes what this compliance option represents (e.g.
"good compliance", "poor compliance with good drugs", ...).

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM43SP(Node):
    """Generated class for 'SP'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='SP', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes the effects of the treatment, assuming this
compliance/adherence/... option is selected. Effects are described
in terms of a list of options, each of which acts independently but
with all effects being activated simultaneously.

name:	Group (for compliance/adherence/drug effect)
Base Type:
Lists intervention components which are deployed according to some
external trigger (for example, screening with a negative patency
outcome or health-system treatment).
Components are referenced from one or more sub-lists. Each of these
lists is deployed independently if and only if its age constraints are
met by the human host and a random sample with the given probability of
a positive outcome is positive.

name:	Triggered intervention deployment"""
        self._metadata: dict = {'type': 'om:TreatmentOption', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['deploy']}, 'attributes': {'name': 'optional'}, 'children': {'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.name: OM43SP._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._deploy: OM97Deploy | None = None

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Describes what this compliance option represents (e.g.
"good compliance", "poor compliance with good drugs", ...).

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM44AQ(Node):
    """Generated class for 'AQ'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='AQ', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes the effects of the treatment, assuming this
compliance/adherence/... option is selected. Effects are described
in terms of a list of options, each of which acts independently but
with all effects being activated simultaneously.

name:	Group (for compliance/adherence/drug effect)
Base Type:
Lists intervention components which are deployed according to some
external trigger (for example, screening with a negative patency
outcome or health-system treatment).
Components are referenced from one or more sub-lists. Each of these
lists is deployed independently if and only if its age constraints are
met by the human host and a random sample with the given probability of
a positive outcome is positive.

name:	Triggered intervention deployment"""
        self._metadata: dict = {'type': 'om:TreatmentOption', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['deploy']}, 'attributes': {'name': 'optional'}, 'children': {'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.name: OM44AQ._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._deploy: OM97Deploy | None = None

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Describes what this compliance option represents (e.g.
"good compliance", "poor compliance with good drugs", ...).

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM45SPAQ(Node):
    """Generated class for 'SPAQ'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='SPAQ', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes the effects of the treatment, assuming this
compliance/adherence/... option is selected. Effects are described
in terms of a list of options, each of which acts independently but
with all effects being activated simultaneously.

name:	Group (for compliance/adherence/drug effect)
Base Type:
Lists intervention components which are deployed according to some
external trigger (for example, screening with a negative patency
outcome or health-system treatment).
Components are referenced from one or more sub-lists. Each of these
lists is deployed independently if and only if its age constraints are
met by the human host and a random sample with the given probability of
a positive outcome is positive.

name:	Triggered intervention deployment"""
        self._metadata: dict = {'type': 'om:TreatmentOption', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['deploy']}, 'attributes': {'name': 'optional'}, 'children': {'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.name: OM45SPAQ._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._deploy: OM97Deploy | None = None

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Describes what this compliance option represents (e.g.
"good compliance", "poor compliance with good drugs", ...).

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM46ACT(Node):
    """Generated class for 'ACT'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='ACT', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes the effects of the treatment, assuming this
compliance/adherence/... option is selected. Effects are described
in terms of a list of options, each of which acts independently but
with all effects being activated simultaneously.

name:	Group (for compliance/adherence/drug effect)
Base Type:
Lists intervention components which are deployed according to some
external trigger (for example, screening with a negative patency
outcome or health-system treatment).
Components are referenced from one or more sub-lists. Each of these
lists is deployed independently if and only if its age constraints are
met by the human host and a random sample with the given probability of
a positive outcome is positive.

name:	Triggered intervention deployment"""
        self._metadata: dict = {'type': 'om:TreatmentOption', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['deploy']}, 'attributes': {'name': 'optional'}, 'children': {'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.name: OM46ACT._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._deploy: OM97Deploy | None = None

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Describes what this compliance option represents (e.g.
"good compliance", "poor compliance with good drugs", ...).

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM47QN(Node):
    """Generated class for 'QN'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='QN', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes the effects of the treatment, assuming this
compliance/adherence/... option is selected. Effects are described
in terms of a list of options, each of which acts independently but
with all effects being activated simultaneously.

name:	Group (for compliance/adherence/drug effect)
Base Type:
Lists intervention components which are deployed according to some
external trigger (for example, screening with a negative patency
outcome or health-system treatment).
Components are referenced from one or more sub-lists. Each of these
lists is deployed independently if and only if its age constraints are
met by the human host and a random sample with the given probability of
a positive outcome is positive.

name:	Triggered intervention deployment"""
        self._metadata: dict = {'type': 'om:TreatmentOption', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['deploy']}, 'attributes': {'name': 'optional'}, 'children': {'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.name: OM47QN._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._deploy: OM97Deploy | None = None

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Describes what this compliance option represents (e.g.
"good compliance", "poor compliance with good drugs", ...).

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM48PSeekOfficialCareUncomplicated1(Node):
    """Generated class for 'pSeekOfficialCareUncomplicated1'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pSeekOfficialCareUncomplicated1', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that a patient with newly incident
uncomplicated disease seeks official care

units:	Dimensionless
min:	0.0
max:	1.0
name:	Probability that a patient with uncomplicated disease seeks official care immediately."""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM48PSeekOfficialCareUncomplicated1._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM49PSelfTreatUncomplicated(Node):
    """Generated class for 'pSelfTreatUncomplicated'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pSelfTreatUncomplicated', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that a patient with uncomplicated disease without
recent history of disease (i.e. first line) will self-treat.
Note that in second line cases there is no probability of self-treatment.

units:	Dimensionless
min:	0.0
max:	1.0
name:	Probability that a patient with uncomplicated disease will self-treat."""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM49PSelfTreatUncomplicated._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM50PSeekOfficialCareUncomplicated2(Node):
    """Generated class for 'pSeekOfficialCareUncomplicated2'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pSeekOfficialCareUncomplicated2', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that a patient with recurrence of
uncomplicated disease seeks official care

units:	Dimensionless
min:	0.0
max:	1.0
name:	Probability that a recurring patient seeks official care"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM50PSeekOfficialCareUncomplicated2._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM51PSeekOfficialCareSevere(Node):
    """Generated class for 'pSeekOfficialCareSevere'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pSeekOfficialCareSevere', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that a patient with severe disease
obtains appropriate care

units:	Dimensionless
min:	0.0
max:	1.0
name:	Probability that a patient with severe disease obtains appropriate care"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM51PSeekOfficialCareSevere._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM52LiverStageDrug(Node):
    """Generated class for 'liverStageDrug'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='liverStageDrug', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Parameters for drug treatment which have an effect on the liver-stage of parasites (Primaquine and potentially Tafenoquine); for use with the Vivax model only.
Note: if this section is not listed, the following default values are
assumed: pHumanCannotReceive=0, pUseUncomplicated=0,
effectivenessOnUse=1.

name:	Liver stage drug treatment parameters (Vivax)"""
        self._metadata: dict = {'type': 'om:LiverStageDrug', 'minOccurs': '0', 'children_metadata': {'ordered': 'all', 'order': ['pHumanCannotReceive', 'ignoreCannotReceive', 'pUseUncomplicated', 'effectivenessOnUse']}, 'attributes': {}, 'children': {'pHumanCannotReceive': {'minOccurs': '1', 'maxOccurs': '1'}, 'ignoreCannotReceive': {'minOccurs': '0', 'maxOccurs': '1'}, 'pUseUncomplicated': {'minOccurs': '0', 'maxOccurs': '1'}, 'effectivenessOnUse': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._pHumanCannotReceive: OM33PHumanCannotReceive | None = None
        self._ignoreCannotReceive: OM34IgnoreCannotReceive | None = None
        self._pUseUncomplicated: OM35PUseUncomplicated | None = None
        self._effectivenessOnUse: OM36EffectivenessOnUse | None = None

    @property
    def pHumanCannotReceive(self) -> 'OM33PHumanCannotReceive':
        """Initialize 'pHumanCannotReceive'."""
        if self._pHumanCannotReceive is None:
            self._pHumanCannotReceive = OM33PHumanCannotReceive(xml_tree=self.xml_tree, parent=self)
        return self._pHumanCannotReceive

    @property
    def ignoreCannotReceive(self) -> 'OM34IgnoreCannotReceive':
        """Initialize 'ignoreCannotReceive'."""
        if self._ignoreCannotReceive is None:
            self._ignoreCannotReceive = OM34IgnoreCannotReceive(xml_tree=self.xml_tree, parent=self)
        return self._ignoreCannotReceive

    @property
    def pUseUncomplicated(self) -> 'OM35PUseUncomplicated':
        """Initialize 'pUseUncomplicated'."""
        if self._pUseUncomplicated is None:
            self._pUseUncomplicated = OM35PUseUncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._pUseUncomplicated

    @property
    def effectivenessOnUse(self) -> 'OM36EffectivenessOnUse':
        """Initialize 'effectivenessOnUse'."""
        if self._effectivenessOnUse is None:
            self._effectivenessOnUse = OM36EffectivenessOnUse(xml_tree=self.xml_tree, parent=self)
        return self._effectivenessOnUse


class OM53CQ(Node):
    """Generated class for 'CQ'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='CQ', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Chloroquine
name:	Chloroquine"""
        self._metadata: dict = {'maxOccurs': '1', 'minOccurs': '0', 'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM53CQ._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM54SP(Node):
    """Generated class for 'SP'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='SP', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Sulphadoxine-pyrimethamine

name:	Sulphadoxine-pyrimethamine"""
        self._metadata: dict = {'maxOccurs': '1', 'minOccurs': '0', 'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM54SP._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM55AQ(Node):
    """Generated class for 'AQ'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='AQ', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Amodiaquine
name:	Amodiaquine"""
        self._metadata: dict = {'maxOccurs': '1', 'minOccurs': '0', 'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM55AQ._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM56SPAQ(Node):
    """Generated class for 'SPAQ'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='SPAQ', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Sulphadoxine-pyrimethamine/Amodiaquine

name:	Sulphadoxine-pyrimethamine/Amodiaquine"""
        self._metadata: dict = {'maxOccurs': '1', 'minOccurs': '0', 'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM56SPAQ._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM57ACT(Node):
    """Generated class for 'ACT'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='ACT', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Artemisinine combination therapy

name:	Artemisinine based combination therapy"""
        self._metadata: dict = {'maxOccurs': '1', 'minOccurs': '0', 'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM57ACT._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM58QN(Node):
    """Generated class for 'QN'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='QN', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Quinine
name:	Quinine"""
        self._metadata: dict = {'maxOccurs': '1', 'minOccurs': '0', 'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM58QN._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM59SelfTreatment(Node):
    """Generated class for 'selfTreatment'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='selfTreatment', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability of self-treatment

units:	Dimensionless
min:	0
max:	1name:	P(self-treat)"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM59SelfTreatment._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM60PSeekOfficialCareUncomplicated1(Node):
    """Generated class for 'pSeekOfficialCareUncomplicated1'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pSeekOfficialCareUncomplicated1', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that a patient with newly incident
uncomplicated disease seeks official care

units:	Dimensionless
min:	0.0
max:	1.0
name:	Probability that a patient with uncomplicated disease seeks official care immediately."""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM60PSeekOfficialCareUncomplicated1._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM61PSelfTreatUncomplicated(Node):
    """Generated class for 'pSelfTreatUncomplicated'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pSelfTreatUncomplicated', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that a patient with uncomplicated disease without
recent history of disease (i.e. first line) will self-treat.
Note that in second line cases there is no probability of self-treatment.

units:	Dimensionless
min:	0.0
max:	1.0
name:	Probability that a patient with uncomplicated disease will self-treat."""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM61PSelfTreatUncomplicated._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM62PSeekOfficialCareUncomplicated2(Node):
    """Generated class for 'pSeekOfficialCareUncomplicated2'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pSeekOfficialCareUncomplicated2', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that a patient with recurrence of
uncomplicated disease seeks official care

units:	Dimensionless
min:	0.0
max:	1.0
name:	Probability that a recurring patient seeks official care"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM62PSeekOfficialCareUncomplicated2._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM63PSeekOfficialCareSevere(Node):
    """Generated class for 'pSeekOfficialCareSevere'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pSeekOfficialCareSevere', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that a patient with severe disease
obtains appropriate care

units:	Dimensionless
min:	0.0
max:	1.0
name:	Probability that a patient with severe disease obtains appropriate care"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM63PSeekOfficialCareSevere._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM64LiverStageDrug(Node):
    """Generated class for 'liverStageDrug'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='liverStageDrug', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Parameters for drug treatment which have an effect on the liver-stage of parasites (Primaquine and potentially Tafenoquine); for use with the Vivax model only.
Note: if this section is not listed, the following default values are
assumed: pHumanCannotReceive=0, pUseUncomplicated=0,
effectivenessOnUse=1.

name:	Liver stage drug treatment parameters (Vivax)"""
        self._metadata: dict = {'type': 'om:LiverStageDrug', 'minOccurs': '0', 'children_metadata': {'ordered': 'all', 'order': ['pHumanCannotReceive', 'ignoreCannotReceive', 'pUseUncomplicated', 'effectivenessOnUse']}, 'attributes': {}, 'children': {'pHumanCannotReceive': {'minOccurs': '1', 'maxOccurs': '1'}, 'ignoreCannotReceive': {'minOccurs': '0', 'maxOccurs': '1'}, 'pUseUncomplicated': {'minOccurs': '0', 'maxOccurs': '1'}, 'effectivenessOnUse': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._pHumanCannotReceive: OM33PHumanCannotReceive | None = None
        self._ignoreCannotReceive: OM34IgnoreCannotReceive | None = None
        self._pUseUncomplicated: OM35PUseUncomplicated | None = None
        self._effectivenessOnUse: OM36EffectivenessOnUse | None = None

    @property
    def pHumanCannotReceive(self) -> 'OM33PHumanCannotReceive':
        """Initialize 'pHumanCannotReceive'."""
        if self._pHumanCannotReceive is None:
            self._pHumanCannotReceive = OM33PHumanCannotReceive(xml_tree=self.xml_tree, parent=self)
        return self._pHumanCannotReceive

    @property
    def ignoreCannotReceive(self) -> 'OM34IgnoreCannotReceive':
        """Initialize 'ignoreCannotReceive'."""
        if self._ignoreCannotReceive is None:
            self._ignoreCannotReceive = OM34IgnoreCannotReceive(xml_tree=self.xml_tree, parent=self)
        return self._ignoreCannotReceive

    @property
    def pUseUncomplicated(self) -> 'OM35PUseUncomplicated':
        """Initialize 'pUseUncomplicated'."""
        if self._pUseUncomplicated is None:
            self._pUseUncomplicated = OM35PUseUncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._pUseUncomplicated

    @property
    def effectivenessOnUse(self) -> 'OM36EffectivenessOnUse':
        """Initialize 'effectivenessOnUse'."""
        if self._effectivenessOnUse is None:
            self._effectivenessOnUse = OM36EffectivenessOnUse(xml_tree=self.xml_tree, parent=self)
        return self._effectivenessOnUse


class OM65TreeUCOfficial(Node):
    """Generated class for 'treeUCOfficial'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='treeUCOfficial', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM65TreeUCOfficial._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM66TreeUCSelfTreat(Node):
    """Generated class for 'treeUCSelfTreat'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='treeUCSelfTreat', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM66TreeUCSelfTreat._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM67CureRateSevere(Node):
    """Generated class for 'cureRateSevere'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='cureRateSevere', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The probability of clearing parasites given access to
appropriate (hospital) care, for a severe case.

name:	Cure rate (severe cases)
min:	0
max:	1"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM67CureRateSevere._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM68TreatmentSevere(Node):
    """Generated class for 'treatmentSevere'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='treatmentSevere', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes the effects of the treatment, assuming this
compliance/adherence/... option is selected. Effects are described
in terms of a list of options, each of which acts independently but
with all effects being activated simultaneously.

name:	Group (for compliance/adherence/drug effect)
Base Type:
Lists intervention components which are deployed according to some
external trigger (for example, screening with a negative patency
outcome or health-system treatment).
Components are referenced from one or more sub-lists. Each of these
lists is deployed independently if and only if its age constraints are
met by the human host and a random sample with the given probability of
a positive outcome is positive.

name:	Triggered intervention deployment"""
        self._metadata: dict = {'type': 'om:TreatmentOption', 'children_metadata': {'ordered': 'sequence', 'order': ['deploy']}, 'attributes': {'name': 'optional'}, 'children': {'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.name: OM68TreatmentSevere._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._deploy: OM97Deploy | None = None

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Describes what this compliance option represents (e.g.
"good compliance", "poor compliance with good drugs", ...).

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM69Uncomplicated(Node):
    """Generated class for 'uncomplicated'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='uncomplicated', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM69Uncomplicated._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM70Complicated(Node):
    """Generated class for 'complicated'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='complicated', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM70Complicated._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM71ClinicalOutcomes(Node):
    """Generated class for 'ClinicalOutcomes'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='ClinicalOutcomes', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of base parameters of the clinical model.

name:	Clinical Outcomes"""
        self._metadata: dict = {'type': 'om:ClinicalOutcomes', 'children_metadata': {'ordered': 'sequence', 'order': ['maxUCSeekingMemory', 'uncomplicatedCaseDuration', 'complicatedCaseDuration', 'complicatedRiskDuration', 'dailyPrImmUCTS']}, 'attributes': {}, 'children': {'maxUCSeekingMemory': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicatedCaseDuration': {'minOccurs': '1', 'maxOccurs': '1'}, 'complicatedCaseDuration': {'minOccurs': '1', 'maxOccurs': '1'}, 'complicatedRiskDuration': {'minOccurs': '1', 'maxOccurs': '1'}, 'dailyPrImmUCTS': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._maxUCSeekingMemory: OM73MaxUCSeekingMemory | None = None
        self._uncomplicatedCaseDuration: OM74UncomplicatedCaseDuration | None = None
        self._complicatedCaseDuration: OM75ComplicatedCaseDuration | None = None
        self._complicatedRiskDuration: OM76ComplicatedRiskDuration | None = None
        self._dailyPrImmUCTS: OM77DailyPrImmUCTS | None = None

    @property
    def maxUCSeekingMemory(self) -> 'OM73MaxUCSeekingMemory':
        """Initialize 'maxUCSeekingMemory'."""
        if self._maxUCSeekingMemory is None:
            self._maxUCSeekingMemory = OM73MaxUCSeekingMemory(xml_tree=self.xml_tree, parent=self)
        return self._maxUCSeekingMemory

    @property
    def uncomplicatedCaseDuration(self) -> 'OM74UncomplicatedCaseDuration':
        """Initialize 'uncomplicatedCaseDuration'."""
        if self._uncomplicatedCaseDuration is None:
            self._uncomplicatedCaseDuration = OM74UncomplicatedCaseDuration(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicatedCaseDuration

    @property
    def complicatedCaseDuration(self) -> 'OM75ComplicatedCaseDuration':
        """Initialize 'complicatedCaseDuration'."""
        if self._complicatedCaseDuration is None:
            self._complicatedCaseDuration = OM75ComplicatedCaseDuration(xml_tree=self.xml_tree, parent=self)
        return self._complicatedCaseDuration

    @property
    def complicatedRiskDuration(self) -> 'OM76ComplicatedRiskDuration':
        """Initialize 'complicatedRiskDuration'."""
        if self._complicatedRiskDuration is None:
            self._complicatedRiskDuration = OM76ComplicatedRiskDuration(xml_tree=self.xml_tree, parent=self)
        return self._complicatedRiskDuration

    @property
    def dailyPrImmUCTS(self) -> 'OM77DailyPrImmUCTS':
        """Initialize 'dailyPrImmUCTS'."""
        if self._dailyPrImmUCTS is None:
            self._dailyPrImmUCTS = OM77DailyPrImmUCTS(xml_tree=self.xml_tree, parent=self)
        return self._dailyPrImmUCTS


class OM72NonMalariaFevers(Node):
    """Generated class for 'NonMalariaFevers'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='NonMalariaFevers', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of non-malaria fever health-system modelling (treatment,
outcomes and costing). Incidence is described by the 
model->clinical->NonMalariaFevers element. Non-malaria fevers are only
modelled if the NON_MALARIA_FEVERS option is used.
As further explanation of the parameters below, we first take:
 = logit(P) - P(need),
and then calculate the probability of antibiotic administration, P(AB),
dependent on treatment seeking location.
No seeking: P(AB) = 0
Informal sector: logit(P(AB)) =  + 
Health facility: logit(P(AB)) =  + I(neg) + I(pos) + I(need)
(where I(X) is 1 when event X is true and 0 otherwise,
logit(p)=log(p/(1-p)), event "need" is the event that death may occur
without treatment, events "neg" and "pos" are the events that a malaria
parasite diagnositic was used and indicated no parasites and parasites
respectively).

name:	Non-malaria fevers"""
        self._metadata: dict = {'type': 'om:HSESNMF', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['prTreatment', 'effectNegativeTest', 'effectPositiveTest', 'effectNeed', 'effectInformal', 'CFR', 'TreatmentEfficacy']}, 'attributes': {}, 'children': {'prTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'effectNegativeTest': {'minOccurs': '1', 'maxOccurs': '1'}, 'effectPositiveTest': {'minOccurs': '1', 'maxOccurs': '1'}, 'effectNeed': {'minOccurs': '1', 'maxOccurs': '1'}, 'effectInformal': {'minOccurs': '1', 'maxOccurs': '1'}, 'CFR': {'minOccurs': '1', 'maxOccurs': '1'}, 'TreatmentEfficacy': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._prTreatment: OM78PrTreatment | None = None
        self._effectNegativeTest: OM79EffectNegativeTest | None = None
        self._effectPositiveTest: OM80EffectPositiveTest | None = None
        self._effectNeed: OM81EffectNeed | None = None
        self._effectInformal: OM82EffectInformal | None = None
        self._CFR: OM31CFR | None = None
        self._TreatmentEfficacy: OM84TreatmentEfficacy | None = None

    @property
    def prTreatment(self) -> 'OM78PrTreatment':
        """Initialize 'prTreatment'."""
        if self._prTreatment is None:
            self._prTreatment = OM78PrTreatment(xml_tree=self.xml_tree, parent=self)
        return self._prTreatment

    @property
    def effectNegativeTest(self) -> 'OM79EffectNegativeTest':
        """Initialize 'effectNegativeTest'."""
        if self._effectNegativeTest is None:
            self._effectNegativeTest = OM79EffectNegativeTest(xml_tree=self.xml_tree, parent=self)
        return self._effectNegativeTest

    @property
    def effectPositiveTest(self) -> 'OM80EffectPositiveTest':
        """Initialize 'effectPositiveTest'."""
        if self._effectPositiveTest is None:
            self._effectPositiveTest = OM80EffectPositiveTest(xml_tree=self.xml_tree, parent=self)
        return self._effectPositiveTest

    @property
    def effectNeed(self) -> 'OM81EffectNeed':
        """Initialize 'effectNeed'."""
        if self._effectNeed is None:
            self._effectNeed = OM81EffectNeed(xml_tree=self.xml_tree, parent=self)
        return self._effectNeed

    @property
    def effectInformal(self) -> 'OM82EffectInformal':
        """Initialize 'effectInformal'."""
        if self._effectInformal is None:
            self._effectInformal = OM82EffectInformal(xml_tree=self.xml_tree, parent=self)
        return self._effectInformal

    @property
    def CFR(self) -> 'OM31CFR':
        """Initialize 'CFR'."""
        if self._CFR is None:
            self._CFR = OM31CFR(xml_tree=self.xml_tree, parent=self)
        return self._CFR

    @property
    def TreatmentEfficacy(self) -> 'OM84TreatmentEfficacy':
        """Initialize 'TreatmentEfficacy'."""
        if self._TreatmentEfficacy is None:
            self._TreatmentEfficacy = OM84TreatmentEfficacy(xml_tree=self.xml_tree, parent=self)
        return self._TreatmentEfficacy


class OM73MaxUCSeekingMemory(ElementNode):
    """Generated class for 'maxUCSeekingMemory'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='maxUCSeekingMemory', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Maximum number of timesteps (including first day of case) that an individual with an uncomplicated case of
malaria will remember he/she was sick before resetting. 

name:	Max UC treatment-seeking memory
units:	Days
min:	0
max:	unbounded"""
        self._metadata: dict = {'type': 'xs:int', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM74UncomplicatedCaseDuration(ElementNode):
    """Generated class for 'uncomplicatedCaseDuration'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='uncomplicatedCaseDuration', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Fixed length of an uncomplicated case of malarial or non-malarial
sickness (from treatment seeking until return to life-as-usual).
Usually 3.

name:	Uncomplicated case duration
units:	Days
min:	1
max:	unbounded"""
        self._metadata: dict = {'type': 'xs:int', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM75ComplicatedCaseDuration(ElementNode):
    """Generated class for 'complicatedCaseDuration'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='complicatedCaseDuration', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Fixed length of a complicated or severe case of malaria
(from treatment seeking until return to life-as-usual).

name:	Complicated case duration
units:	Days
min:	1
max:	unbounded"""
        self._metadata: dict = {'type': 'xs:int', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM76ComplicatedRiskDuration(ElementNode):
    """Generated class for 'complicatedRiskDuration'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='complicatedRiskDuration', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Number of days for which humans are at risk of death during a severe
or complicated case of malaria. Cannot be greater than the duration
of a complicated case or less than 1 day.

name:	Complicated risk duration
units:	Days
min:	1
max:	unbounded"""
        self._metadata: dict = {'type': 'xs:int', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM77DailyPrImmUCTS(ElementNode):
    """Generated class for 'dailyPrImmUCTS'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='dailyPrImmUCTS', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
It is sometimes desirable to model delays to treatment-seeking in
uncomplicated cases. While treatment of drugs can be delayed within
case management trees to provide a similar effect, this doesn't
delay any of the decisions, including diagnostics using the current
parasite density.
Instead a list of dailyPrImmUCTS elements can be used, describing
successive daily probabilities of treatment (sum must be 1). For
example, with a list of two elements with values 0.8 and 0.2, for
80% of UC cases the decision tree is evaluated immediately, and for
20% of cases evaluation is delayed by one day.
For no delay, use one element with a value of 1.

name:	Daily probability of immediate treatment seeking for uncomplicated cases
units:	Dimensionless
min:	0.0
max:	1.0"""
        self._metadata: dict = {'type': 'xs:double', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM78PrTreatment(ElementNode):
    """Generated class for 'prTreatment'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='prTreatment', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability of a non-malaria fever being treated with an antibiotic
given that no malaria diagnostic was used but independent of need.
Symbol: P.

name:	P(treatment|no diagnostic)
units:	Dimensionless
min:	0.0
max:	1.0"""
        self._metadata: dict = {'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM79EffectNegativeTest(ElementNode):
    """Generated class for 'effectNegativeTest'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='effectNegativeTest', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The effect of a negative malaria diagnostic on the odds ratio of
receiving antibiotics. Symbol: exp().

name:	Effect of a negative test"""
        self._metadata: dict = {'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM80EffectPositiveTest(ElementNode):
    """Generated class for 'effectPositiveTest'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='effectPositiveTest', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The effect of a positive malaria diagnostic on the odds ratio of
receiving antibiotics. Symbol: exp().

name:	Effect of a positive test"""
        self._metadata: dict = {'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM81EffectNeed(ElementNode):
    """Generated class for 'effectNeed'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='effectNeed', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The effect of needing antibiotic treatment on the odds ratio of
receiving antibiotics. Symbol: exp().

name:	Effect of need"""
        self._metadata: dict = {'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM82EffectInformal(ElementNode):
    """Generated class for 'effectInformal'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='effectInformal', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The effect of seeking treatment from an informal provider (i.e.
a provider untrained in NMF diagnosis) on the odds ratio of
receiving antibiotics. Symbol: exp()

name:	Effect of informal provider"""
        self._metadata: dict = {'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM83CFR(Node):
    """Generated class for 'CFR'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='CFR', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Base case fatality rate for non-malaria fevers (probability of
death from a fever requiring antibiotic treatment given that no
antibiotic treatment is received, per age-group).

name:	Case fatality rate
units:	Dimensionless
min:	0.0
max:	1.0"""
        self._metadata: dict = {'type': 'om:AgeGroupValues', 'children_metadata': {'ordered': 'sequence', 'order': ['group']}, 'attributes': {'interpolation': 'optional'}, 'children': {'group': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.interpolation: OM83CFR._Interpolation = self._Interpolation(xml_tree=xml_tree, parent=self)
        self._group: OM293Group | None = None

    @property
    def group(self) -> 'OM293Group':
        """Initialize 'group'."""
        if self._group is None:
            self._group = OM293Group(xml_tree=self.xml_tree, parent=self)
        return self._group

    class _Interpolation(AttributeNode):
        """Generated class for 'interpolation'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interpolation', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Interpolation algorithm. Normally it is desirable for age-based
values to be continuous w.r.t. age. By default linear interpolation
is used.
With all algorithms except "none", the age groups are converted to a
set of points centred within each age range. Extra
points are added at each end (zero and infinity) to keep value
constant at both ends of the function. A zero-length age group may
be used as a kind of barrier to adjust the distribution; e.g. with
age group boundaries at 15, 20 and 25 years, a (linear) spline would
be drawn between ages 17.5 and 22.5, whereas with boundaries at
15, 20 and 20 years, a spline would be drawn between ages 17.5 and 20
years (may be desired if individuals are assumed to reach adult size
at 20).
Algorithms:
1. none: input values are used directly
2. linear: straight lines (on an age vs. value graph) are used to
interpolate data points.

name:	interpolation"""
            self._metadata: dict = {'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['none', 'linear']}, 'type': 'xs:string'}


class OM84TreatmentEfficacy(ElementNode):
    """Generated class for 'TreatmentEfficacy'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='TreatmentEfficacy', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that treatment would prevent a death (i.e. CFR is
multiplied by one minus this when treatment occurs).

units:	Dimensionless
name:	Treatment efficacy
min:	0.0
max:	1.0"""
        self._metadata: dict = {'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM85Multiple(Node):
    """Generated class for 'multiple'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='multiple', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A special node allowing multiple sub-trees to be evaluated.
This is different from an ordinary decision tree node in that:
a) multiple types of child can occur simultaneously (e.g. multiple
types of treatment or treatment plus a 'random' sub-tree)
b) the 'noTreatment' and 'treatFailure' nodes are not allowed

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DTMultiple', 'children_metadata': {'ordered': None, 'order': [['caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'treatPKPD', 'treatSimple', 'deploy', 'report', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM85Multiple._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._report: OM93Report | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM86CaseType(Node):
    """Generated class for 'caseType'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='caseType', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A switch which choses a branch deterministically, based on whether the
patient was treated recently (second line) or not (first line).
For uncomplicated cases only.

name:	Switch (first/second line)"""
        self._metadata: dict = {'type': 'om:DTCaseType', 'children_metadata': {'ordered': 'all', 'order': ['firstLine', 'secondLine']}, 'attributes': {'name': 'optional'}, 'children': {'firstLine': {'minOccurs': '1', 'maxOccurs': '1'}, 'secondLine': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM86CaseType._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._firstLine: OM110FirstLine | None = None
        self._secondLine: OM111SecondLine | None = None

    @property
    def firstLine(self) -> 'OM110FirstLine':
        """Initialize 'firstLine'."""
        if self._firstLine is None:
            self._firstLine = OM110FirstLine(xml_tree=self.xml_tree, parent=self)
        return self._firstLine

    @property
    def secondLine(self) -> 'OM111SecondLine':
        """Initialize 'secondLine'."""
        if self._secondLine is None:
            self._secondLine = OM111SecondLine(xml_tree=self.xml_tree, parent=self)
        return self._secondLine

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM87Diagnostic(Node):
    """Generated class for 'diagnostic'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='diagnostic', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A switch which choses a branch deterministically, based on the outcome
of some type of diagnostic.

name:	Switch (diagnostic)"""
        self._metadata: dict = {'type': 'om:DTDiagnostic', 'children_metadata': {'ordered': 'all', 'order': ['positive', 'negative']}, 'attributes': {'diagnostic': 'required', 'name': 'optional'}, 'children': {'positive': {'minOccurs': '1', 'maxOccurs': '1'}, 'negative': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.diagnostic: OM87Diagnostic._Diagnostic = self._Diagnostic(xml_tree=xml_tree, parent=self)
        self.name: OM87Diagnostic._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._positive: OM112Positive | None = None
        self._negative: OM113Negative | None = None

    @property
    def positive(self) -> 'OM112Positive':
        """Initialize 'positive'."""
        if self._positive is None:
            self._positive = OM112Positive(xml_tree=self.xml_tree, parent=self)
        return self._positive

    @property
    def negative(self) -> 'OM113Negative':
        """Initialize 'negative'."""
        if self._negative is None:
            self._negative = OM113Negative(xml_tree=self.xml_tree, parent=self)
        return self._negative

    class _Diagnostic(AttributeNode):
        """Generated class for 'diagnostic'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='diagnostic', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Should match the name of some parameterised diagnostic (see
scenario/diagnostics).

name:	Name of diagnostic"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM88Uncomplicated(Node):
    """Generated class for 'uncomplicated'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='uncomplicated', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A switch which choses a branch deterministically, based on whether the host has an uncomplicated case. This could be a Malaria fever or a non-Malaria fever. If non-Malaria fevers are enable, it is possible to add a <diagnostic> node.

name:	Switch (uncomplicated)"""
        self._metadata: dict = {'type': 'om:DTUncomplicated', 'children_metadata': {'ordered': 'all', 'order': ['positive', 'negative']}, 'attributes': {'name': 'optional', 'memory': 'optional'}, 'children': {'positive': {'minOccurs': '1', 'maxOccurs': '1'}, 'negative': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM88Uncomplicated._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.memory: OM88Uncomplicated._Memory = self._Memory(xml_tree=xml_tree, parent=self)
        self._positive: OM112Positive | None = None
        self._negative: OM113Negative | None = None

    @property
    def positive(self) -> 'OM112Positive':
        """Initialize 'positive'."""
        if self._positive is None:
            self._positive = OM112Positive(xml_tree=self.xml_tree, parent=self)
        return self._positive

    @property
    def negative(self) -> 'OM113Negative':
        """Initialize 'negative'."""
        if self._negative is None:
            self._negative = OM113Negative(xml_tree=self.xml_tree, parent=self)
        return self._negative

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Memory(AttributeNode):
        """Generated class for 'memory'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='memory', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Follow-up period during which a recurrence is
considered to be a treatment failure
Can be specified in steps (e.g. 6t) or days (e.g. 28d).

units:	User-defined (defaults to steps)

          name:	Number of days to look back for fevers. This must be less than or equal to the healthsystem memory parameter. In general, this should be less than or equal to the repeatStep in MSAT with contiuous deployment"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}


class OM89Severe(Node):
    """Generated class for 'severe'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='severe', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A switch which choses a branch deterministically, based on whether the host has a severe case or not. Note that this include severe cases due to comorbidities.

name:	Switch (severe)"""
        self._metadata: dict = {'type': 'om:DTSevere', 'children_metadata': {'ordered': 'all', 'order': ['positive', 'negative']}, 'attributes': {'name': 'optional', 'memory': 'optional'}, 'children': {'positive': {'minOccurs': '1', 'maxOccurs': '1'}, 'negative': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM89Severe._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.memory: OM89Severe._Memory = self._Memory(xml_tree=xml_tree, parent=self)
        self._positive: OM112Positive | None = None
        self._negative: OM113Negative | None = None

    @property
    def positive(self) -> 'OM112Positive':
        """Initialize 'positive'."""
        if self._positive is None:
            self._positive = OM112Positive(xml_tree=self.xml_tree, parent=self)
        return self._positive

    @property
    def negative(self) -> 'OM113Negative':
        """Initialize 'negative'."""
        if self._negative is None:
            self._negative = OM113Negative(xml_tree=self.xml_tree, parent=self)
        return self._negative

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Memory(AttributeNode):
        """Generated class for 'memory'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='memory', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Follow-up period during which a recurrence is
considered to be a treatment failure
Can be specified in steps (e.g. 6t) or days (e.g. 28d).

units:	User-defined (defaults to steps)

          name:	Number of days to look back for fevers. This must be less than or equal to the healthsystem memory parameter. In general, this should be less than or equal to the repeatStep in MSAT with contiuous deployment"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM90Random(Node):
    """Generated class for 'random'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='random', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A switch which choses a branch randomly.
Each branch must be listed with a probability; the sum of all these
probabilities must equal 1.

name:	Switch (probabilistic)"""
        self._metadata: dict = {'type': 'om:DTRandom', 'children_metadata': {'ordered': 'sequence', 'order': ['outcome']}, 'attributes': {'name': 'optional'}, 'children': {'outcome': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.name: OM90Random._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._outcome: OM118Outcome | None = None

    @property
    def outcome(self) -> 'OM118Outcome':
        """Initialize 'outcome'."""
        if self._outcome is None:
            self._outcome = OM118Outcome(xml_tree=self.xml_tree, parent=self)
        return self._outcome

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM91Age(Node):
    """Generated class for 'age'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='age', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A switch which choses a branch deterministically, based on the
patient's age (in years).
Categories must uniquely cover all ages from birth, with no upper
bound. Categories must be listed in order of age, increasing; the first
must have lower bound 0. Upper bounds are equal to the lower bound of
the next category, (but are exclusive where lower bounds are
inclusive); the last category has no upper bound.

name:	Switch (age of patient)"""
        self._metadata: dict = {'type': 'om:DTAge', 'children_metadata': {'ordered': 'sequence', 'order': ['age']}, 'attributes': {'name': 'optional'}, 'children': {'age': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.name: OM91Age._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._age: OM119Age | None = None

    @property
    def age(self) -> 'OM119Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM119Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM92NoTreatment(Node):
    """Generated class for 'noTreatment'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='noTreatment', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
An end node doing nothing. This exists to explicitly state that no
treatment happens and to prevent trees from accidentally being left
incomplete.

name:	No treatment"""
        self._metadata: dict = {'type': 'om:DTNoTreatment', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'name': 'optional'}, 'children': {}}
        self.name: OM92NoTreatment._Name = self._Name(xml_tree=xml_tree, parent=self)

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM93Report(Node):
    """Generated class for 'report'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='report', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
This increments measure 80 (nCMDTReport) by one every time this node is visited. This can be useful to report the results of mass test and treat interventions using the decision tree.
name:	DT Report"""
        self._metadata: dict = {'type': 'om:DTReport', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'name': 'optional', 'outputNumber': ''}, 'children': {}}
        self.name: OM93Report._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.outputNumber: OM93Report._OutputNumber = self._OutputNumber(xml_tree=xml_tree, parent=self)

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _OutputNumber(AttributeNode):
        """Generated class for 'outputNumber'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='outputNumber', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Optionally, this can be given to delay the start of treatment by a
given number of hours. If not specified, treatment is not delayed. If
a delay is given, all medications within the treatment schedule used
are delayed by this number of hours.

name:	Delay (hours)"""
            self._metadata: dict = {'type': 'xs:int', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}


class OM94TreatFailure(Node):
    """Generated class for 'treatFailure'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='treatFailure', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
An end node which reports treatment but does not change parasitalogical
status. This allows correct labelling of second-line cases.

name:	Failed treatment"""
        self._metadata: dict = {'type': 'om:DTTreatFailure', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'name': 'optional'}, 'children': {}}
        self.name: OM94TreatFailure._Name = self._Name(xml_tree=xml_tree, parent=self)

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM95TreatPKPD(Node):
    """Generated class for 'treatPKPD'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='treatPKPD', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A command to administer drugs according to a given schedule and
dosage table, optionally with a delay.

name:	Treatment (PK/PD model)"""
        self._metadata: dict = {'type': 'om:DTTreatPKPD', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'schedule': 'required', 'dosage': 'required', 'delay_h': ''}, 'children': {}}
        self.schedule: OM95TreatPKPD._Schedule = self._Schedule(xml_tree=xml_tree, parent=self)
        self.dosage: OM95TreatPKPD._Dosage = self._Dosage(xml_tree=xml_tree, parent=self)
        self.delay_h: OM95TreatPKPD._Delay_h = self._Delay_h(xml_tree=xml_tree, parent=self)

    class _Schedule(AttributeNode):
        """Generated class for 'schedule'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='schedule', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The name of a schedule to use for treatment.

name:	Name of treatment schedule"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Dosage(AttributeNode):
        """Generated class for 'dosage'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='dosage', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The name of a dosage table to use for treatment.

name:	Name of dosage table"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Delay_h(AttributeNode):
        """Generated class for 'delay_h'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='delay_h', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Optionally, this can be given to delay the start of treatment by a
given number of hours. If not specified, treatment is not delayed. If
a delay is given, all medications within the treatment schedule used
are delayed by this number of hours.

name:	Delay (hours)"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}


class OM96TreatSimple(Node):
    """Generated class for 'treatSimple'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='treatSimple', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Simple treatment model, targetting liver- and/or blood-stage
infections. This is all-or-nothing treatment which, when deploymed,
completely clears all infections of the targetted stages. This makes it
unsuitable for modeling resistance, but suitable for use with simple
infection models.
Infections are considered liver-stage when less than five days old and
blood-stage after that. Effects are described independently for the two
stages.

name:	Simple treatment"""
        self._metadata: dict = {'type': 'om:DTTreatSimple', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'durationLiver': 'required', 'durationBlood': 'required'}, 'children': {}}
        self.durationLiver: OM96TreatSimple._DurationLiver = self._DurationLiver(xml_tree=xml_tree, parent=self)
        self.durationBlood: OM96TreatSimple._DurationBlood = self._DurationBlood(xml_tree=xml_tree, parent=self)

    class _DurationLiver(AttributeNode):
        """Generated class for 'durationLiver'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='durationLiver', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Controls action on liver-stage infections. 0 means no action, -1 step
is a compatibility option to act like treatment before schema version
32 (which removed infections retrospectively), 1 step or any duration
which equals some whole number of steps n>0 means to clear all
liver-stage infections found on the next 1 or n steps.
Note on -1 compatibility option: the main difference to 1 step
(clearing on the next timestep) is that parasite densities will be
reduced immediately, and thus from the point of view of surveys and
mass screen and treat interventions a peak in density which is
immediately treated through case management will not be seen.
Can be specified in steps (e.g. 1t, -1t) or days (e.g. 5d).

name:	Length of liver-stage effect
units:	User defined"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _DurationBlood(AttributeNode):
        """Generated class for 'durationBlood'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='durationBlood', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Controls action on blood-stage infections. 0 means no action, -1 step
is a compatibility option to act like treatment before schema version
32 (which removed infections retrospectively), 1 step or any duration
which equals some whole number of steps n>0 means to clear all
blood-stage infections found on the next 1 or n steps.
Note on -1 compatibility option: the main difference to 1 step
(clearing on the next timestep) is that parasite densities will be
reduced immediately, and thus from the point of view of surveys and
mass screen and treat interventions a peak in density which is
immediately treated through case management will not be seen.
Can be specified in steps (e.g. 1t, -1t) or days (e.g. 5d).

name:	Length of blood-stage effect
units:	User defined"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM97Deploy(Node):
    """Generated class for 'deploy'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='deploy', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Deploy one or more intervention components.

name:	Deploy intervention"""
        self._metadata: dict = {'type': 'om:DTDeploy', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'component': 'required'}, 'children': {}}
        self.component: OM97Deploy._Component = self._Component(xml_tree=xml_tree, parent=self)

    class _Component(AttributeNode):
        """Generated class for 'component'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='component', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The identifier (short name) of a component.

name:	Component identifier"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM98Cohort(Node):
    """Generated class for 'cohort'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='cohort', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A switch which choses a branch deterministically, based on whether the host is part of the cohort (defined by the intervention component) or not.

name:	Switch (cohort)"""
        self._metadata: dict = {'type': 'om:DTCohort', 'children_metadata': {'ordered': 'all', 'order': ['positive', 'negative']}, 'attributes': {'name': 'optional', 'component': 'required'}, 'children': {'positive': {'minOccurs': '1', 'maxOccurs': '1'}, 'negative': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM98Cohort._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.component: OM98Cohort._Component = self._Component(xml_tree=xml_tree, parent=self)
        self._positive: OM112Positive | None = None
        self._negative: OM113Negative | None = None

    @property
    def positive(self) -> 'OM112Positive':
        """Initialize 'positive'."""
        if self._positive is None:
            self._positive = OM112Positive(xml_tree=self.xml_tree, parent=self)
        return self._positive

    @property
    def negative(self) -> 'OM113Negative':
        """Initialize 'negative'."""
        if self._negative is None:
            self._negative = OM113Negative(xml_tree=self.xml_tree, parent=self)
        return self._negative

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Component(AttributeNode):
        """Generated class for 'component'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='component', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Follow-up period during which a recurrence is
considered to be a treatment failure
Can be specified in steps (e.g. 6t) or days (e.g. 28d).

units:	User-defined (defaults to steps)

          name:	Number of days to look back for fevers. This must be less than or equal to the healthsystem memory parameter. In general, this should be less than or equal to the repeatStep in MSAT with contiuous deployment"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM99CaseType(Node):
    """Generated class for 'caseType'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='caseType', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A switch which choses a branch deterministically, based on whether the
patient was treated recently (second line) or not (first line).
For uncomplicated cases only.

name:	Switch (first/second line)"""
        self._metadata: dict = {'type': 'om:DTCaseType', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'all', 'order': ['firstLine', 'secondLine']}, 'attributes': {'name': 'optional'}, 'children': {'firstLine': {'minOccurs': '1', 'maxOccurs': '1'}, 'secondLine': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM99CaseType._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._firstLine: OM110FirstLine | None = None
        self._secondLine: OM111SecondLine | None = None

    @property
    def firstLine(self) -> 'OM110FirstLine':
        """Initialize 'firstLine'."""
        if self._firstLine is None:
            self._firstLine = OM110FirstLine(xml_tree=self.xml_tree, parent=self)
        return self._firstLine

    @property
    def secondLine(self) -> 'OM111SecondLine':
        """Initialize 'secondLine'."""
        if self._secondLine is None:
            self._secondLine = OM111SecondLine(xml_tree=self.xml_tree, parent=self)
        return self._secondLine

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM100Diagnostic(Node):
    """Generated class for 'diagnostic'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='diagnostic', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A switch which choses a branch deterministically, based on the outcome
of some type of diagnostic.

name:	Switch (diagnostic)"""
        self._metadata: dict = {'type': 'om:DTDiagnostic', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'all', 'order': ['positive', 'negative']}, 'attributes': {'diagnostic': 'required', 'name': 'optional'}, 'children': {'positive': {'minOccurs': '1', 'maxOccurs': '1'}, 'negative': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.diagnostic: OM100Diagnostic._Diagnostic = self._Diagnostic(xml_tree=xml_tree, parent=self)
        self.name: OM100Diagnostic._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._positive: OM112Positive | None = None
        self._negative: OM113Negative | None = None

    @property
    def positive(self) -> 'OM112Positive':
        """Initialize 'positive'."""
        if self._positive is None:
            self._positive = OM112Positive(xml_tree=self.xml_tree, parent=self)
        return self._positive

    @property
    def negative(self) -> 'OM113Negative':
        """Initialize 'negative'."""
        if self._negative is None:
            self._negative = OM113Negative(xml_tree=self.xml_tree, parent=self)
        return self._negative

    class _Diagnostic(AttributeNode):
        """Generated class for 'diagnostic'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='diagnostic', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Should match the name of some parameterised diagnostic (see
scenario/diagnostics).

name:	Name of diagnostic"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM101Uncomplicated(Node):
    """Generated class for 'uncomplicated'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='uncomplicated', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A switch which choses a branch deterministically, based on whether the host has an uncomplicated case. This could be a Malaria fever or a non-Malaria fever. If non-Malaria fevers are enable, it is possible to add a <diagnostic> node.

name:	Switch (uncomplicated)"""
        self._metadata: dict = {'type': 'om:DTUncomplicated', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'all', 'order': ['positive', 'negative']}, 'attributes': {'name': 'optional', 'memory': 'optional'}, 'children': {'positive': {'minOccurs': '1', 'maxOccurs': '1'}, 'negative': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM101Uncomplicated._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.memory: OM101Uncomplicated._Memory = self._Memory(xml_tree=xml_tree, parent=self)
        self._positive: OM112Positive | None = None
        self._negative: OM113Negative | None = None

    @property
    def positive(self) -> 'OM112Positive':
        """Initialize 'positive'."""
        if self._positive is None:
            self._positive = OM112Positive(xml_tree=self.xml_tree, parent=self)
        return self._positive

    @property
    def negative(self) -> 'OM113Negative':
        """Initialize 'negative'."""
        if self._negative is None:
            self._negative = OM113Negative(xml_tree=self.xml_tree, parent=self)
        return self._negative

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Memory(AttributeNode):
        """Generated class for 'memory'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='memory', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Follow-up period during which a recurrence is
considered to be a treatment failure
Can be specified in steps (e.g. 6t) or days (e.g. 28d).

units:	User-defined (defaults to steps)

          name:	Number of days to look back for fevers. This must be less than or equal to the healthsystem memory parameter. In general, this should be less than or equal to the repeatStep in MSAT with contiuous deployment"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}


class OM102Severe(Node):
    """Generated class for 'severe'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='severe', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A switch which choses a branch deterministically, based on whether the host has a severe case or not. Note that this include severe cases due to comorbidities.

name:	Switch (severe)"""
        self._metadata: dict = {'type': 'om:DTSevere', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'all', 'order': ['positive', 'negative']}, 'attributes': {'name': 'optional', 'memory': 'optional'}, 'children': {'positive': {'minOccurs': '1', 'maxOccurs': '1'}, 'negative': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM102Severe._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.memory: OM102Severe._Memory = self._Memory(xml_tree=xml_tree, parent=self)
        self._positive: OM112Positive | None = None
        self._negative: OM113Negative | None = None

    @property
    def positive(self) -> 'OM112Positive':
        """Initialize 'positive'."""
        if self._positive is None:
            self._positive = OM112Positive(xml_tree=self.xml_tree, parent=self)
        return self._positive

    @property
    def negative(self) -> 'OM113Negative':
        """Initialize 'negative'."""
        if self._negative is None:
            self._negative = OM113Negative(xml_tree=self.xml_tree, parent=self)
        return self._negative

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Memory(AttributeNode):
        """Generated class for 'memory'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='memory', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Follow-up period during which a recurrence is
considered to be a treatment failure
Can be specified in steps (e.g. 6t) or days (e.g. 28d).

units:	User-defined (defaults to steps)

          name:	Number of days to look back for fevers. This must be less than or equal to the healthsystem memory parameter. In general, this should be less than or equal to the repeatStep in MSAT with contiuous deployment"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM103Random(Node):
    """Generated class for 'random'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='random', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A switch which choses a branch randomly.
Each branch must be listed with a probability; the sum of all these
probabilities must equal 1.

name:	Switch (probabilistic)"""
        self._metadata: dict = {'type': 'om:DTRandom', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': ['outcome']}, 'attributes': {'name': 'optional'}, 'children': {'outcome': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.name: OM103Random._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._outcome: OM118Outcome | None = None

    @property
    def outcome(self) -> 'OM118Outcome':
        """Initialize 'outcome'."""
        if self._outcome is None:
            self._outcome = OM118Outcome(xml_tree=self.xml_tree, parent=self)
        return self._outcome

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM104Age(Node):
    """Generated class for 'age'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='age', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A switch which choses a branch deterministically, based on the
patient's age (in years).
Categories must uniquely cover all ages from birth, with no upper
bound. Categories must be listed in order of age, increasing; the first
must have lower bound 0. Upper bounds are equal to the lower bound of
the next category, (but are exclusive where lower bounds are
inclusive); the last category has no upper bound.

name:	Switch (age of patient)"""
        self._metadata: dict = {'type': 'om:DTAge', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': ['age']}, 'attributes': {'name': 'optional'}, 'children': {'age': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.name: OM104Age._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._age: OM119Age | None = None

    @property
    def age(self) -> 'OM119Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM119Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM105TreatPKPD(Node):
    """Generated class for 'treatPKPD'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='treatPKPD', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A command to administer drugs according to a given schedule and
dosage table, optionally with a delay.

name:	Treatment (PK/PD model)"""
        self._metadata: dict = {'type': 'om:DTTreatPKPD', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'schedule': 'required', 'dosage': 'required', 'delay_h': ''}, 'children': {}}
        self.schedule: OM105TreatPKPD._Schedule = self._Schedule(xml_tree=xml_tree, parent=self)
        self.dosage: OM105TreatPKPD._Dosage = self._Dosage(xml_tree=xml_tree, parent=self)
        self.delay_h: OM105TreatPKPD._Delay_h = self._Delay_h(xml_tree=xml_tree, parent=self)

    class _Schedule(AttributeNode):
        """Generated class for 'schedule'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='schedule', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The name of a schedule to use for treatment.

name:	Name of treatment schedule"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Dosage(AttributeNode):
        """Generated class for 'dosage'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='dosage', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The name of a dosage table to use for treatment.

name:	Name of dosage table"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Delay_h(AttributeNode):
        """Generated class for 'delay_h'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='delay_h', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Optionally, this can be given to delay the start of treatment by a
given number of hours. If not specified, treatment is not delayed. If
a delay is given, all medications within the treatment schedule used
are delayed by this number of hours.

name:	Delay (hours)"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}


class OM106TreatSimple(Node):
    """Generated class for 'treatSimple'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='treatSimple', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Simple treatment model, targetting liver- and/or blood-stage
infections. This is all-or-nothing treatment which, when deploymed,
completely clears all infections of the targetted stages. This makes it
unsuitable for modeling resistance, but suitable for use with simple
infection models.
Infections are considered liver-stage when less than five days old and
blood-stage after that. Effects are described independently for the two
stages.

name:	Simple treatment"""
        self._metadata: dict = {'type': 'om:DTTreatSimple', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'durationLiver': 'required', 'durationBlood': 'required'}, 'children': {}}
        self.durationLiver: OM106TreatSimple._DurationLiver = self._DurationLiver(xml_tree=xml_tree, parent=self)
        self.durationBlood: OM106TreatSimple._DurationBlood = self._DurationBlood(xml_tree=xml_tree, parent=self)

    class _DurationLiver(AttributeNode):
        """Generated class for 'durationLiver'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='durationLiver', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Controls action on liver-stage infections. 0 means no action, -1 step
is a compatibility option to act like treatment before schema version
32 (which removed infections retrospectively), 1 step or any duration
which equals some whole number of steps n>0 means to clear all
liver-stage infections found on the next 1 or n steps.
Note on -1 compatibility option: the main difference to 1 step
(clearing on the next timestep) is that parasite densities will be
reduced immediately, and thus from the point of view of surveys and
mass screen and treat interventions a peak in density which is
immediately treated through case management will not be seen.
Can be specified in steps (e.g. 1t, -1t) or days (e.g. 5d).

name:	Length of liver-stage effect
units:	User defined"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _DurationBlood(AttributeNode):
        """Generated class for 'durationBlood'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='durationBlood', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Controls action on blood-stage infections. 0 means no action, -1 step
is a compatibility option to act like treatment before schema version
32 (which removed infections retrospectively), 1 step or any duration
which equals some whole number of steps n>0 means to clear all
blood-stage infections found on the next 1 or n steps.
Note on -1 compatibility option: the main difference to 1 step
(clearing on the next timestep) is that parasite densities will be
reduced immediately, and thus from the point of view of surveys and
mass screen and treat interventions a peak in density which is
immediately treated through case management will not be seen.
Can be specified in steps (e.g. 1t, -1t) or days (e.g. 5d).

name:	Length of blood-stage effect
units:	User defined"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM107Deploy(Node):
    """Generated class for 'deploy'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='deploy', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Deploy one or more intervention components.

name:	Deploy intervention"""
        self._metadata: dict = {'type': 'om:DTDeploy', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'component': 'required'}, 'children': {}}
        self.component: OM107Deploy._Component = self._Component(xml_tree=xml_tree, parent=self)

    class _Component(AttributeNode):
        """Generated class for 'component'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='component', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The identifier (short name) of a component.

name:	Component identifier"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM108Report(Node):
    """Generated class for 'report'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='report', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
This increments measure 80 (nCMDTReport) by one every time this node is visited. This can be useful to report the results of mass test and treat interventions using the decision tree.
name:	DT Report"""
        self._metadata: dict = {'type': 'om:DTReport', 'maxOccurs': 'unbounded', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'name': 'optional', 'outputNumber': ''}, 'children': {}}
        self.name: OM108Report._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.outputNumber: OM108Report._OutputNumber = self._OutputNumber(xml_tree=xml_tree, parent=self)

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _OutputNumber(AttributeNode):
        """Generated class for 'outputNumber'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='outputNumber', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Optionally, this can be given to delay the start of treatment by a
given number of hours. If not specified, treatment is not delayed. If
a delay is given, all medications within the treatment schedule used
are delayed by this number of hours.

name:	Delay (hours)"""
            self._metadata: dict = {'type': 'xs:int', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}


class OM109Cohort(Node):
    """Generated class for 'cohort'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='cohort', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A switch which choses a branch deterministically, based on whether the host is part of the cohort (defined by the intervention component) or not.

name:	Switch (cohort)"""
        self._metadata: dict = {'type': 'om:DTCohort', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'all', 'order': ['positive', 'negative']}, 'attributes': {'name': 'optional', 'component': 'required'}, 'children': {'positive': {'minOccurs': '1', 'maxOccurs': '1'}, 'negative': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM109Cohort._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.component: OM109Cohort._Component = self._Component(xml_tree=xml_tree, parent=self)
        self._positive: OM112Positive | None = None
        self._negative: OM113Negative | None = None

    @property
    def positive(self) -> 'OM112Positive':
        """Initialize 'positive'."""
        if self._positive is None:
            self._positive = OM112Positive(xml_tree=self.xml_tree, parent=self)
        return self._positive

    @property
    def negative(self) -> 'OM113Negative':
        """Initialize 'negative'."""
        if self._negative is None:
            self._negative = OM113Negative(xml_tree=self.xml_tree, parent=self)
        return self._negative

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Component(AttributeNode):
        """Generated class for 'component'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='component', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Follow-up period during which a recurrence is
considered to be a treatment failure
Can be specified in steps (e.g. 6t) or days (e.g. 28d).

units:	User-defined (defaults to steps)

          name:	Number of days to look back for fevers. This must be less than or equal to the healthsystem memory parameter. In general, this should be less than or equal to the repeatStep in MSAT with contiuous deployment"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM110FirstLine(Node):
    """Generated class for 'firstLine'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='firstLine', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM110FirstLine._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM111SecondLine(Node):
    """Generated class for 'secondLine'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='secondLine', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM111SecondLine._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM112Positive(Node):
    """Generated class for 'positive'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='positive', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM112Positive._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM113Negative(Node):
    """Generated class for 'negative'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='negative', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM113Negative._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM114Positive(Node):
    """Generated class for 'positive'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='positive', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM114Positive._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM115Negative(Node):
    """Generated class for 'negative'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='negative', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM115Negative._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM116Positive(Node):
    """Generated class for 'positive'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='positive', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM116Positive._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM117Negative(Node):
    """Generated class for 'negative'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='negative', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM117Negative._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM118Outcome(Node):
    """Generated class for 'outcome'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='outcome', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree
Base Type:
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'minOccurs': '1', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'type': 'om:DecisionTree', 'attributes': {'p': 'required', 'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.p: OM118Outcome._P = self._P(xml_tree=xml_tree, parent=self)
        self.name: OM118Outcome._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _P(AttributeNode):
        """Generated class for 'p'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='p', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Probability of selecting this outcome. The sum of
probabilities across all outcomes must be 1.

units:	None
min:	0
max:	1
name:	Probability"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Element:
An optional piece of documentation attached to this node.

name:	Name
Type:
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM119Age(Node):
    """Generated class for 'age'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='age', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes a branch, selected for patients of a certain age.

name:	Age range
Base Type:
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree
Base Type:
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'minOccurs': '1', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'type': 'om:DecisionTree', 'attributes': {'lb': 'required', 'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.lb: OM119Age._Lb = self._Lb(xml_tree=xml_tree, parent=self)
        self.name: OM119Age._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Lb(AttributeNode):
        """Generated class for 'lb'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='lb', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """name:	Lower bound (inclusive)
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Element:
An optional piece of documentation attached to this node.

name:	Name
Type:
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM120Positive(Node):
    """Generated class for 'positive'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='positive', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM120Positive._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM121Negative(Node):
    """Generated class for 'negative'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='negative', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM121Negative._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM122ClearInfections(Node):
    """Generated class for 'clearInfections'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='clearInfections', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
This clears infections according to several options: it can clear
all blood stage infections, all liver stage infections or both, and
it can act on multiple timesteps. To have a probability of no
action add another treatment option (which does nothing) and set
the probabilities of selection appropriately.
This allows immediate (legacy) or delayed action, a prophylactic
period, and selection of which stages are targeted. It is a simple
model but appropriate enough for use with the five day timestep
when assuming no resistance and that drug
failure is mainly caused by bad drugs or compliance.
The old treatment action for the five-day timestep model is
essentially this, with immediateAction (timesteps=-1) and
stage=both, except for the IPT model's SP action, which was more
like with timesteps>1 and stage=blood.

name:	Prophylactic treatment"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'timesteps': 'required', 'stage': 'required'}, 'children': {}}
        self.timesteps: OM122ClearInfections._Timesteps = self._Timesteps(xml_tree=xml_tree, parent=self)
        self.stage: OM122ClearInfections._Stage = self._Stage(xml_tree=xml_tree, parent=self)

    class _Timesteps(AttributeNode):
        """Generated class for 'timesteps'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='timesteps', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The number of timesteps during which this action remains
in effect (e.g. 2 means clear infections during the next
two timestep updates). Full clearance of the targeted stages
occurs during this time.
A special value of -1 means act immediately (retrospectively);
this the old behaviour. A value of 1 means act on the next
timestep only.
Both of these can be thought of as a model for short-acting
effective drug treatment; the main differences are that the
latter means parasite densities will remain high from the point
of view of surveys and diagnostics (i.e. mass screen and treat)
used before the next timestep and that the latter will also
remove infections starting the next timestep. Arguably the
latter is a better model, but the differences are perhaps
small, excepting where immediate treatment of fevers (i.e.
through the health system) can hide high parasite densities
from reporting and mass-screen-and-treat diagnostics. For
use by interventions, the latter model has nicer behaviour in
that the order of deployment of multiple interventions
deployed at the same time does not matter, and that the former
model retrospectively treats infections which may already have
caused fever, thus may have a lower health impact than it
should.
It is recommended to use the new model (value 1, or greater
than 1 if prophylactic effect is desired) unless wanting to
emulate the old behaviour.
Values of 0 or less than -1 are not allowed.
Can be specified in steps (e.g. 1t, -1t) or days (e.g. 5d).

name:	Length of effect
units:	User defined (defaults to steps)"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Stage(AttributeNode):
        """Generated class for 'stage'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='stage', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Controls whether liver-stage or blood-stage infections
are cleared, or both.
Infections are considered liver-stage for one 5-day timestep,
blood-stage but pre-patent for some number of timesteps
(latentp - 1), then start the patent blood stage. If stage is
set to "liver", infections are only cleared during their first
timestep; if stage is set to "blood", infections are cleared
during pre-patent and patent blood stages; if stage is set to
"both" all infections are cleared.
The old behaviour (oddly considering the drugs it is meant to
emulate) is to clear both stages, except for the IPT model of
SP action, which cleared only patent blood-stage infections.

name:	Target stage"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['liver', 'blood', 'both']}, 'type': 'xs:string'}


class OM123Continuous(Node):
    """Generated class for 'continuous'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='continuous', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['option']}, 'type': 'om:OptionSet', 'attributes': {'period': 'required', 'duringInit': 'optional'}, 'children': {'option': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.period: OM123Continuous._Period = self._Period(xml_tree=xml_tree, parent=self)
        self.duringInit: OM123Continuous._DuringInit = self._DuringInit(xml_tree=xml_tree, parent=self)
        self._option: OM290Option | None = None

    @property
    def option(self) -> 'OM290Option':
        """Initialize 'option'."""
        if self._option is None:
            self._option = OM290Option(xml_tree=self.xml_tree, parent=self)
        return self._option

    class _Period(AttributeNode):
        """Generated class for 'period'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='period', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Delay between reports; typically one time step but can be
greater.
Can be specified in steps (e.g. 1t) or days (e.g. 5d).

units:	User defined (default:	 steps)
name:	Delay between reports"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _DuringInit(AttributeNode):
        """Generated class for 'duringInit'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='duringInit', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Also output during initialization. By default this is
disabled (only intervention-period data is output). This
should not be used for predictions, but can be useful for
model validation.
In this mode, 'simulation time' is output as the first
column (in addition to 'timestep'), since 'timestep' is dis-
continuous across the start of the intervention period.

units:	Days
min:	1
max:	unbounded
name:	During initialization"""
            self._metadata: dict = {'type': 'xs:boolean', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM124SurveyOptions(Node):
    """Generated class for 'SurveyOptions'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='SurveyOptions', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
List of all active survey options. See model/mon/OutputMeasures.h for a list of
supported outputs. Should also be on the wiki.

name:	Name of quantity"""
        self._metadata: dict = {'type': 'om:MonitoringOptions', 'children_metadata': {'ordered': 'sequence', 'order': ['option']}, 'attributes': {'onlyNewEpisode': ''}, 'children': {'option': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.onlyNewEpisode: OM124SurveyOptions._OnlyNewEpisode = self._OnlyNewEpisode(xml_tree=xml_tree, parent=self)
        self._option: OM131Option | None = None

    @property
    def option(self) -> 'OM131Option':
        """Initialize 'option'."""
        if self._option is None:
            self._option = OM131Option(xml_tree=self.xml_tree, parent=self)
        return self._option

    class _OnlyNewEpisode(AttributeNode):
        """Generated class for 'onlyNewEpisode'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='onlyNewEpisode', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If set, some statistics exclude humans who have been treated in the
recent past (precisely, when the time of last treatment was before
the current step and no more than health-system-memory days/steps
ago).
This is a rough replacement for the REPORT_ONLY_AT_RISK option,
with one difference: the maximum age of treatment for
REPORT_ONLY_AT_RISK was fixed at 20 days.
Affected measures include (as of version 35):
nHost (0),
nInfect(1),
nExpectd (2),
nPatent (3),
sumLogPyrogenThres (4),
sumlogDens (5),
totalInfs (6),
totalPatentInf (8),
sumPyrogenThresh (10),
nSubPopRemovalFirstEvent (62),
sumAge (68),
nInfectByGenotype (69),
nPatentByGenotype (70),
logDensByGenotype (71),
nHostDrugConcNonZero (72),
sumLogDrugConcNonZero (73).

name:	Report only for new cases"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}


class OM125Surveys(Node):
    """Generated class for 'surveys'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='surveys', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
List of survey times

name:	Survey times (time steps)"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': ['surveyTime']}, 'attributes': {'detectionLimit': 'optional', 'diagnostic': 'optional'}, 'children': {'surveyTime': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.detectionLimit: OM125Surveys._DetectionLimit = self._DetectionLimit(xml_tree=xml_tree, parent=self)
        self.diagnostic: OM125Surveys._Diagnostic = self._Diagnostic(xml_tree=xml_tree, parent=self)
        self._surveyTime: OM126SurveyTime | None = None

    @property
    def surveyTime(self) -> 'OM126SurveyTime':
        """Initialize 'surveyTime'."""
        if self._surveyTime is None:
            self._surveyTime = OM126SurveyTime(xml_tree=self.xml_tree, parent=self)
        return self._surveyTime

    class _DetectionLimit(AttributeNode):
        """Generated class for 'detectionLimit'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='detectionLimit', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Deprecated: limit above which a human's infection is reported
as patent.
Alternative: do not specify this; instead specify "diagnostic".

units:	parasites/microlitre
min:	0
name:	Detection limit for parasitaemia"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Diagnostic(AttributeNode):
        """Generated class for 'diagnostic'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='diagnostic', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of a parameterised diagnostic to use in surveys (see
scenario/diagnostics).

name:	Name of monitoring diagnostic"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM126SurveyTime(ElementNode):
    """Generated class for 'surveyTime'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='surveyTime', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Time of a survey. A report will be made for those measures
enabled under SurveyOptions. Reported data is either from the
moment the survey is done (immediate data) or is collected 
over the time since the previous survey, or in some cases
over a fixed time span (usually one year).
Times can be specified in time steps, starting from 0, or as
a date (see monitoring/startDate), or in days (e.g. 15d) or
years (e.g. 1y). Relative times mean the time since the start
of the intervention period, and must be non-negative (zero is
valid, but some measures, e.g. nUncomp, will be zero).
The simulation ends immediately after the last survey is taken.

units:	User defined (defaults to steps)
min:	0
name:	Survey time"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'type': 'xs:string', 'base_type': 'xs:string', 'attributes': {'repeatStep': 'optional', 'repeatEnd': 'optional', 'reported': ''}, 'children': {}}
        self.repeatStep: OM126SurveyTime._RepeatStep = self._RepeatStep(xml_tree=xml_tree, parent=self)
        self.repeatEnd: OM126SurveyTime._RepeatEnd = self._RepeatEnd(xml_tree=xml_tree, parent=self)
        self.reported: OM126SurveyTime._Reported = self._Reported(xml_tree=xml_tree, parent=self)

    class _RepeatStep(AttributeNode):
        """Generated class for 'repeatStep'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='repeatStep', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
See repeatEnd's documentation.
name:	Step of repetition
units:	User defined"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _RepeatEnd(AttributeNode):
        """Generated class for 'repeatEnd'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='repeatEnd', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Either both repeatStep and repeatEnd should be present
or neither. If present, the survey is repeated every
repeatStep timesteps (i.e. if t0 is the initial time
and x is repeatStep, surveys are done at times t0,
t0+x, t0+2*x, ...), ending before repeatEnd
(final repetition is the one before repeatEnd).
Note that repeatEnd may be specified as a date but
repeatStep must be a duration (days, steps or years).

name:	End of repetition (exclusive)
units:	User defined"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Reported(AttributeNode):
        """Generated class for 'reported'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='reported', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
For normal surveys, reporting=true. If set false,
quantities are measured but not reported. The reason for doing this is
to update conditions set on reportable measures.
Multiple surveys may be given here for the same date, e.g. if using
"repeatStep" for both reporting and non-reporting surveys. These are
combined such that a maximum of one survey is carried out per time-step,
and the survey is reported if any of the listed surveys for this date is
configured as "reporting".
Note that adding non-reporting surveys will not affect value output by
reported surveys, with the exception that generated psuedo-random numbers
may be altered (specifically, when any stochastic diagnostics are used in
surveys).
"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'true', 'children_metadata': {'ordered': None, 'order': []}}


class OM127AgeGroup(Node):
    """Generated class for 'ageGroup'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='ageGroup', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
List of age groups included in demography or surveys

name:	Age groups"""
        self._metadata: dict = {'type': 'om:MonAgeGroup', 'children_metadata': {'ordered': 'sequence', 'order': ['group']}, 'attributes': {'lowerbound': 'required'}, 'children': {'group': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.lowerbound: OM127AgeGroup._Lowerbound = self._Lowerbound(xml_tree=xml_tree, parent=self)
        self._group: OM129Group | None = None

    @property
    def group(self) -> 'OM129Group':
        """Initialize 'group'."""
        if self._group is None:
            self._group = OM129Group(xml_tree=self.xml_tree, parent=self)
        return self._group

    class _Lowerbound(AttributeNode):
        """Generated class for 'lowerbound'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='lowerbound', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Lower bound of age group

units:	Years
min:	0
max:	100
name:	lower bound of age group"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM128Cohorts(Node):
    """Generated class for 'cohorts'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='cohorts', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Allows the configuration of multiple cohorts (output segregated
according to membership within specific sub-populations).
If this element is omitted, monitoring surveys cover the entire
simulated human population.
It does not affect the "continuous" outputs (these never take
cohorts into account).

name:	Cohorts"""
        self._metadata: dict = {'minOccurs': '0', 'type': 'om:Cohorts', 'children_metadata': {'ordered': 'sequence', 'order': ['subPop']}, 'attributes': {}, 'children': {'subPop': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._subPop: OM130SubPop | None = None

    @property
    def subPop(self) -> 'OM130SubPop':
        """Initialize 'subPop'."""
        if self._subPop is None:
            self._subPop = OM130SubPop(xml_tree=self.xml_tree, parent=self)
        return self._subPop


class OM129Group(Node):
    """Generated class for 'group'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='group', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'type': 'om:MonGroupBounds', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'upperbound': 'required'}, 'children': {}}
        self.upperbound: OM129Group._Upperbound = self._Upperbound(xml_tree=xml_tree, parent=self)

    class _Upperbound(AttributeNode):
        """Generated class for 'upperbound'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='upperbound', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Upper bound of age group

units:	Years
min:	0
max:	100
name:	upper bound of age group"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM130SubPop(Node):
    """Generated class for 'subPop'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='subPop', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Consider a certain sup-population a cohort, and segregate outputs
according to membership. Where multiple sub-populations are listed,
segregate output according to all combinations of membership: e.g.
if sub-populations A and B are listed, there will be outputs for
"member of A and B", "member of A but not B", "B but not A" and
"not a member of A or B". Listing n sub-populations implies 2^n
sets of outputs (each is further segregated by age groups, survey
times and enabled output measures, which could lead to excessive
program memory usage and output file size).
To identify outputs, each sub-population has a power of two number
as identifier (see "number" attribute). Each of the 2^n output sets
is identified by a number: the output set is the output from humans
who are members in some set of sub-populations (S1, S2, ...) and
not members in some others (T1, T2, ...); the number identifying
the set is the sum of the numbers identifying the sets S1, S2, etc.
In the output file, the output set is identified by multiplying
this number by 1000 then adding it to the age group column.

name:	Sub-population"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'type': 'om:CohortSubPop', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'id': 'required', 'number': 'required'}, 'children': {}}
        self.id: OM130SubPop._Id = self._Id(xml_tree=xml_tree, parent=self)
        self.number: OM130SubPop._Number = self._Number(xml_tree=xml_tree, parent=self)

    class _Id(AttributeNode):
        """Generated class for 'id'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='id', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Textual identifier for the sub-population (i.e. for an intervention
component, since sub-populations are defined as the hosts an
intervention component is deployed to).

name:	Sub-population identifier"""
            self._metadata: dict = {'use': 'required', 'type': 'xs:string', 'children_metadata': {'ordered': None, 'order': []}}

    class _Number(AttributeNode):
        """Generated class for 'number'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='number', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Number identifying a sub-population; used to define identifiers of
output sets. This number must be a power of 2 (i.e. 1, 2, 4, 8, ...).
See documentation of subPop element.

name:	Sub-population number
units:	dimensionless
min:	1
max:	2097152"""
            self._metadata: dict = {'type': 'xs:integer', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM131Option(Node):
    """Generated class for 'option'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='option', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'type': 'om:MonitoringOption', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'outputNumber': 'optional', 'byAge': 'optional', 'byCohort': 'optional', 'bySpecies': 'optional', 'byGenotype': 'optional', 'byDrugType': 'optional', 'name': 'required', 'value': ''}, 'children': {}}
        self.outputNumber: OM131Option._OutputNumber = self._OutputNumber(xml_tree=xml_tree, parent=self)
        self.byAge: OM131Option._ByAge = self._ByAge(xml_tree=xml_tree, parent=self)
        self.byCohort: OM131Option._ByCohort = self._ByCohort(xml_tree=xml_tree, parent=self)
        self.bySpecies: OM131Option._BySpecies = self._BySpecies(xml_tree=xml_tree, parent=self)
        self.byGenotype: OM131Option._ByGenotype = self._ByGenotype(xml_tree=xml_tree, parent=self)
        self.byDrugType: OM131Option._ByDrugType = self._ByDrugType(xml_tree=xml_tree, parent=self)
        self.name: OM131Option._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.value: OM131Option._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _OutputNumber(AttributeNode):
        """Generated class for 'outputNumber'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='outputNumber', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Number identifying this monitoring measure in the output
file (3rd column). Normally this is determined from the
measure, but it can be set manually, e.g. for when the same
measure is recorded twice (to accumulate across different
categories).

name:	Number identifying measure in output"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _ByAge(AttributeNode):
        """Generated class for 'byAge'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='byAge', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If true, the measure is reported for each age category. If
false, values are summed across all age categories and only
the sum reported. If not specified, separate categories
will be reported if the measure supports this.

name:	Report by age category"""
            self._metadata: dict = {'type': 'xs:boolean', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _ByCohort(AttributeNode):
        """Generated class for 'byCohort'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='byCohort', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If true, the measure is reported for each cohort separately.
If false, values are summed across all cohorts and only
the sum reported. If not specified, separate categories
will be reported if the measure supports this.

name:	Report by cohort"""
            self._metadata: dict = {'type': 'xs:boolean', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _BySpecies(AttributeNode):
        """Generated class for 'bySpecies'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='bySpecies', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If true, the measure is reported for each mosquito species
separately. If false, values are summed across all species
and only the sum reported. If not specified, separate
categories will be reported if the measure supports this.

name:	Report by mosquito species"""
            self._metadata: dict = {'type': 'xs:boolean', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _ByGenotype(AttributeNode):
        """Generated class for 'byGenotype'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='byGenotype', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If true, the measure is reported for each parasite genotype
separately. If false, values are summed across all genotypes
and only the sum reported. If not specified, separate
categories will be reported if the measure supports this.

name:	Report by parasite genotype"""
            self._metadata: dict = {'type': 'xs:boolean', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _ByDrugType(AttributeNode):
        """Generated class for 'byDrugType'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='byDrugType', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If true, the measure is reported for each drug type
separately. If false, values are summed across all drug types
and only the sum reported. If not specified, separate
categories will be reported if the measure supports this.

name:	Report by drug type"""
            self._metadata: dict = {'type': 'xs:boolean', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of an option (monitoring measure or model option).

name:	Option name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Option on/off switch (true/false). Specifying value="true" is
the same as not specifying a value; specifying value="false"
explicitly turns the option off. If an option is not mentioned
at all, it is left at its default value (normally off, but
in a few cases, such as some bug-fix options, on).

name:	Indicator of whether option is required"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'true', 'children_metadata': {'ordered': None, 'order': []}}


class OM132ChangeHS(Node):
    """Generated class for 'changeHS'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='changeHS', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Changes to the health system

name:	Change health system"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['timedDeployment']}, 'attributes': {'name': 'optional'}, 'children': {'timedDeployment': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.name: OM132ChangeHS._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._timedDeployment: OM133TimedDeployment | None = None

    @property
    def timedDeployment(self) -> 'OM133TimedDeployment':
        """Initialize 'timedDeployment'."""
        if self._timedDeployment is None:
            self._timedDeployment = OM133TimedDeployment(xml_tree=self.xml_tree, parent=self)
        return self._timedDeployment

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of intervention

name:	Name of intervention"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM133TimedDeployment(Node):
    """Generated class for 'timedDeployment'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='timedDeployment', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of case management system, used to specify the initial model
or a replacement (an intervention). Encompasses case management
data and some other data required to derive case outcomes.
Contains a sub-element describing the particular health-system in use.
Health system data is here defined as data used to decide on a treatment
strategy, given a case requiring treatment.

name:	Case management system
Base Type:
Description of case management system, used to specify the initial model
or a replacement (an intervention). Encompasses case management
data and some other data required to derive case outcomes.
Contains a sub-element describing the particular health-system in use.
Health system data is here defined as data used to decide on a treatment
strategy, given a case requiring treatment.

name:	Case management system"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': [['EventScheduler', 'ImmediateOutcomes', 'DecisionTree5Day'], 'CFR', 'pSequelaeInpatient']}, 'type': 'om:HealthSystem', 'attributes': {'time': 'required'}, 'children': {'EventScheduler': {'minOccurs': '1', 'maxOccurs': '1'}, 'ImmediateOutcomes': {'minOccurs': '1', 'maxOccurs': '1'}, 'DecisionTree5Day': {'minOccurs': '1', 'maxOccurs': '1'}, 'CFR': {'minOccurs': '1', 'maxOccurs': '1'}, 'pSequelaeInpatient': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.time: OM133TimedDeployment._Time = self._Time(xml_tree=xml_tree, parent=self)
        self._EventScheduler: OM28EventScheduler | None = None
        self._ImmediateOutcomes: OM29ImmediateOutcomes | None = None
        self._DecisionTree5Day: OM30DecisionTree5Day | None = None
        self._CFR: OM31CFR | None = None
        self._pSequelaeInpatient: OM32PSequelaeInpatient | None = None

    @property
    def EventScheduler(self) -> 'OM28EventScheduler':
        """Initialize 'EventScheduler'."""
        if self._EventScheduler is None:
            self._EventScheduler = OM28EventScheduler(xml_tree=self.xml_tree, parent=self)
        return self._EventScheduler

    @property
    def ImmediateOutcomes(self) -> 'OM29ImmediateOutcomes':
        """Initialize 'ImmediateOutcomes'."""
        if self._ImmediateOutcomes is None:
            self._ImmediateOutcomes = OM29ImmediateOutcomes(xml_tree=self.xml_tree, parent=self)
        return self._ImmediateOutcomes

    @property
    def DecisionTree5Day(self) -> 'OM30DecisionTree5Day':
        """Initialize 'DecisionTree5Day'."""
        if self._DecisionTree5Day is None:
            self._DecisionTree5Day = OM30DecisionTree5Day(xml_tree=self.xml_tree, parent=self)
        return self._DecisionTree5Day

    @property
    def CFR(self) -> 'OM31CFR':
        """Initialize 'CFR'."""
        if self._CFR is None:
            self._CFR = OM31CFR(xml_tree=self.xml_tree, parent=self)
        return self._CFR

    @property
    def pSequelaeInpatient(self) -> 'OM32PSequelaeInpatient':
        """Initialize 'pSequelaeInpatient'."""
        if self._pSequelaeInpatient is None:
            self._pSequelaeInpatient = OM32PSequelaeInpatient(xml_tree=self.xml_tree, parent=self)
        return self._pSequelaeInpatient

    class _Time(AttributeNode):
        """Generated class for 'time'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='time', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Time at which this replacement occurs. See doc on
intervention period and on monitoring/startDate for
details of how times work.
Can be specified in steps, days, years, or as a date
(examples: 15t, 75d, 0.2y, 2000-03-16).

name:	Time
units:	User defined (defauls to steps)
min:	0"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM134ChangeEIR(Node):
    """Generated class for 'changeEIR'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='changeEIR', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
New description of transmission level for models not
supporting vector control interventions. Use of this overrides
previous transmission levels such that human infectiousness no
longer has any feedback effect on transmission. Supplied EIR
data must last until end of simulation.

name:	Change transmission levels"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['timedDeployment']}, 'attributes': {'name': 'optional'}, 'children': {'timedDeployment': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.name: OM134ChangeEIR._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._timedDeployment: OM135TimedDeployment | None = None

    @property
    def timedDeployment(self) -> 'OM135TimedDeployment':
        """Initialize 'timedDeployment'."""
        if self._timedDeployment is None:
            self._timedDeployment = OM135TimedDeployment(xml_tree=self.xml_tree, parent=self)
        return self._timedDeployment

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of intervention

name:	Name of intervention"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM135TimedDeployment(Node):
    """Generated class for 'timedDeployment'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='timedDeployment', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': ['EIRDaily']}, 'type': 'om:NonVector', 'attributes': {'time': 'required', 'eipDuration': 'required'}, 'children': {'EIRDaily': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.time: OM135TimedDeployment._Time = self._Time(xml_tree=xml_tree, parent=self)
        self.eipDuration: OM135TimedDeployment._EipDuration = self._EipDuration(xml_tree=xml_tree, parent=self)
        self._EIRDaily: OM312EIRDaily | None = None

    @property
    def EIRDaily(self) -> 'OM312EIRDaily':
        """Initialize 'EIRDaily'."""
        if self._EIRDaily is None:
            self._EIRDaily = OM312EIRDaily(xml_tree=self.xml_tree, parent=self)
        return self._EIRDaily

    class _Time(AttributeNode):
        """Generated class for 'time'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='time', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Time at which this replacement occurs. See doc on
intervention period and on monitoring/startDate for
details of how times work.
Can be specified in steps, days, years, or as a date
(examples: 15t, 75d, 0.2y, 2000-03-16).

name:	Time
units:	User defined (defauls to steps)
min:	0"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _EipDuration(AttributeNode):
        """Generated class for 'eipDuration'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='eipDuration', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Element:
The duration of sporogony in days
units:	Days
name:	Duration of sporogony
Type:
The duration of sporogony in days
units:	Days
name:	Duration of sporogony"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM136ImportedInfections(Node):
    """Generated class for 'importedInfections'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='importedInfections', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Models importation of P. falciparum infections directly into humans
from an external source. This is infections, not inoculations or
EIR being imported.

name:	Imported infections"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['timed']}, 'attributes': {'name': 'optional'}, 'children': {'timed': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM136ImportedInfections._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._timed: OM137Timed | None = None

    @property
    def timed(self) -> 'OM137Timed':
        """Initialize 'timed'."""
        if self._timed is None:
            self._timed = OM137Timed(xml_tree=self.xml_tree, parent=self)
        return self._timed

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of intervention

name:	Name of intervention"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM137Timed(Node):
    """Generated class for 'timed'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='timed', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Rate of case importation, as a step function. Each value is
valid until replaced by the next value.

name:	Rate of importation"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': ['rate']}, 'attributes': {'period': ''}, 'children': {'rate': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.period: OM137Timed._Period = self._Period(xml_tree=xml_tree, parent=self)
        self._rate: OM138Rate | None = None

    @property
    def rate(self) -> 'OM138Rate':
        """Initialize 'rate'."""
        if self._rate is None:
            self._rate = OM138Rate(xml_tree=self.xml_tree, parent=self)
        return self._rate

    class _Period(AttributeNode):
        """Generated class for 'period'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='period', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If period is 0 (or effectively infinite), the last specified
value remains indefinitely in effect.
If period is less than the length of the simulation's intervention phase,
then all "rate" deployments are repeated with this periodicity.
In this case, the first "rate" deployment must coincide with the start of
the intervention phase (monitoring/startDate).
Can be specified in steps (e.g. 1t) or days (e.g. 365d).

name:	Period of repetition
units:	User defined (default:	 steps)
min:	0"""
            self._metadata: dict = {'type': 'xs:string', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}


class OM138Rate(Node):
    """Generated class for 'rate'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='rate', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'minOccurs': '1', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'type': 'om:DoubleValue', 'attributes': {'time': 'required', 'value': 'required'}, 'children': {}}
        self.time: OM138Rate._Time = self._Time(xml_tree=xml_tree, parent=self)
        self.value: OM138Rate._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Time(AttributeNode):
        """Generated class for 'time'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='time', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Time at which this importation rate becomes active.
See doc on intervention period and on monitoring/startDate for
details of how times work. Can be specified in steps, days,
years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).

name:	Time of start
units:	User defined (defauls to steps)
min:	0"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Element:
A double-precision floating-point value.
name:	Input parameter value
exposed:	false
Type:
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM139InsertR_0Case(Node):
    """Generated class for 'insertR_0Case'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='insertR_0Case', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Used to simulate R_0. First, infections should be eliminated,
immunity removed, and the population given an effective transmission-
blocking vaccine (not done by this intervention). Then this
intervention may be used to: pick one human, infect him, administer
a fully effective Preerythrocytic vaccine and remove
transmission-blocking vaccine effect on this human. Thus only this
one human will be a source of infections in an unprotected population,
and will not reinfected himself.

name:	Insert R_0 case"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['timedDeployment']}, 'attributes': {'name': 'optional'}, 'children': {'timedDeployment': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.name: OM139InsertR_0Case._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._timedDeployment: OM133TimedDeployment | None = None

    @property
    def timedDeployment(self) -> 'OM133TimedDeployment':
        """Initialize 'timedDeployment'."""
        if self._timedDeployment is None:
            self._timedDeployment = OM133TimedDeployment(xml_tree=self.xml_tree, parent=self)
        return self._timedDeployment

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of intervention

name:	Name of intervention"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM140TimedDeployment(Node):
    """Generated class for 'timedDeployment'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='timedDeployment', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'time': 'required'}, 'children': {}}
        self.time: OM140TimedDeployment._Time = self._Time(xml_tree=xml_tree, parent=self)

    class _Time(AttributeNode):
        """Generated class for 'time'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='time', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Time at which this intervention occurs.
See doc on intervention period and on monitoring/startDate for
details of how times work. Can be specified in steps, days,
years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).

name:	Time
units:	User defined (defauls to steps)
min:	0"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM141UninfectVectors(Node):
    """Generated class for 'uninfectVectors'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='uninfectVectors', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Removes all infections from mosquitoes -- resulting in zero EIR to
humans, until such time that mosquitoes are re-infected and become
infectious. Only efficacious in dynamic EIR mode (when changeEIR was
not used).
Hypothetical, but potentially useful to simulate a setting starting
from no infections, but with enough mosquitoes to reach a set
equilibrium of exposure.

units:	List of elements
name:	Uninfect vectors"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['timedDeployment']}, 'attributes': {'name': 'optional'}, 'children': {'timedDeployment': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.name: OM141UninfectVectors._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._timedDeployment: OM133TimedDeployment | None = None

    @property
    def timedDeployment(self) -> 'OM133TimedDeployment':
        """Initialize 'timedDeployment'."""
        if self._timedDeployment is None:
            self._timedDeployment = OM133TimedDeployment(xml_tree=self.xml_tree, parent=self)
        return self._timedDeployment

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of intervention

name:	Name of intervention"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM142TimedDeployment(Node):
    """Generated class for 'timedDeployment'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='timedDeployment', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'time': 'required'}, 'children': {}}
        self.time: OM142TimedDeployment._Time = self._Time(xml_tree=xml_tree, parent=self)

    class _Time(AttributeNode):
        """Generated class for 'time'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='time', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Time at which this intervention occurs.
See doc on intervention period and on monitoring/startDate for
details of how times work. Can be specified in steps, days,
years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).

name:	Time
units:	User defined (defauls to steps)
min:	0"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM143VectorPop(Node):
    """Generated class for 'vectorPop'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='vectorPop', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A list of parameterisations of generic vector host-inspecific interventions.
name:	Vector population intervention
units:	List of elements"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['intervention']}, 'attributes': {}, 'children': {'intervention': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._intervention: OM144Intervention | None = None

    @property
    def intervention(self) -> 'OM144Intervention':
        """Initialize 'intervention'."""
        if self._intervention is None:
            self._intervention = OM144Intervention(xml_tree=self.xml_tree, parent=self)
        return self._intervention


class OM144Intervention(Node):
    """Generated class for 'intervention'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='intervention', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
An intervention which may have various effects on the vector populations as a whole. (Not host specific.)
Multiple instances of this intervention class are allowed (multiple parameterisations, not just deployments).
Each instance may have multiple deployments. In this case the effects of each instance
are independent (effects are combined) but the effects of multiple deployments of a single
instance are not independent (only the latest deployment has any effect).

units:	List of elements
name:	Vector population intervention"""
        self._metadata: dict = {'minOccurs': '1', 'maxOccurs': 'unbounded', 'type': 'om:VectorIntervention', 'children_metadata': {'ordered': 'sequence', 'order': ['description', 'timed']}, 'attributes': {'name': 'required'}, 'children': {'description': {'minOccurs': '1', 'maxOccurs': '1'}, 'timed': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self.name: OM144Intervention._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._description: OM173Description | None = None
        self._timed: OM175Timed | None = None

    @property
    def description(self) -> 'OM173Description':
        """Initialize 'description'."""
        if self._description is None:
            self._description = OM173Description(xml_tree=self.xml_tree, parent=self)
        return self._description

    @property
    def timed(self) -> 'OM175Timed':
        """Initialize 'timed'."""
        if self._timed is None:
            self._timed = OM175Timed(xml_tree=self.xml_tree, parent=self)
        return self._timed

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of intervention (e.g. larviciding, sugar bait).

name:	Name of intervention"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM145VectorTrap(Node):
    """Generated class for 'vectorTrap'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='vectorTrap', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Traps attract and kill mosquitoes. They are modelled as a
non-human-host where the probability of mosquitoes surviving
feeding is zero (since otherwise the simulator would assume
surviving mosquitoes have had a blood meal), and where this
"host" is initially not present.
Model: each type of trap has has an initial availability
relative to a human and a decay in availability. Each
deployment has a fixed maximum lifespan, after which the
traps from that deployment are removed (it is up to the
user whether this is after availability is effectively zero
or sooner, either coinciding with a redeployment or
causing a reduction in overall effectiveness of traps).

name:	Baited trap"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['intervention']}, 'attributes': {}, 'children': {'intervention': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._intervention: OM146Intervention | None = None

    @property
    def intervention(self) -> 'OM146Intervention':
        """Initialize 'intervention'."""
        if self._intervention is None:
            self._intervention = OM146Intervention(xml_tree=self.xml_tree, parent=self)
        return self._intervention


class OM146Intervention(Node):
    """Generated class for 'intervention'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='intervention', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Parameters and deployment of one type of trap. In case multiple types
of trap are needed simultaneously, multiple elements can be used. Note
that different types of trap do not interact except that all will
attract mosquitoes.

name:	Vector trap intervetion"""
        self._metadata: dict = {'type': 'om:VectorTrap', 'minOccurs': '1', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': ['description', 'timed']}, 'attributes': {'name': 'optional'}, 'children': {'description': {'minOccurs': '1', 'maxOccurs': '1'}, 'timed': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM146Intervention._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._description: OM173Description | None = None
        self._timed: OM137Timed | None = None

    @property
    def description(self) -> 'OM173Description':
        """Initialize 'description'."""
        if self._description is None:
            self._description = OM173Description(xml_tree=self.xml_tree, parent=self)
        return self._description

    @property
    def timed(self) -> 'OM137Timed':
        """Initialize 'timed'."""
        if self._timed is None:
            self._timed = OM137Timed(xml_tree=self.xml_tree, parent=self)
        return self._timed

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Optional name for this type of trap

name:	Descriptive name for type of trap"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM147NonHumanHostsModifications(Node):
    """Generated class for 'nonHumanHostsModifications'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='nonHumanHostsModifications', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
List of interventions that modify  parameters of non-human hosts described in the <entomology> <vector> <anopheles>."""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['intervention']}, 'attributes': {}, 'children': {'intervention': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._intervention: OM148Intervention | None = None

    @property
    def intervention(self) -> 'OM148Intervention':
        """Initialize 'intervention'."""
        if self._intervention is None:
            self._intervention = OM148Intervention(xml_tree=self.xml_tree, parent=self)
        return self._intervention


class OM148Intervention(Node):
    """Generated class for 'intervention'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='intervention', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
This intervention modifies parameters of non-human hosts described in the <entomology> <vector> <anopheles>
<nonHumanHosts> section of the input scenario file.
The intervention is described by 5 parameters that define the change in each of non-human host parameters: 
reduceAvailability: Reduction in the availability rate, i. For example a value of 0 will result in no change; a value of 0.2 will reduce the availability to 0.8 of its initial value; and a value of 1 will set the availability to 0;
prePrandialKillingEffect: Reduction in the pre-prandial survival probability, PBi.  For example a value of 0 will result in no change; a value of 0.2 will reduce PBi to 0.8 of its initial value; and a value of 1 will set PBi to 0;
postPrandialKillingEffect: Reduction in the post-prandial survival probability, PCi.  For example a value of 0 will result in no change; a value of 0.2 will reduce PCi to 0.8 of its initial value; and a value of 1 will set PCi to 0;
restingKillingEffect: Reduction in the survival probability of the resting period, PDi.  For example a value of 0 will result in no change; a value of 0.2 will reduce PDi to 0.8 of its initial value; and a value of 1 will set PDi to 0;"""
        self._metadata: dict = {'minOccurs': '1', 'maxOccurs': 'unbounded', 'type': 'om:NonHumanHostsIntervention', 'children_metadata': {'ordered': 'sequence', 'order': ['decay', 'description', 'timed']}, 'attributes': {'name': 'required', 'nonHumanHostsName': 'required'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}, 'description': {'minOccurs': '1', 'maxOccurs': '1'}, 'timed': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self.name: OM148Intervention._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.nonHumanHostsName: OM148Intervention._NonHumanHostsName = self._NonHumanHostsName(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None
        self._description: OM173Description | None = None
        self._timed: OM175Timed | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    @property
    def description(self) -> 'OM173Description':
        """Initialize 'description'."""
        if self._description is None:
            self._description = OM173Description(xml_tree=self.xml_tree, parent=self)
        return self._description

    @property
    def timed(self) -> 'OM175Timed':
        """Initialize 'timed'."""
        if self._timed is None:
            self._timed = OM175Timed(xml_tree=self.xml_tree, parent=self)
        return self._timed

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of intervention (e.g. larviciding, sugar bait).

name:	Name of intervention"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _NonHumanHostsName(AttributeNode):
        """Generated class for 'nonHumanHostsName'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='nonHumanHostsName', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of intervention (e.g. larviciding, sugar bait).

name:	Name of intervention"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM149AddNonHumanHosts(Node):
    """Generated class for 'addNonHumanHosts'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='addNonHumanHosts', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
List of intervention that add new non-human hosts that have not been described in the <entomology> <vector>
<anopheles> <nonHumanHosts>."""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['nonHumanHosts']}, 'attributes': {}, 'children': {'nonHumanHosts': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._nonHumanHosts: OM150NonHumanHosts | None = None

    @property
    def nonHumanHosts(self) -> 'OM150NonHumanHosts':
        """Initialize 'nonHumanHosts'."""
        if self._nonHumanHosts is None:
            self._nonHumanHosts = OM150NonHumanHosts(xml_tree=self.xml_tree, parent=self)
        return self._nonHumanHosts


class OM150NonHumanHosts(Node):
    """Generated class for 'nonHumanHosts'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='nonHumanHosts', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes a new non-human hosts that have not been described in the <entomology> <vector> <anopheles> <nonHumanHosts>."""
        self._metadata: dict = {'minOccurs': '1', 'maxOccurs': 'unbounded', 'type': 'om:NonHumanHosts', 'children_metadata': {'ordered': 'sequence', 'order': ['description', 'timed']}, 'attributes': {'name': 'required'}, 'children': {'description': {'minOccurs': '1', 'maxOccurs': '1'}, 'timed': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM150NonHumanHosts._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._description: OM173Description | None = None
        self._timed: OM137Timed | None = None

    @property
    def description(self) -> 'OM173Description':
        """Initialize 'description'."""
        if self._description is None:
            self._description = OM173Description(xml_tree=self.xml_tree, parent=self)
        return self._description

    @property
    def timed(self) -> 'OM137Timed':
        """Initialize 'timed'."""
        if self._timed is None:
            self._timed = OM137Timed(xml_tree=self.xml_tree, parent=self)
        return self._timed

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of intervention (e.g. larviciding, sugar bait).

name:	Name of intervention"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM151Human(Node):
    """Generated class for 'human'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='human', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Encapsulates all interventions whose effects are specific to the
human host: any interventions where target humans may be selected
via population-coverage, age limits and sub-population membership.

name:	Human-specific interventions"""
        self._metadata: dict = {'type': 'om:HumanInterventions', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['component', 'deployment']}, 'attributes': {}, 'children': {'component': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deployment': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self._component: OM152Component | None = None
        self._deployment: OM153Deployment | None = None

    @property
    def component(self) -> 'OM152Component':
        """Initialize 'component'."""
        if self._component is None:
            self._component = OM152Component(xml_tree=self.xml_tree, parent=self)
        return self._component

    @property
    def deployment(self) -> 'OM153Deployment':
        """Initialize 'deployment'."""
        if self._deployment is None:
            self._deployment = OM153Deployment(xml_tree=self.xml_tree, parent=self)
        return self._deployment


class OM152Component(Node):
    """Generated class for 'component'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='component', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A parameterisation of an effect achieved by one component of an
intervention. (An intervention is described as the effects of a set
of components plus deployments of those components. This describes
the components individually, not deployments or which components
comprise an intervention.)
Each element describes one component: its effects, decay of the(se)
effect(s), and related stuff (e.g. description of indirect decay
and of usage levels).
Different interventions can deploy the same component to the same
perso. In most cases this will just deploy a fresh instance (e.g. a
new bed net will replace the old (nobody uses multiple bed nets),
or a new drug dose will act on top of previous doses, or in the
case of a vaccine, effect depends on the total number of previous
inoculations (including from other interventions).
Where multiple components of the same type (but with different ids)
are deployed (whether within a single intervention or by multiple
interventions), they act independently (e.g. two bed nets deployed
to a single host would act to reduce attractiveness or survival of
mosquitoes biting that host twice  this may be useful to simulate
some novel vector intervention since the two nets may have separate
parameters).

name:	Component"""
        self._metadata: dict = {'minOccurs': '1', 'maxOccurs': 'unbounded', 'type': 'om:HumanInterventionComponent', 'children_metadata': {'ordered': 'sequence', 'order': [['screen', 'treatSimple', 'treatPKPD', 'decisionTree', 'PEV', 'BSV', 'TBV', 'ITN', 'IRS', 'GVI', 'recruitmentOnly', 'clearImmunity'], 'subPopRemoval']}, 'attributes': {'id': 'required', 'name': 'optional'}, 'children': {'screen': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'decisionTree': {'minOccurs': '1', 'maxOccurs': '1'}, 'PEV': {'minOccurs': '1', 'maxOccurs': '1'}, 'BSV': {'minOccurs': '1', 'maxOccurs': '1'}, 'TBV': {'minOccurs': '1', 'maxOccurs': '1'}, 'ITN': {'minOccurs': '1', 'maxOccurs': '1'}, 'IRS': {'minOccurs': '1', 'maxOccurs': '1'}, 'GVI': {'minOccurs': '1', 'maxOccurs': '1'}, 'recruitmentOnly': {'minOccurs': '0', 'maxOccurs': '1'}, 'clearImmunity': {'minOccurs': '1', 'maxOccurs': '1'}, 'subPopRemoval': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self.id: OM152Component._Id = self._Id(xml_tree=xml_tree, parent=self)
        self.name: OM152Component._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._screen: OM158Screen | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._decisionTree: OM161DecisionTree | None = None
        self._PEV: OM162PEV | None = None
        self._BSV: OM163BSV | None = None
        self._TBV: OM164TBV | None = None
        self._ITN: OM165ITN | None = None
        self._IRS: OM166IRS | None = None
        self._GVI: OM167GVI | None = None
        self._recruitmentOnly: OM168RecruitmentOnly | None = None
        self._clearImmunity: OM169ClearImmunity | None = None
        self._subPopRemoval: OM170SubPopRemoval | None = None

    @property
    def screen(self) -> 'OM158Screen':
        """Initialize 'screen'."""
        if self._screen is None:
            self._screen = OM158Screen(xml_tree=self.xml_tree, parent=self)
        return self._screen

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def decisionTree(self) -> 'OM161DecisionTree':
        """Initialize 'decisionTree'."""
        if self._decisionTree is None:
            self._decisionTree = OM161DecisionTree(xml_tree=self.xml_tree, parent=self)
        return self._decisionTree

    @property
    def PEV(self) -> 'OM162PEV':
        """Initialize 'PEV'."""
        if self._PEV is None:
            self._PEV = OM162PEV(xml_tree=self.xml_tree, parent=self)
        return self._PEV

    @property
    def BSV(self) -> 'OM163BSV':
        """Initialize 'BSV'."""
        if self._BSV is None:
            self._BSV = OM163BSV(xml_tree=self.xml_tree, parent=self)
        return self._BSV

    @property
    def TBV(self) -> 'OM164TBV':
        """Initialize 'TBV'."""
        if self._TBV is None:
            self._TBV = OM164TBV(xml_tree=self.xml_tree, parent=self)
        return self._TBV

    @property
    def ITN(self) -> 'OM165ITN':
        """Initialize 'ITN'."""
        if self._ITN is None:
            self._ITN = OM165ITN(xml_tree=self.xml_tree, parent=self)
        return self._ITN

    @property
    def IRS(self) -> 'OM166IRS':
        """Initialize 'IRS'."""
        if self._IRS is None:
            self._IRS = OM166IRS(xml_tree=self.xml_tree, parent=self)
        return self._IRS

    @property
    def GVI(self) -> 'OM167GVI':
        """Initialize 'GVI'."""
        if self._GVI is None:
            self._GVI = OM167GVI(xml_tree=self.xml_tree, parent=self)
        return self._GVI

    @property
    def recruitmentOnly(self) -> 'OM168RecruitmentOnly':
        """Initialize 'recruitmentOnly'."""
        if self._recruitmentOnly is None:
            self._recruitmentOnly = OM168RecruitmentOnly(xml_tree=self.xml_tree, parent=self)
        return self._recruitmentOnly

    @property
    def clearImmunity(self) -> 'OM169ClearImmunity':
        """Initialize 'clearImmunity'."""
        if self._clearImmunity is None:
            self._clearImmunity = OM169ClearImmunity(xml_tree=self.xml_tree, parent=self)
        return self._clearImmunity

    @property
    def subPopRemoval(self) -> 'OM170SubPopRemoval':
        """Initialize 'subPopRemoval'."""
        if self._subPopRemoval is None:
            self._subPopRemoval = OM170SubPopRemoval(xml_tree=self.xml_tree, parent=self)
        return self._subPopRemoval

    class _Id(AttributeNode):
        """Generated class for 'id'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='id', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A short name or code identifying the intervention component
(used to refer to this component when describing an intervention).
Also the id of the sub-population defined as those hosts who have
received this intervention and who haven't subsequently been removed
from the sub-population.

name:	Component identifier"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An informal name/description for the component

name:	Name of component"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM153Deployment(Node):
    """Generated class for 'deployment'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='deployment', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
This element describes deployment of an intervention: which
components are deployed, how humans are selected for deployment
(via timed or age-based deployment) as well as a few additional
restrictions (e.g. vaccine dosing restrictions).
All components deployed by this intervention are deployed to the
same people (each timed or continuous deployment selects recipients
and then gives each recipient all components of the intervention).

name:	Deployment"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['component', 'condition', 'continuous', 'timed']}, 'attributes': {'name': 'optional'}, 'children': {'component': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'condition': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'continuous': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'timed': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.name: OM153Deployment._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._component: OM154Component | None = None
        self._condition: OM155Condition | None = None
        self._continuous: OM156Continuous | None = None
        self._timed: OM157Timed | None = None

    @property
    def component(self) -> 'OM154Component':
        """Initialize 'component'."""
        if self._component is None:
            self._component = OM154Component(xml_tree=self.xml_tree, parent=self)
        return self._component

    @property
    def condition(self) -> 'OM155Condition':
        """Initialize 'condition'."""
        if self._condition is None:
            self._condition = OM155Condition(xml_tree=self.xml_tree, parent=self)
        return self._condition

    @property
    def continuous(self) -> 'OM156Continuous':
        """Initialize 'continuous'."""
        if self._continuous is None:
            self._continuous = OM156Continuous(xml_tree=self.xml_tree, parent=self)
        return self._continuous

    @property
    def timed(self) -> 'OM157Timed':
        """Initialize 'timed'."""
        if self._timed is None:
            self._timed = OM157Timed(xml_tree=self.xml_tree, parent=self)
        return self._timed

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of intervention
name:	Intervention name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM154Component(Node):
    """Generated class for 'component'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='component', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The list of components deployed to eligible humans.

name:	Component to be deployed"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'type': 'om:Component', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'id': 'required'}, 'children': {}}
        self.id: OM154Component._Id = self._Id(xml_tree=xml_tree, parent=self)

    class _Id(AttributeNode):
        """Generated class for 'id'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='id', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The identifier (short name) of a component.

name:	Identifier"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM155Condition(Node):
    """Generated class for 'condition'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='condition', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
If conditions are specified, deployment of this intervention will only go ahead
if all specified conditions are true. Condition statements are evaluated only
during surveys, so deployment is enabled or disabled depending on the results
of the most recent survey. So called *unreported surveys* can be used to
reevaluate conditions without increasing granularity of output.
Conditions are evaluated for the whole population, not for individual age-groups
or cohorts.
This affects all types of deployment.

name:	Condition"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'measure': 'required', 'minValue': 'optional', 'maxValue': 'optional', 'initialState': 'required'}, 'children': {}}
        self.measure: OM155Condition._Measure = self._Measure(xml_tree=xml_tree, parent=self)
        self.minValue: OM155Condition._MinValue = self._MinValue(xml_tree=xml_tree, parent=self)
        self.maxValue: OM155Condition._MaxValue = self._MaxValue(xml_tree=xml_tree, parent=self)
        self.initialState: OM155Condition._InitialState = self._InitialState(xml_tree=xml_tree, parent=self)

    class _Measure(AttributeNode):
        """Generated class for 'measure'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='measure', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The monitoring measure to test. Not all measures are available for use.

name:	Measure"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _MinValue(AttributeNode):
        """Generated class for 'minValue'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='minValue', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Minimum value. If specified, the measured variable must be greater than 
or equal to this value for the condition to be satisfied.

name:	Minimum value"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _MaxValue(AttributeNode):
        """Generated class for 'maxValue'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='maxValue', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Maximum value. If specified, the measured variable must be less than or
equal to this value for the condition to be satisfied.

name:	Maximum value"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _InitialState(AttributeNode):
        """Generated class for 'initialState'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initialState', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Whether this condition is considered true or false before updated by a survey.

name:	Initial state"""
            self._metadata: dict = {'type': 'xs:boolean', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM156Continuous(Node):
    """Generated class for 'continuous'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='continuous', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
List of ages at which deployment takes place
(through EPI, post-natal and school-based programmes, etc.).
A sub-population restriction may be added as a property of the
list of continuous deployments.

name:	Age-based (continuous) deployment"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'type': 'om:ContinuousList', 'children_metadata': {'ordered': 'sequence', 'order': ['restrictToSubPop', 'deploy']}, 'attributes': {}, 'children': {'restrictToSubPop': {'minOccurs': '0', 'maxOccurs': '1'}, 'deploy': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._restrictToSubPop: OM181RestrictToSubPop | None = None
        self._deploy: OM182Deploy | None = None

    @property
    def restrictToSubPop(self) -> 'OM181RestrictToSubPop':
        """Initialize 'restrictToSubPop'."""
        if self._restrictToSubPop is None:
            self._restrictToSubPop = OM181RestrictToSubPop(xml_tree=self.xml_tree, parent=self)
        return self._restrictToSubPop

    @property
    def deploy(self) -> 'OM182Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM182Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy


class OM157Timed(Node):
    """Generated class for 'timed'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='timed', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
List of timed deployments of the intervention (that is, of
deployment campaigns).
Cumulative deployment mode can be specified for all deployments in a timed list.
To allow multiple cumulative deployment descriptions, the entire timed list
may be repeated.

name:	Mass (timed) deployment"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'type': 'om:MassListWithCum', 'children_metadata': {'ordered': 'sequence', 'order': ['restrictToSubPop', 'cumulativeCoverage', 'deploy']}, 'attributes': {}, 'children': {'restrictToSubPop': {'minOccurs': '0', 'maxOccurs': '1'}, 'cumulativeCoverage': {'minOccurs': '0', 'maxOccurs': '1'}, 'deploy': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._restrictToSubPop: OM181RestrictToSubPop | None = None
        self._cumulativeCoverage: OM185CumulativeCoverage | None = None
        self._deploy: OM186Deploy | None = None

    @property
    def restrictToSubPop(self) -> 'OM181RestrictToSubPop':
        """Initialize 'restrictToSubPop'."""
        if self._restrictToSubPop is None:
            self._restrictToSubPop = OM181RestrictToSubPop(xml_tree=self.xml_tree, parent=self)
        return self._restrictToSubPop

    @property
    def cumulativeCoverage(self) -> 'OM185CumulativeCoverage':
        """Initialize 'cumulativeCoverage'."""
        if self._cumulativeCoverage is None:
            self._cumulativeCoverage = OM185CumulativeCoverage(xml_tree=self.xml_tree, parent=self)
        return self._cumulativeCoverage

    @property
    def deploy(self) -> 'OM186Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM186Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy


class OM158Screen(Node):
    """Generated class for 'screen'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='screen', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
This can be combined with MDA to achieve mass screen and treat (MSAT)
or other types of mass screening intervention.
When deployed to a host, this simulates a test of patent malaria
(microscopy, RDT or some such), then triggers deployment of whichever
intervention components are configured (deployments for both positive
and negative test outcomes can be configured).
The use of the screening itself is reported (if enabled), but not the
outcome. Deployment of interventions triggered by the screening may
be reported, however.

name:	(Mass) screening"""
        self._metadata: dict = {'type': 'om:Screen', 'children_metadata': {'ordered': 'sequence', 'order': ['positive', 'negative']}, 'attributes': {'diagnostic': 'required'}, 'children': {'positive': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'negative': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.diagnostic: OM158Screen._Diagnostic = self._Diagnostic(xml_tree=xml_tree, parent=self)
        self._positive: OM171Positive | None = None
        self._negative: OM172Negative | None = None

    @property
    def positive(self) -> 'OM171Positive':
        """Initialize 'positive'."""
        if self._positive is None:
            self._positive = OM171Positive(xml_tree=self.xml_tree, parent=self)
        return self._positive

    @property
    def negative(self) -> 'OM172Negative':
        """Initialize 'negative'."""
        if self._negative is None:
            self._negative = OM172Negative(xml_tree=self.xml_tree, parent=self)
        return self._negative

    class _Diagnostic(AttributeNode):
        """Generated class for 'diagnostic'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='diagnostic', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of a parameterised diagnostic (see scenario/diagnostics).

name:	Name of diagnostic"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM159TreatSimple(Node):
    """Generated class for 'treatSimple'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='treatSimple', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Simple treatment model, targetting liver- and/or blood-stage
infections. This is all-or-nothing treatment which, when deploymed,
completely clears all infections of the targetted stages. This makes it
unsuitable for modeling resistance, but suitable for use with simple
infection models.
Infections are considered liver-stage when less than five days old and
blood-stage after that. Effects are described independently for the two
stages.

name:	Simple treatment"""
        self._metadata: dict = {'type': 'om:DTTreatSimple', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'durationLiver': 'required', 'durationBlood': 'required'}, 'children': {}}
        self.durationLiver: OM159TreatSimple._DurationLiver = self._DurationLiver(xml_tree=xml_tree, parent=self)
        self.durationBlood: OM159TreatSimple._DurationBlood = self._DurationBlood(xml_tree=xml_tree, parent=self)

    class _DurationLiver(AttributeNode):
        """Generated class for 'durationLiver'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='durationLiver', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Controls action on liver-stage infections. 0 means no action, -1 step
is a compatibility option to act like treatment before schema version
32 (which removed infections retrospectively), 1 step or any duration
which equals some whole number of steps n>0 means to clear all
liver-stage infections found on the next 1 or n steps.
Note on -1 compatibility option: the main difference to 1 step
(clearing on the next timestep) is that parasite densities will be
reduced immediately, and thus from the point of view of surveys and
mass screen and treat interventions a peak in density which is
immediately treated through case management will not be seen.
Can be specified in steps (e.g. 1t, -1t) or days (e.g. 5d).

name:	Length of liver-stage effect
units:	User defined"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _DurationBlood(AttributeNode):
        """Generated class for 'durationBlood'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='durationBlood', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Controls action on blood-stage infections. 0 means no action, -1 step
is a compatibility option to act like treatment before schema version
32 (which removed infections retrospectively), 1 step or any duration
which equals some whole number of steps n>0 means to clear all
blood-stage infections found on the next 1 or n steps.
Note on -1 compatibility option: the main difference to 1 step
(clearing on the next timestep) is that parasite densities will be
reduced immediately, and thus from the point of view of surveys and
mass screen and treat interventions a peak in density which is
immediately treated through case management will not be seen.
Can be specified in steps (e.g. 1t, -1t) or days (e.g. 5d).

name:	Length of blood-stage effect
units:	User defined"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM160TreatPKPD(Node):
    """Generated class for 'treatPKPD'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='treatPKPD', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A command to administer drugs according to a given schedule and
dosage table, optionally with a delay.

name:	Treatment (PK/PD model)"""
        self._metadata: dict = {'type': 'om:DTTreatPKPD', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'schedule': 'required', 'dosage': 'required', 'delay_h': ''}, 'children': {}}
        self.schedule: OM160TreatPKPD._Schedule = self._Schedule(xml_tree=xml_tree, parent=self)
        self.dosage: OM160TreatPKPD._Dosage = self._Dosage(xml_tree=xml_tree, parent=self)
        self.delay_h: OM160TreatPKPD._Delay_h = self._Delay_h(xml_tree=xml_tree, parent=self)

    class _Schedule(AttributeNode):
        """Generated class for 'schedule'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='schedule', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The name of a schedule to use for treatment.

name:	Name of treatment schedule"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Dosage(AttributeNode):
        """Generated class for 'dosage'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='dosage', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The name of a dosage table to use for treatment.

name:	Name of dosage table"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Delay_h(AttributeNode):
        """Generated class for 'delay_h'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='delay_h', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Optionally, this can be given to delay the start of treatment by a
given number of hours. If not specified, treatment is not delayed. If
a delay is given, all medications within the treatment schedule used
are delayed by this number of hours.

name:	Delay (hours)"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}


class OM161DecisionTree(Node):
    """Generated class for 'decisionTree'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='decisionTree', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes how "decisions" are made, both probabilistically and
deterministically, and what actions are carried out.
Quantities may also be reported as a side effect of decisions made in
the tree, for example the number of diagnostics used.

name:	Decision tree"""
        self._metadata: dict = {'type': 'om:DecisionTree', 'children_metadata': {'ordered': None, 'order': [['multiple', 'caseType', 'diagnostic', 'uncomplicated', 'severe', 'random', 'age', 'noTreatment', 'report', 'treatFailure', 'treatPKPD', 'treatSimple', 'deploy', 'cohort']]}, 'attributes': {'name': 'optional'}, 'children': {'multiple': {'minOccurs': '1', 'maxOccurs': '1'}, 'caseType': {'minOccurs': '1', 'maxOccurs': '1'}, 'diagnostic': {'minOccurs': '1', 'maxOccurs': '1'}, 'uncomplicated': {'minOccurs': '1', 'maxOccurs': '1'}, 'severe': {'minOccurs': '1', 'maxOccurs': '1'}, 'random': {'minOccurs': '1', 'maxOccurs': '1'}, 'age': {'minOccurs': '1', 'maxOccurs': '1'}, 'noTreatment': {'minOccurs': '1', 'maxOccurs': '1'}, 'report': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatFailure': {'minOccurs': '1', 'maxOccurs': '1'}, 'treatPKPD': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'treatSimple': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'cohort': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM161DecisionTree._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._multiple: OM85Multiple | None = None
        self._caseType: OM86CaseType | None = None
        self._diagnostic: OM87Diagnostic | None = None
        self._uncomplicated: OM88Uncomplicated | None = None
        self._severe: OM89Severe | None = None
        self._random: OM90Random | None = None
        self._age: OM91Age | None = None
        self._noTreatment: OM92NoTreatment | None = None
        self._report: OM93Report | None = None
        self._treatFailure: OM94TreatFailure | None = None
        self._treatPKPD: OM95TreatPKPD | None = None
        self._treatSimple: OM96TreatSimple | None = None
        self._deploy: OM97Deploy | None = None
        self._cohort: OM98Cohort | None = None

    @property
    def multiple(self) -> 'OM85Multiple':
        """Initialize 'multiple'."""
        if self._multiple is None:
            self._multiple = OM85Multiple(xml_tree=self.xml_tree, parent=self)
        return self._multiple

    @property
    def caseType(self) -> 'OM86CaseType':
        """Initialize 'caseType'."""
        if self._caseType is None:
            self._caseType = OM86CaseType(xml_tree=self.xml_tree, parent=self)
        return self._caseType

    @property
    def diagnostic(self) -> 'OM87Diagnostic':
        """Initialize 'diagnostic'."""
        if self._diagnostic is None:
            self._diagnostic = OM87Diagnostic(xml_tree=self.xml_tree, parent=self)
        return self._diagnostic

    @property
    def uncomplicated(self) -> 'OM88Uncomplicated':
        """Initialize 'uncomplicated'."""
        if self._uncomplicated is None:
            self._uncomplicated = OM88Uncomplicated(xml_tree=self.xml_tree, parent=self)
        return self._uncomplicated

    @property
    def severe(self) -> 'OM89Severe':
        """Initialize 'severe'."""
        if self._severe is None:
            self._severe = OM89Severe(xml_tree=self.xml_tree, parent=self)
        return self._severe

    @property
    def random(self) -> 'OM90Random':
        """Initialize 'random'."""
        if self._random is None:
            self._random = OM90Random(xml_tree=self.xml_tree, parent=self)
        return self._random

    @property
    def age(self) -> 'OM91Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM91Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def noTreatment(self) -> 'OM92NoTreatment':
        """Initialize 'noTreatment'."""
        if self._noTreatment is None:
            self._noTreatment = OM92NoTreatment(xml_tree=self.xml_tree, parent=self)
        return self._noTreatment

    @property
    def report(self) -> 'OM93Report':
        """Initialize 'report'."""
        if self._report is None:
            self._report = OM93Report(xml_tree=self.xml_tree, parent=self)
        return self._report

    @property
    def treatFailure(self) -> 'OM94TreatFailure':
        """Initialize 'treatFailure'."""
        if self._treatFailure is None:
            self._treatFailure = OM94TreatFailure(xml_tree=self.xml_tree, parent=self)
        return self._treatFailure

    @property
    def treatPKPD(self) -> 'OM95TreatPKPD':
        """Initialize 'treatPKPD'."""
        if self._treatPKPD is None:
            self._treatPKPD = OM95TreatPKPD(xml_tree=self.xml_tree, parent=self)
        return self._treatPKPD

    @property
    def treatSimple(self) -> 'OM96TreatSimple':
        """Initialize 'treatSimple'."""
        if self._treatSimple is None:
            self._treatSimple = OM96TreatSimple(xml_tree=self.xml_tree, parent=self)
        return self._treatSimple

    @property
    def deploy(self) -> 'OM97Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM97Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy

    @property
    def cohort(self) -> 'OM98Cohort':
        """Initialize 'cohort'."""
        if self._cohort is None:
            self._cohort = OM98Cohort(xml_tree=self.xml_tree, parent=self)
        return self._cohort

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An optional piece of documentation attached to this node.

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM162PEV(Node):
    """Generated class for 'PEV'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='PEV', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Pre-erythrocytic vaccine (PEV): prevents a proportion of infections
from commencing.

name:	Vaccines
Type:
Description of a vaccine's effect
name:	Vaccine descriptions"""
        self._metadata: dict = {'type': 'om:VaccineDescription', 'children_metadata': {'ordered': 'sequence', 'order': ['decay', 'efficacyB', 'initialEfficacy', 'phenotype']}, 'attributes': {}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}, 'efficacyB': {'minOccurs': '1', 'maxOccurs': '1'}, 'initialEfficacy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'phenotype': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self._decay: OM187Decay | None = None
        self._efficacyB: OM188EfficacyB | None = None
        self._initialEfficacy: OM189InitialEfficacy | None = None
        self._phenotype: OM190Phenotype | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    @property
    def efficacyB(self) -> 'OM188EfficacyB':
        """Initialize 'efficacyB'."""
        if self._efficacyB is None:
            self._efficacyB = OM188EfficacyB(xml_tree=self.xml_tree, parent=self)
        return self._efficacyB

    @property
    def initialEfficacy(self) -> 'OM189InitialEfficacy':
        """Initialize 'initialEfficacy'."""
        if self._initialEfficacy is None:
            self._initialEfficacy = OM189InitialEfficacy(xml_tree=self.xml_tree, parent=self)
        return self._initialEfficacy

    @property
    def phenotype(self) -> 'OM190Phenotype':
        """Initialize 'phenotype'."""
        if self._phenotype is None:
            self._phenotype = OM190Phenotype(xml_tree=self.xml_tree, parent=self)
        return self._phenotype


class OM163BSV(Node):
    """Generated class for 'BSV'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='BSV', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Blood-stage vaccine (BSV): acts as a killing factor on blood-stage
parasites. Exact action depends on the within host model.

name:	Vaccines
Type:
Description of a vaccine's effect
name:	Vaccine descriptions"""
        self._metadata: dict = {'type': 'om:VaccineDescription', 'children_metadata': {'ordered': 'sequence', 'order': ['decay', 'efficacyB', 'initialEfficacy', 'phenotype']}, 'attributes': {}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}, 'efficacyB': {'minOccurs': '1', 'maxOccurs': '1'}, 'initialEfficacy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'phenotype': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self._decay: OM187Decay | None = None
        self._efficacyB: OM188EfficacyB | None = None
        self._initialEfficacy: OM189InitialEfficacy | None = None
        self._phenotype: OM190Phenotype | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    @property
    def efficacyB(self) -> 'OM188EfficacyB':
        """Initialize 'efficacyB'."""
        if self._efficacyB is None:
            self._efficacyB = OM188EfficacyB(xml_tree=self.xml_tree, parent=self)
        return self._efficacyB

    @property
    def initialEfficacy(self) -> 'OM189InitialEfficacy':
        """Initialize 'initialEfficacy'."""
        if self._initialEfficacy is None:
            self._initialEfficacy = OM189InitialEfficacy(xml_tree=self.xml_tree, parent=self)
        return self._initialEfficacy

    @property
    def phenotype(self) -> 'OM190Phenotype':
        """Initialize 'phenotype'."""
        if self._phenotype is None:
            self._phenotype = OM190Phenotype(xml_tree=self.xml_tree, parent=self)
        return self._phenotype


class OM164TBV(Node):
    """Generated class for 'TBV'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='TBV', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Transmission-blocking vaccine (TBV): one minus this scales the
probability of transmission to mosquitoes

name:	Vaccines
Type:
Description of a vaccine's effect
name:	Vaccine descriptions"""
        self._metadata: dict = {'type': 'om:VaccineDescription', 'children_metadata': {'ordered': 'sequence', 'order': ['decay', 'efficacyB', 'initialEfficacy', 'phenotype']}, 'attributes': {}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}, 'efficacyB': {'minOccurs': '1', 'maxOccurs': '1'}, 'initialEfficacy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'phenotype': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self._decay: OM187Decay | None = None
        self._efficacyB: OM188EfficacyB | None = None
        self._initialEfficacy: OM189InitialEfficacy | None = None
        self._phenotype: OM190Phenotype | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    @property
    def efficacyB(self) -> 'OM188EfficacyB':
        """Initialize 'efficacyB'."""
        if self._efficacyB is None:
            self._efficacyB = OM188EfficacyB(xml_tree=self.xml_tree, parent=self)
        return self._efficacyB

    @property
    def initialEfficacy(self) -> 'OM189InitialEfficacy':
        """Initialize 'initialEfficacy'."""
        if self._initialEfficacy is None:
            self._initialEfficacy = OM189InitialEfficacy(xml_tree=self.xml_tree, parent=self)
        return self._initialEfficacy

    @property
    def phenotype(self) -> 'OM190Phenotype':
        """Initialize 'phenotype'."""
        if self._phenotype is None:
            self._phenotype = OM190Phenotype(xml_tree=self.xml_tree, parent=self)
        return self._phenotype


class OM165ITN(Node):
    """Generated class for 'ITN'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='ITN', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Description of bed-net interventions (ITNs, LLINs).

name:	Bed nets
Type:name:	Description"""
        self._metadata: dict = {'type': 'om:ITNDescription', 'children_metadata': {'ordered': 'sequence', 'order': ['usage', 'holeRate', 'ripRate', 'ripFactor', 'initialInsecticide', 'insecticideDecay', 'attritionOfNets', 'anophelesParams']}, 'attributes': {}, 'children': {'usage': {'minOccurs': '0', 'maxOccurs': '1'}, 'holeRate': {'minOccurs': '1', 'maxOccurs': '1'}, 'ripRate': {'minOccurs': '1', 'maxOccurs': '1'}, 'ripFactor': {'minOccurs': '1', 'maxOccurs': '1'}, 'initialInsecticide': {'minOccurs': '1', 'maxOccurs': '1'}, 'insecticideDecay': {'minOccurs': '1', 'maxOccurs': '1'}, 'attritionOfNets': {'minOccurs': '1', 'maxOccurs': '1'}, 'anophelesParams': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._usage: OM191Usage | None = None
        self._holeRate: OM192HoleRate | None = None
        self._ripRate: OM193RipRate | None = None
        self._ripFactor: OM194RipFactor | None = None
        self._initialInsecticide: OM195InitialInsecticide | None = None
        self._insecticideDecay: OM196InsecticideDecay | None = None
        self._attritionOfNets: OM197AttritionOfNets | None = None
        self._anophelesParams: OM198AnophelesParams | None = None

    @property
    def usage(self) -> 'OM191Usage':
        """Initialize 'usage'."""
        if self._usage is None:
            self._usage = OM191Usage(xml_tree=self.xml_tree, parent=self)
        return self._usage

    @property
    def holeRate(self) -> 'OM192HoleRate':
        """Initialize 'holeRate'."""
        if self._holeRate is None:
            self._holeRate = OM192HoleRate(xml_tree=self.xml_tree, parent=self)
        return self._holeRate

    @property
    def ripRate(self) -> 'OM193RipRate':
        """Initialize 'ripRate'."""
        if self._ripRate is None:
            self._ripRate = OM193RipRate(xml_tree=self.xml_tree, parent=self)
        return self._ripRate

    @property
    def ripFactor(self) -> 'OM194RipFactor':
        """Initialize 'ripFactor'."""
        if self._ripFactor is None:
            self._ripFactor = OM194RipFactor(xml_tree=self.xml_tree, parent=self)
        return self._ripFactor

    @property
    def initialInsecticide(self) -> 'OM195InitialInsecticide':
        """Initialize 'initialInsecticide'."""
        if self._initialInsecticide is None:
            self._initialInsecticide = OM195InitialInsecticide(xml_tree=self.xml_tree, parent=self)
        return self._initialInsecticide

    @property
    def insecticideDecay(self) -> 'OM196InsecticideDecay':
        """Initialize 'insecticideDecay'."""
        if self._insecticideDecay is None:
            self._insecticideDecay = OM196InsecticideDecay(xml_tree=self.xml_tree, parent=self)
        return self._insecticideDecay

    @property
    def attritionOfNets(self) -> 'OM197AttritionOfNets':
        """Initialize 'attritionOfNets'."""
        if self._attritionOfNets is None:
            self._attritionOfNets = OM197AttritionOfNets(xml_tree=self.xml_tree, parent=self)
        return self._attritionOfNets

    @property
    def anophelesParams(self) -> 'OM198AnophelesParams':
        """Initialize 'anophelesParams'."""
        if self._anophelesParams is None:
            self._anophelesParams = OM198AnophelesParams(xml_tree=self.xml_tree, parent=self)
        return self._anophelesParams


class OM166IRS(Node):
    """Generated class for 'IRS'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='IRS', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Description of indoor residual spraying interventions.

name:	Indoor residual spraying
Type:
Description of effect for the more complex and probably more realistic
Briet model: IRS has three effects, whos strength is calculated as a
function of surviving insecticide content.

name:	Description (based on decay of insecticide)"""
        self._metadata: dict = {'type': 'om:IRSDescription', 'children_metadata': {'ordered': 'sequence', 'order': ['usage', 'initialInsecticide', 'insecticideDecay', 'anophelesParams']}, 'attributes': {}, 'children': {'usage': {'minOccurs': '0', 'maxOccurs': '1'}, 'initialInsecticide': {'minOccurs': '1', 'maxOccurs': '1'}, 'insecticideDecay': {'minOccurs': '1', 'maxOccurs': '1'}, 'anophelesParams': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._usage: OM191Usage | None = None
        self._initialInsecticide: OM195InitialInsecticide | None = None
        self._insecticideDecay: OM196InsecticideDecay | None = None
        self._anophelesParams: OM198AnophelesParams | None = None

    @property
    def usage(self) -> 'OM191Usage':
        """Initialize 'usage'."""
        if self._usage is None:
            self._usage = OM191Usage(xml_tree=self.xml_tree, parent=self)
        return self._usage

    @property
    def initialInsecticide(self) -> 'OM195InitialInsecticide':
        """Initialize 'initialInsecticide'."""
        if self._initialInsecticide is None:
            self._initialInsecticide = OM195InitialInsecticide(xml_tree=self.xml_tree, parent=self)
        return self._initialInsecticide

    @property
    def insecticideDecay(self) -> 'OM196InsecticideDecay':
        """Initialize 'insecticideDecay'."""
        if self._insecticideDecay is None:
            self._insecticideDecay = OM196InsecticideDecay(xml_tree=self.xml_tree, parent=self)
        return self._insecticideDecay

    @property
    def anophelesParams(self) -> 'OM198AnophelesParams':
        """Initialize 'anophelesParams'."""
        if self._anophelesParams is None:
            self._anophelesParams = OM198AnophelesParams(xml_tree=self.xml_tree, parent=self)
        return self._anophelesParams


class OM167GVI(Node):
    """Generated class for 'GVI'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='GVI', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Low-level description of intervention effects on vectors (i.e.
mosquitoes). Can be used to describe simple ITN or IRS
interventions (though more complex models are available for these
interventions) or other interventions such as mosquito repellant
or ivermectin.
Note that all actions of this intervention component will decay
according to a single decay function. If independant decay is
wanted, a separate component can be used for each action.

name:	Generic vector intervention"""
        self._metadata: dict = {'type': 'om:GVIDescription', 'children_metadata': {'ordered': 'sequence', 'order': ['usage', 'decay', 'anophelesParams']}, 'attributes': {}, 'children': {'usage': {'minOccurs': '0', 'maxOccurs': '1'}, 'decay': {'minOccurs': '1', 'maxOccurs': '1'}, 'anophelesParams': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._usage: OM191Usage | None = None
        self._decay: OM187Decay | None = None
        self._anophelesParams: OM198AnophelesParams | None = None

    @property
    def usage(self) -> 'OM191Usage':
        """Initialize 'usage'."""
        if self._usage is None:
            self._usage = OM191Usage(xml_tree=self.xml_tree, parent=self)
        return self._usage

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    @property
    def anophelesParams(self) -> 'OM198AnophelesParams':
        """Initialize 'anophelesParams'."""
        if self._anophelesParams is None:
            self._anophelesParams = OM198AnophelesParams(xml_tree=self.xml_tree, parent=self)
        return self._anophelesParams


class OM168RecruitmentOnly(Node):
    """Generated class for 'recruitmentOnly'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='recruitmentOnly', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Recruitment of a host into a sub-population.
All human-targeting intervention deployments recruit simulated
humans into a sub-population which can be used for the purposes
of cumulative deployment, deployment only to a sub-population and
defining a cohort. This pseudo-intervention can be used to define
a sub-population without also deploying some intervention.

name:	Recruitment only"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM169ClearImmunity(Node):
    """Generated class for 'clearImmunity'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='clearImmunity', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Removes all exposure-related immunitsy gained over time by hosts
without removing infections (or affecting the ability to gain
immunity through exposure).
Hypothetical, but potentially useful to simulate scenarios with
unprotected humans.

name:	Clear Immunity"""
        self._metadata: dict = {'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM170SubPopRemoval(Node):
    """Generated class for 'subPopRemoval'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='subPopRemoval', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Each human intervention component corresponds to a sub-population:
those who have received or are considered to be protected by the
intervention component. Humans automatically become members of this
sub-population when receiving an intervention component; this element
controls how humans are removed from the sub-population.
ITN attrition also removes humans from sub-populations.
Note that sub-populations do not directly correspond to an
intervention's effects: lack of effectiveness does not imply removal
from the sub-population (except as explicitly configured here) and
removal from the sub-population does not halt an intervention's
effects.
Sub-populations may be used to define a cohort, to restrict deployment
of other interventions and to use cumulative deployment mode. A sub-
population may or may not correspond (roughly) to humans protected by
some intervention.

name:	Remove from sub-population ..."""
        self._metadata: dict = {'minOccurs': '0', 'type': 'om:SubPopRemoval', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'onFirstBout': '', 'onFirstTreatment': '', 'onFirstInfection': '', 'afterYears': 'optional'}, 'children': {}}
        self.onFirstBout: OM170SubPopRemoval._OnFirstBout = self._OnFirstBout(xml_tree=xml_tree, parent=self)
        self.onFirstTreatment: OM170SubPopRemoval._OnFirstTreatment = self._OnFirstTreatment(xml_tree=xml_tree, parent=self)
        self.onFirstInfection: OM170SubPopRemoval._OnFirstInfection = self._OnFirstInfection(xml_tree=xml_tree, parent=self)
        self.afterYears: OM170SubPopRemoval._AfterYears = self._AfterYears(xml_tree=xml_tree, parent=self)

    class _OnFirstBout(AttributeNode):
        """Generated class for 'onFirstBout'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='onFirstBout', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If true, remove individuals from the sub-population at the start of
the first episode (start of a clinical bout) since they were
recruited into the sub-population. This is intended for cohort
studies which measure time to the first episode, using active
case detection.
Reports delayed due to health-system memory are forced out when this
occurs. Note that this can increase the number of uncomplicated cases
reported across the entire population; for this reason reports are
not forced on recruitment or most removal options.
This does not prevent re-recruitment in the case that recruitment
settings could conceivably recruit the same individual twice.

name:	Time to first episode only"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _OnFirstTreatment(AttributeNode):
        """Generated class for 'onFirstTreatment'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='onFirstTreatment', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If true, remove individuals from the sub-population when they first
seektreatment since they were recruited into the sub-population. This
is intended for cohort studies which measure the time to first
episode, using passive case detection.
Reports delayed due to health-system memory are forced out when this
occurs. Note that this can increase the number of uncomplicated cases
reported across the entire population; for this reason reports are
not forced on recruitment or most removal options.
This does not prevent re-recruitment in the case that recruitment
settings could conceivably recruit the same individual twice.

name:	Time to first treatment only"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _OnFirstInfection(AttributeNode):
        """Generated class for 'onFirstInfection'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='onFirstInfection', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If true, remove individuals from the sub-population at completion of
the first survey in which they present with a patent infection since
they were recruited into the sub-population. This intended for cohort
studies which measure time to the first infection, using active
case detection.
Reports delayed due to health-system memory are forced out when this
occurs. Note that this can increase the number of uncomplicated cases
reported across the entire population; for this reason reports are
not forced on recruitment or most removal options.
This does not prevent re-recruitment in the case that recruitment settings could
conceivably recruit the same individual twice.

name:	Time to first infection only"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _AfterYears(AttributeNode):
        """Generated class for 'afterYears'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='afterYears', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If given, membership to the sub-population of humans who have
received this intervention component expires after the given number of
years. Note that future deployments renew membership (e.g. if this
parameter is 4 years and the intervention is redeployed 3 years from
now, expiry happens after 7 years).
This provides a crude way of modelling a cohort protected by some
intervention. A few interventions provide more detailed ways of
modelling expiry of protection. In any case, "expiry of protection"
is an abstract concept and does not imply that all protection has
ceased, even in the simulator.
This may also be useful for cumulative deployment.
Minimum duration is zero, which implies the human is effectively
never a member of the sub-population; a duration of one timestep
implies the human is a member of the sub-population while any futher
interventions are deployed on the same time as this human becomes a
member and on the next update of the human (including transmission
and health system events) but not beyond that. If this attribute is
not given, the simulated human is a member until death or some other
option triggers removal.
Input is rounded to the nearest time step.

name:	Remove from sub-population after
units:	Years
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM171Positive(Node):
    """Generated class for 'positive'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='positive', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The list of components deployed to eligible humans.

name:	Component to be deployed"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'type': 'om:Component', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'id': 'required'}, 'children': {}}
        self.id: OM171Positive._Id = self._Id(xml_tree=xml_tree, parent=self)

    class _Id(AttributeNode):
        """Generated class for 'id'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='id', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The identifier (short name) of a component.

name:	Identifier"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM172Negative(Node):
    """Generated class for 'negative'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='negative', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The list of components deployed to eligible humans.

name:	Component to be deployed"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'type': 'om:Component', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'id': 'required'}, 'children': {}}
        self.id: OM172Negative._Id = self._Id(xml_tree=xml_tree, parent=self)

    class _Id(AttributeNode):
        """Generated class for 'id'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='id', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The identifier (short name) of a component.

name:	Identifier"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM173Description(Node):
    """Generated class for 'description'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='description', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': ['anopheles']}, 'attributes': {}, 'children': {'anopheles': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._anopheles: OM174Anopheles | None = None

    @property
    def anopheles(self) -> 'OM174Anopheles':
        """Initialize 'anopheles'."""
        if self._anopheles is None:
            self._anopheles = OM174Anopheles(xml_tree=self.xml_tree, parent=self)
        return self._anopheles


class OM174Anopheles(Node):
    """Generated class for 'anopheles'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='anopheles', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Descriptions of the effects of vector interventions with per-species effects.

units:	dimensionless
min:	0
max:	1
name:	Vector population intervention"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'type': 'om:VectorSpeciesIntervention', 'children_metadata': {'ordered': 'all', 'order': ['seekingDeathRateIncrease', 'probDeathOvipositing', 'emergenceReduction', 'probAdditionalDeathSugarFeeding']}, 'attributes': {'mosquito': 'required'}, 'children': {'seekingDeathRateIncrease': {'minOccurs': '0', 'maxOccurs': '1'}, 'probDeathOvipositing': {'minOccurs': '0', 'maxOccurs': '1'}, 'emergenceReduction': {'minOccurs': '0', 'maxOccurs': '1'}, 'probAdditionalDeathSugarFeeding': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self.mosquito: OM174Anopheles._Mosquito = self._Mosquito(xml_tree=xml_tree, parent=self)
        self._seekingDeathRateIncrease: OM227SeekingDeathRateIncrease | None = None
        self._probDeathOvipositing: OM229ProbDeathOvipositing | None = None
        self._emergenceReduction: OM231EmergenceReduction | None = None
        self._probAdditionalDeathSugarFeeding: OM233ProbAdditionalDeathSugarFeeding | None = None

    @property
    def seekingDeathRateIncrease(self) -> 'OM227SeekingDeathRateIncrease':
        """Initialize 'seekingDeathRateIncrease'."""
        if self._seekingDeathRateIncrease is None:
            self._seekingDeathRateIncrease = OM227SeekingDeathRateIncrease(xml_tree=self.xml_tree, parent=self)
        return self._seekingDeathRateIncrease

    @property
    def probDeathOvipositing(self) -> 'OM229ProbDeathOvipositing':
        """Initialize 'probDeathOvipositing'."""
        if self._probDeathOvipositing is None:
            self._probDeathOvipositing = OM229ProbDeathOvipositing(xml_tree=self.xml_tree, parent=self)
        return self._probDeathOvipositing

    @property
    def emergenceReduction(self) -> 'OM231EmergenceReduction':
        """Initialize 'emergenceReduction'."""
        if self._emergenceReduction is None:
            self._emergenceReduction = OM231EmergenceReduction(xml_tree=self.xml_tree, parent=self)
        return self._emergenceReduction

    @property
    def probAdditionalDeathSugarFeeding(self) -> 'OM233ProbAdditionalDeathSugarFeeding':
        """Initialize 'probAdditionalDeathSugarFeeding'."""
        if self._probAdditionalDeathSugarFeeding is None:
            self._probAdditionalDeathSugarFeeding = OM233ProbAdditionalDeathSugarFeeding(xml_tree=self.xml_tree, parent=self)
        return self._probAdditionalDeathSugarFeeding

    class _Mosquito(AttributeNode):
        """Generated class for 'mosquito'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mosquito', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of the species/subspecies/variant.

name:	Species/subspecies/variant name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM175Timed(Node):
    """Generated class for 'timed'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='timed', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
List of timed vector population intervention deployment

name:	Vector population intervention deployment"""
        self._metadata: dict = {'minOccurs': '0', 'type': 'om:TimedBaseList', 'children_metadata': {'ordered': 'sequence', 'order': ['deploy']}, 'attributes': {}, 'children': {'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self._deploy: OM180Deploy | None = None

    @property
    def deploy(self) -> 'OM180Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM180Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy


class OM176Description(Node):
    """Generated class for 'description'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='description', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Parameters associated with a vector trap intervention, per
mosquito species.

name:	Description"""
        self._metadata: dict = {'minOccurs': '1', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': ['relativeAvailability', 'decayOfAvailability']}, 'attributes': {'mosquito': 'required'}, 'children': {'relativeAvailability': {'minOccurs': '1', 'maxOccurs': '1'}, 'decayOfAvailability': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.mosquito: OM176Description._Mosquito = self._Mosquito(xml_tree=xml_tree, parent=self)
        self._relativeAvailability: OM177RelativeAvailability | None = None
        self._decayOfAvailability: OM178DecayOfAvailability | None = None

    @property
    def relativeAvailability(self) -> 'OM177RelativeAvailability':
        """Initialize 'relativeAvailability'."""
        if self._relativeAvailability is None:
            self._relativeAvailability = OM177RelativeAvailability(xml_tree=self.xml_tree, parent=self)
        return self._relativeAvailability

    @property
    def decayOfAvailability(self) -> 'OM178DecayOfAvailability':
        """Initialize 'decayOfAvailability'."""
        if self._decayOfAvailability is None:
            self._decayOfAvailability = OM178DecayOfAvailability(xml_tree=self.xml_tree, parent=self)
        return self._decayOfAvailability

    class _Mosquito(AttributeNode):
        """Generated class for 'mosquito'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mosquito', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of the species/subspecies/variant.

name:	Species/subspecies/variant name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM177RelativeAvailability(Node):
    """Generated class for 'relativeAvailability'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='relativeAvailability', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describes the availiability of a trap to a
host-seeking mosquito relative to an average
unprotected adult.
I.e. if this parameter is 2, then each trap will on
average attract twice as many mosquitoes as
unprotected adults.
This is the initial availability; it may decay
towards zero depending on the configured
decay function.

units:	Proportion
name:	Initial relative availability
min:	0
max:	inf"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM177RelativeAvailability._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM178DecayOfAvailability(Node):
    """Generated class for 'decayOfAvailability'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='decayOfAvailability', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Describes how availability decays to zero.
If decay heterogeneity/variance is used, there will be a
sample once-per-deployment (i.e. all traps of the same
deployment will be affected the same way). There is no
support for variances between traps (except in this crude
way, between deployments).

name:	Decay of availability
Type:
Specification of decay or survival of a parameter.

name:	Decay or survival of a parameter"""
        self._metadata: dict = {'type': 'om:DecayFunction', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'function': 'required', 'L': 'optional', 'k': '', 'CV': '', 'increasing': '', 'initialEfficacy': 'optional', 'rho': 'optional', 'halflife_short': 'optional', 'halflife_long': 'optional'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.function: OM178DecayOfAvailability._Function = self._Function(xml_tree=xml_tree, parent=self)
        self.L: OM178DecayOfAvailability._L = self._L(xml_tree=xml_tree, parent=self)
        self.k: OM178DecayOfAvailability._K = self._K(xml_tree=xml_tree, parent=self)
        self.CV: OM178DecayOfAvailability._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.increasing: OM178DecayOfAvailability._Increasing = self._Increasing(xml_tree=xml_tree, parent=self)
        self.initialEfficacy: OM178DecayOfAvailability._InitialEfficacy = self._InitialEfficacy(xml_tree=xml_tree, parent=self)
        self.rho: OM178DecayOfAvailability._Rho = self._Rho(xml_tree=xml_tree, parent=self)
        self.halflife_short: OM178DecayOfAvailability._Halflife_short = self._Halflife_short(xml_tree=xml_tree, parent=self)
        self.halflife_long: OM178DecayOfAvailability._Halflife_long = self._Halflife_long(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Function(AttributeNode):
        """Generated class for 'function'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='function', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Determines which decay function to use. Available decay functions,
for age t in years:
constant: 1
step: 1 for t less than L, otherwise 0
linear: 1 - t/L for t less than L, otherwise 0
exponential: exp( - t/L * log(2) )
weibull: exp( -(t/L)^k * log(2) )
hill: 1 / (1 + (t/L)^k)
smooth-compact: exp( k - k / (1 - (t/L)^2) ) for t less than L, otherwise 0

units:	None
min:	0
max:	1
name:	function"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['constant', 'step', 'linear', 'exponential', 'weibull', 'hill', 'smooth-compact', 'plus', 'minus', 'divides', 'multiplies']}, 'type': 'xs:string'}

    class _L(AttributeNode):
        """Generated class for 'L'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='L', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Time) scale parameter of distribution: this is either the age of
complete decay (smooth-compact, step and linear functions) or the age
at which the parameter has decayed to half its original value
(exponential, weibull and hill). Not used when function="constant"
(i.e. no decay).
This value can be specified in years, days or steps (e.g. 2y, 180d or
100t). When the unit is not specified years are assumed. The value is
used without rounding except when sampling an age of decay, when the
rounding happens as late as possible.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _K(AttributeNode):
        """Generated class for 'k'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='k', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Shape parameter of distribution. If not specified, default value of
1 is used. Meaning depends on function; not used in some cases.

min:	0
name:	k
units:	none"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1.0', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If CV is non-zero, heterogeneity of decay is introduced via a random
variable sampled from the log-normal distribution. This distribution is
parameterised with mean=1 and CV as given.
The effective age of decay is the real age multiplied by this variable
(for decay functions with a half-life, this is equivalent to dividing
the half-life by the variable).

min:	0
name:	Coefficient of Variation"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}

    class _Increasing(AttributeNode):
        """Generated class for 'increasing'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='increasing', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Boolean) If True, this tells OpenMalaria to use the complement of the
DecayFunction defined as 1-f(x). This is useful to model increasing
functions that will "decay" to 1. This only works if f(x) is contained
between 0 and 1.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _InitialEfficacy(AttributeNode):
        """Generated class for 'initialEfficacy'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initialEfficacy', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Efficacy between 0 and 1.
"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}

    class _Rho(AttributeNode):
        """Generated class for 'rho'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='rho', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Proportion between 0 and 1, proportion of the response that is short-lived."""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_short(AttributeNode):
        """Generated class for 'halflife_short'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_short', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of short lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_long(AttributeNode):
        """Generated class for 'halflife_long'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_long', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of long lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM179Timed(Node):
    """Generated class for 'timed'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='timed', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
List of timed vector trap intervention deployment

name:	Vector trap intervention deployment"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['deploy']}, 'attributes': {}, 'children': {'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self._deploy: OM180Deploy | None = None

    @property
    def deploy(self) -> 'OM180Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM180Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy


class OM180Deploy(Node):
    """Generated class for 'deploy'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='deploy', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'type': 'om:TimedBase', 'attributes': {'ratioToHumans': 'required', 'lifespan': 'required', 'time': 'required'}, 'children': {}}
        self.ratioToHumans: OM180Deploy._RatioToHumans = self._RatioToHumans(xml_tree=xml_tree, parent=self)
        self.lifespan: OM180Deploy._Lifespan = self._Lifespan(xml_tree=xml_tree, parent=self)
        self.time: OM180Deploy._Time = self._Time(xml_tree=xml_tree, parent=self)

    class _RatioToHumans(AttributeNode):
        """Generated class for 'ratioToHumans'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='ratioToHumans', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The number of traps deployed, by this
deployment, per adult human.
E.g. if there are currently 100 traps and 1000
humans, then a ratio of 0.1 will increase the
number of traps to 200.

name:	Ratio to humans
unit:	dimensionless
min:	0
max:	inf"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Lifespan(AttributeNode):
        """Generated class for 'lifespan'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='lifespan', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Life of the trap until replaced or removed, e.g.
"73t" or "1y". After this time period, these traps
will be removed from the simulation.
New deployments do not automatically remove old
traps. Existing traps cannot be refurbished in the
model. It may make sense to make the end-of-life
coincide with a new deployment.

name:	Lifespan
units:	Steps or Days or Years"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Time(AttributeNode):
        """Generated class for 'time'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='time', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Element:
Time at which this deployment occurs.
See doc on intervention period and on monitoring/startDate for
details of how times work. Can be specified in steps, days,
years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).

name:	Time
units:	User defined (defauls to steps)
min:	0
Type:
Time at which this deployment occurs.
See doc on intervention period and on monitoring/startDate for
details of how times work. Can be specified in steps, days,
years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).

name:	Time
units:	User defined (defauls to steps)
min:	0"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM181RestrictToSubPop(Node):
    """Generated class for 'restrictToSubPop'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='restrictToSubPop', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
If this element is specified, deployment is restricted to some
sub-population (specified via the "id" attribute); otherwise the
target population is the entire simulated population. Either way, other
deployment restrictions (age, time, number of vaccine doeses) still
apply.

name:	Restrict to sub-population"""
        self._metadata: dict = {'type': 'om:RestrictToSubPop', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'id': 'required', 'complement': ''}, 'children': {}}
        self.id: OM181RestrictToSubPop._Id = self._Id(xml_tree=xml_tree, parent=self)
        self.complement: OM181RestrictToSubPop._Complement = self._Complement(xml_tree=xml_tree, parent=self)

    class _Id(AttributeNode):
        """Generated class for 'id'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='id', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The identifier (short name) of the sub-population (i.e. the "id" of
some intervention component). Also see the "complement" attribute.

name:	Sub-population identifier"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Complement(AttributeNode):
        """Generated class for 'complement'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='complement', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If this is not specified or is false, deployment is restricted to the
sub-population of people protected by the intervention component
who's id is given. If complement is set to true, deployment is
instead restricted to the complement of that sub-population, i.e. to
those 
name:	Complement"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}


class OM182Deploy(Node):
    """Generated class for 'deploy'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='deploy', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'type': 'om:ContinuousDeployment', 'minOccurs': '1', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'targetAgeYrs': 'required', 'begin': 'optional', 'end': 'optional', 'coverage': 'required', 'vaccMinPrevDoses': 'optional', 'vaccMaxCumDoses': 'optional', 'minAvailability': 'optional', 'maxAvailability': 'optional'}, 'children': {}}
        self.targetAgeYrs: OM182Deploy._TargetAgeYrs = self._TargetAgeYrs(xml_tree=xml_tree, parent=self)
        self.begin: OM182Deploy._Begin = self._Begin(xml_tree=xml_tree, parent=self)
        self.end: OM182Deploy._End = self._End(xml_tree=xml_tree, parent=self)
        self.coverage: OM182Deploy._Coverage = self._Coverage(xml_tree=xml_tree, parent=self)
        self.vaccMinPrevDoses: OM182Deploy._VaccMinPrevDoses = self._VaccMinPrevDoses(xml_tree=xml_tree, parent=self)
        self.vaccMaxCumDoses: OM182Deploy._VaccMaxCumDoses = self._VaccMaxCumDoses(xml_tree=xml_tree, parent=self)
        self.minAvailability: OM182Deploy._MinAvailability = self._MinAvailability(xml_tree=xml_tree, parent=self)
        self.maxAvailability: OM182Deploy._MaxAvailability = self._MaxAvailability(xml_tree=xml_tree, parent=self)

    class _TargetAgeYrs(AttributeNode):
        """Generated class for 'targetAgeYrs'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='targetAgeYrs', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Target age of intervention.
Input is rounded to the nearest time step.

units:	Years
min:	0
max:	100
name:	Target age"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Begin(AttributeNode):
        """Generated class for 'begin'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='begin', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
First time at which this deployment is active. If not specified,
deployment starts at the beginning of the intervention period.
See doc on intervention period and on monitoring/startDate for
details of how times work. Can be specified in steps, days,
years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).

name:	First time active
units:	User defined (defauls to steps)"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _End(AttributeNode):
        """Generated class for 'end'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='end', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
End of the period during which the intervention is active (to be
exact, the first step of the intervention period at which the
item becomes inactive). If not specified, deployment never
ceases after starting during the simulation.
See doc on intervention period and on monitoring/startDate for
details of how times work. Can be specified in steps, days,
years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).

units:	User defined (defauls to steps)
name:	End step"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Coverage(AttributeNode):
        """Generated class for 'coverage'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='coverage', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Proportion of otherwise eligible individuals who will receive this
deployment.

units:	dimensionless
min:	0
max:	1
name:	Coverage"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _VaccMinPrevDoses(AttributeNode):
        """Generated class for 'vaccMinPrevDoses'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='vaccMinPrevDoses', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Applies to vaccines only: vaccine doses are only deployed by this
deployment if the previous number of doses (for the component
deployed) is at least this number.
For example, if this is the second deployment opportunity for this
vaccine and this value is 1, then this deployment cannot deploy the
vaccine to individuals who did not receive the first deployment.

name:	Vaccine min previous doses
units:	inoculations
min:	0"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _VaccMaxCumDoses(AttributeNode):
        """Generated class for 'vaccMaxCumDoses'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='vaccMaxCumDoses', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Applies to vaccines only: vaccine doses are only deployed by this
deployment if the previous number of doses (for the component
deployed) is less than this number.

name:	Vaccine max cumulative doses
units:	inoculations
min:	0"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _MinAvailability(AttributeNode):
        """Generated class for 'minAvailability'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='minAvailability', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Minimum ento availability percentile. 
This option is meant to be used with heterogeneity of availability, which can be specified in the entomology section. Without heterogenity (default), all hosts have the same availability and this option will have no effect.
The percentile must be an integer value between 0 and 100. Percentile 99th represents individuals who are more available than 99% of the population. Percentile 0 represents the least available individuals. 100 is equivalent for infinity.

units:	percent
min:	0
name:	Minimum ento availability"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _MaxAvailability(AttributeNode):
        """Generated class for 'maxAvailability'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='maxAvailability', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Maximum ento availability percentile. 
This option is meant to be used with heterogeneity of availability, which can be specified in the entomology section. Without heterogenity (default), all hosts have the same availability and this option will have no effect.
The percentile must be an integer value between 0 and 100. Percentile 99th represents individuals who are more available than 99% of the population. Percentile 0 represents the least available individuals. 100 is equivalent for infinity.
units:	percent
min:	0
name:	Maximum ento availability"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM183Deploy(Node):
    """Generated class for 'deploy'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='deploy', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'type': 'om:TimedBase', 'minOccurs': '1', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'time': 'required'}, 'children': {}}
        self.time: OM183Deploy._Time = self._Time(xml_tree=xml_tree, parent=self)

    class _Time(AttributeNode):
        """Generated class for 'time'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='time', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Time at which this deployment occurs.
See doc on intervention period and on monitoring/startDate for
details of how times work. Can be specified in steps, days,
years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).

name:	Time
units:	User defined (defauls to steps)
min:	0"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM184RestrictToSubPop(Node):
    """Generated class for 'restrictToSubPop'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='restrictToSubPop', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
If this element is specified, deployment is restricted to some
sub-population (specified via the "id" attribute); otherwise the
target population is the entire simulated population. Either way, other
deployment restrictions (age, time, number of vaccine doeses) still
apply.

name:	Restrict to sub-population"""
        self._metadata: dict = {'minOccurs': '0', 'type': 'om:RestrictToSubPop', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'id': 'required', 'complement': ''}, 'children': {}}
        self.id: OM184RestrictToSubPop._Id = self._Id(xml_tree=xml_tree, parent=self)
        self.complement: OM184RestrictToSubPop._Complement = self._Complement(xml_tree=xml_tree, parent=self)

    class _Id(AttributeNode):
        """Generated class for 'id'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='id', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The identifier (short name) of the sub-population (i.e. the "id" of
some intervention component). Also see the "complement" attribute.

name:	Sub-population identifier"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Complement(AttributeNode):
        """Generated class for 'complement'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='complement', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If this is not specified or is false, deployment is restricted to the
sub-population of people protected by the intervention component
who's id is given. If complement is set to true, deployment is
instead restricted to the complement of that sub-population, i.e. to
those 
name:	Complement"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}


class OM185CumulativeCoverage(Node):
    """Generated class for 'cumulativeCoverage'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='cumulativeCoverage', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
If this element is not specified, standard deployment occurs, where
a portion of the population as given by the coverage property of this
campaign is selected, and interventions are deployed to all of
these people (regardless of previous coverage).
If this attribute is specified, instead, the population is divided
into two sets: those who are a member of a certain sub-population and
those who are not (see "subPopRemoval" element).
If the proportion of people in the
first set is less than the desired coverage, then the proportion of
people from the second set needed to increase total coverage to the
desired coverage is calculated. This proportion is then used as the
probablity of selection from the second set into a third set of
people who then receive all interventions deployed by this campaign.
Note that selection is stochastic so the final coverage level may not
be exactly that desired. Note also that the component used when
selecting people need not actually be one of the components deployed
by this intervention, although that is the intended use case.

name:	Cumulative coverage"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'component': 'required'}, 'children': {}}
        self.component: OM185CumulativeCoverage._Component = self._Component(xml_tree=xml_tree, parent=self)

    class _Component(AttributeNode):
        """Generated class for 'component'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='component', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The identifier (short name) of the component used when
selecting people.

name:	Component identifier"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM186Deploy(Node):
    """Generated class for 'deploy'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='deploy', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'type': 'om:MassDeployment', 'minOccurs': '1', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'time': 'required', 'maxAge': 'optional', 'minAge': '', 'repeatStep': 'optional', 'repeatEnd': 'optional', 'coverage': 'required', 'vaccMinPrevDoses': 'optional', 'vaccMaxCumDoses': 'optional', 'minAvailability': 'optional', 'maxAvailability': 'optional'}, 'children': {}}
        self.time: OM186Deploy._Time = self._Time(xml_tree=xml_tree, parent=self)
        self.maxAge: OM186Deploy._MaxAge = self._MaxAge(xml_tree=xml_tree, parent=self)
        self.minAge: OM186Deploy._MinAge = self._MinAge(xml_tree=xml_tree, parent=self)
        self.repeatStep: OM186Deploy._RepeatStep = self._RepeatStep(xml_tree=xml_tree, parent=self)
        self.repeatEnd: OM186Deploy._RepeatEnd = self._RepeatEnd(xml_tree=xml_tree, parent=self)
        self.coverage: OM186Deploy._Coverage = self._Coverage(xml_tree=xml_tree, parent=self)
        self.vaccMinPrevDoses: OM186Deploy._VaccMinPrevDoses = self._VaccMinPrevDoses(xml_tree=xml_tree, parent=self)
        self.vaccMaxCumDoses: OM186Deploy._VaccMaxCumDoses = self._VaccMaxCumDoses(xml_tree=xml_tree, parent=self)
        self.minAvailability: OM186Deploy._MinAvailability = self._MinAvailability(xml_tree=xml_tree, parent=self)
        self.maxAvailability: OM186Deploy._MaxAvailability = self._MaxAvailability(xml_tree=xml_tree, parent=self)

    class _Time(AttributeNode):
        """Generated class for 'time'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='time', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Time at which this deployment occurs.
See doc on intervention period and on monitoring/startDate for
details of how times work. Can be specified in steps, days,
years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).

name:	Time
units:	User defined (defauls to steps)
min:	0"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _MaxAge(AttributeNode):
        """Generated class for 'maxAge'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='maxAge', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Maximum age of eligible individuals (defaults to no limit).
Input is rounded to the nearest time step.

units:	Years
min:	0
name:	Maximum age of eligible individuals"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _MinAge(AttributeNode):
        """Generated class for 'minAge'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='minAge', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Minimum age of eligible individuals (defaults to 0).
Input is rounded to the nearest time step.

units:	Years
min:	0
name:	Minimum age of eligible individuals"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}

    class _RepeatStep(AttributeNode):
        """Generated class for 'repeatStep'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='repeatStep', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
See repeatEnd's documentation.
name:	Step of repetition
units:	User defined"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _RepeatEnd(AttributeNode):
        """Generated class for 'repeatEnd'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='repeatEnd', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Either both repeatStep and repeatEnd should be present
or neither. If present, the deployment is repeated every
repeatStep timesteps (i.e. if t0 is the initial time
and x is repeatStep, depolyments are done at times t0,
t0+x, t0+2*x, ...), ending before repeatEnd
(final repetition is the one before repeatEnd).
Note that repeatEnd may be specified as a date but
repeatStep must be a duration (days, steps or years).

name:	End of repetition (exclusive)
units:	User defined"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Coverage(AttributeNode):
        """Generated class for 'coverage'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='coverage', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Proportion of otherwise eligible individuals who will receive this
deployment.

units:	dimensionless
min:	0
max:	1
name:	Coverage"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _VaccMinPrevDoses(AttributeNode):
        """Generated class for 'vaccMinPrevDoses'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='vaccMinPrevDoses', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Applies to vaccines only: vaccine doses are only deployed by this
deployment if the previous number of doses (for the component
deployed) is at least this number.
For example, if this is the second deployment opportunity for this
vaccine and this value is 1, then this deployment cannot deploy the
vaccine to individuals who did not receive the first deployment.

name:	Vaccine min previous doses
units:	inoculations
min:	0"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _VaccMaxCumDoses(AttributeNode):
        """Generated class for 'vaccMaxCumDoses'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='vaccMaxCumDoses', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Applies to vaccines only: vaccine doses are only deployed by this
deployment if the previous number of doses (for the component
deployed) is less than this number.

name:	Vaccine max cumulative doses
units:	inoculations
min:	0"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _MinAvailability(AttributeNode):
        """Generated class for 'minAvailability'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='minAvailability', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Minimum ento availability percentile. 
This option is meant to be used with heterogeneity of availability, which can be specified in the entomology section. Without heterogenity (default), all hosts have the same availability and this option will have no effect.
The percentile must be an integer value between 0 and 100. Percentile 99th represents individuals who are more available than 99% of the population. Percentile 0 represents the least available individuals. 100 is equivalent for infinity.

units:	percent
min:	0
name:	Minimum ento availability"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _MaxAvailability(AttributeNode):
        """Generated class for 'maxAvailability'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='maxAvailability', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Maximum ento availability percentile. 
This option is meant to be used with heterogeneity of availability, which can be specified in the entomology section. Without heterogenity (default), all hosts have the same availability and this option will have no effect.
The percentile must be an integer value between 0 and 100. Percentile 99th represents individuals who are more available than 99% of the population. Percentile 0 represents the least available individuals. 100 is equivalent for infinity.
units:	percent
min:	0
name:	Maximum ento availability"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM187Decay(Node):
    """Generated class for 'decay'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='decay', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Specification of decay of efficacy. Documentation: see DecayFunction type
or https://github.com/SwissTPH/openmalaria/wiki/ModelDecayFunctions

name:	Decay of effect
Type:
Specification of decay or survival of a parameter.

name:	Decay or survival of a parameter"""
        self._metadata: dict = {'type': 'om:DecayFunction', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'function': 'required', 'L': 'optional', 'k': '', 'CV': '', 'increasing': '', 'initialEfficacy': 'optional', 'rho': 'optional', 'halflife_short': 'optional', 'halflife_long': 'optional'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.function: OM187Decay._Function = self._Function(xml_tree=xml_tree, parent=self)
        self.L: OM187Decay._L = self._L(xml_tree=xml_tree, parent=self)
        self.k: OM187Decay._K = self._K(xml_tree=xml_tree, parent=self)
        self.CV: OM187Decay._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.increasing: OM187Decay._Increasing = self._Increasing(xml_tree=xml_tree, parent=self)
        self.initialEfficacy: OM187Decay._InitialEfficacy = self._InitialEfficacy(xml_tree=xml_tree, parent=self)
        self.rho: OM187Decay._Rho = self._Rho(xml_tree=xml_tree, parent=self)
        self.halflife_short: OM187Decay._Halflife_short = self._Halflife_short(xml_tree=xml_tree, parent=self)
        self.halflife_long: OM187Decay._Halflife_long = self._Halflife_long(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Function(AttributeNode):
        """Generated class for 'function'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='function', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Determines which decay function to use. Available decay functions,
for age t in years:
constant: 1
step: 1 for t less than L, otherwise 0
linear: 1 - t/L for t less than L, otherwise 0
exponential: exp( - t/L * log(2) )
weibull: exp( -(t/L)^k * log(2) )
hill: 1 / (1 + (t/L)^k)
smooth-compact: exp( k - k / (1 - (t/L)^2) ) for t less than L, otherwise 0

units:	None
min:	0
max:	1
name:	function"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['constant', 'step', 'linear', 'exponential', 'weibull', 'hill', 'smooth-compact', 'plus', 'minus', 'divides', 'multiplies']}, 'type': 'xs:string'}

    class _L(AttributeNode):
        """Generated class for 'L'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='L', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Time) scale parameter of distribution: this is either the age of
complete decay (smooth-compact, step and linear functions) or the age
at which the parameter has decayed to half its original value
(exponential, weibull and hill). Not used when function="constant"
(i.e. no decay).
This value can be specified in years, days or steps (e.g. 2y, 180d or
100t). When the unit is not specified years are assumed. The value is
used without rounding except when sampling an age of decay, when the
rounding happens as late as possible.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _K(AttributeNode):
        """Generated class for 'k'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='k', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Shape parameter of distribution. If not specified, default value of
1 is used. Meaning depends on function; not used in some cases.

min:	0
name:	k
units:	none"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1.0', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If CV is non-zero, heterogeneity of decay is introduced via a random
variable sampled from the log-normal distribution. This distribution is
parameterised with mean=1 and CV as given.
The effective age of decay is the real age multiplied by this variable
(for decay functions with a half-life, this is equivalent to dividing
the half-life by the variable).

min:	0
name:	Coefficient of Variation"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}

    class _Increasing(AttributeNode):
        """Generated class for 'increasing'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='increasing', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Boolean) If True, this tells OpenMalaria to use the complement of the
DecayFunction defined as 1-f(x). This is useful to model increasing
functions that will "decay" to 1. This only works if f(x) is contained
between 0 and 1.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _InitialEfficacy(AttributeNode):
        """Generated class for 'initialEfficacy'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initialEfficacy', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Efficacy between 0 and 1.
"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}

    class _Rho(AttributeNode):
        """Generated class for 'rho'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='rho', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Proportion between 0 and 1, proportion of the response that is short-lived."""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_short(AttributeNode):
        """Generated class for 'halflife_short'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_short', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of short lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_long(AttributeNode):
        """Generated class for 'halflife_long'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_long', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of long lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM188EfficacyB(Node):
    """Generated class for 'efficacyB'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='efficacyB', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Measure of variation in vaccine efficacy: efficacy is sampled from
a beta distribution with efficacyB its beta parameter and its alpha
parameter fixed such that the mean is that given by initialEfficacy.

units:	Positive real
min:	0.001
max:	1.00E+06
name:	Variance parameter for vaccine efficacy"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM188EfficacyB._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM189InitialEfficacy(Node):
    """Generated class for 'initialEfficacy'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='initialEfficacy', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Mean efficacy values before decay (see efficacyB and decay parameter
descriptions for sampling and decay). The i-th value in this list
is used for the efficacy of the vaccine after the i-th dose. Where
more doses are given than there are values in this list, the last
value is repeated.

units:	dimensionless
min:	0
max:	1
name:	Initial mean efficacy"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'minOccurs': '0', 'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM189InitialEfficacy._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM190Phenotype(Node):
    """Generated class for 'phenotype'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='phenotype', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Pharmaco-Dynamic parameters for some resistance phenotype.
To model resistance to this drug, describe multiple infection
phenotypes (with respect to these PD parameters) and list one
or more "restrict" elements for each phenotype.
Loci are specified elsewhere. Multiple loci may influence the
action of a single drug and each locus may influence multiple
drugs.

name:	PD parameters for some allele / resistance phenotype"""
        self._metadata: dict = {'type': 'om:VaccinePhenotype', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': ['restriction', 'initialEfficacy']}, 'attributes': {'name': 'optional'}, 'children': {'restriction': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'initialEfficacy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.name: OM190Phenotype._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._restriction: OM253Restriction | None = None
        self._initialEfficacy: OM189InitialEfficacy | None = None

    @property
    def restriction(self) -> 'OM253Restriction':
        """Initialize 'restriction'."""
        if self._restriction is None:
            self._restriction = OM253Restriction(xml_tree=self.xml_tree, parent=self)
        return self._restriction

    @property
    def initialEfficacy(self) -> 'OM189InitialEfficacy':
        """Initialize 'initialEfficacy'."""
        if self._initialEfficacy is None:
            self._initialEfficacy = OM189InitialEfficacy(xml_tree=self.xml_tree, parent=self)
        return self._initialEfficacy

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of the phenotype; for documentation use only.

name:	Name of phenotype"""
            self._metadata: dict = {'use': 'optional', 'type': 'xs:string', 'children_metadata': {'ordered': None, 'order': []}}


class OM191Usage(Node):
    """Generated class for 'usage'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='usage', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Usage of nets by humans, from 0 to 1.
At the moment this is constant across humans and deterministic:
relative attractiveness and survival factors are
base*(1-usage*propActing) + intervention_factor*usage*propActing.
See also "propActing" (proportion of bits for which net acts).

units:	dimensionless
min:	0
max:	1
name:	Proportion of time nets are used by humans"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM191Usage._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM192HoleRate(Node):
    """Generated class for 'holeRate'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='holeRate', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
The rate at which new holes are made in nets.
nHoles(t) = nHoles(t-1) + X where X~Pois(R/T) where T is the number
of time-steps per year. R is sampled from
log-normal: R ~ log N( log(mean)-sigma/2, sigma ) and is covariant
with ripRate and insecticideDecay. (To be exact, a single Gaussian
sample is taken, adjusted for each sigma then exponentiated.)

units:	Holes per annum
min:	0
name:	Rate at which holes are made
Type:
A parameter with optional log-normal heterogeneity.
The mean value must be specified. Optionally, a distribution ("distr")
and coefficient of variation ("CV") may be specified.

name:	Sampled value
Base Type:
A parameter with optional heterogeneity.
The mean cannot be specified (unless this type is extended).
Optionally, a distribution ("distr") and coefficient of variation ("CV") may be specified.

name:	Sampled value (log normal)"""
        self._metadata: dict = {'type': 'om:SampledValueLN', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'CV': 'optional', 'distr': 'optional', 'variance': 'optional'}, 'children': {}}
        self.mean: OM192HoleRate._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.CV: OM192HoleRate._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.distr: OM192HoleRate._Distr = self._Distr(xml_tree=xml_tree, parent=self)
        self.variance: OM192HoleRate._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) coefficient of variation.
This value must be specified when a (non-constant) distribution is used. 
Note: since version 46, variance can be used instead.
Note that specifying CV="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"lognormal": the parameter is sampled from a log-normal distribution.
Note that the "mean" and "CV" values are linear (arithmetic) properties
of the distribution and not log-space properties.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'lognormal', 'gamma']}, 'type': 'xs:string'}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The variance parameter of the distirbution.
This value can be specified when a (non-constant) distribution is used.
Note that specifying variance="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM193RipRate(Node):
    """Generated class for 'ripRate'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='ripRate', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Each existing hole has a probability of being ripped bigger according
to a Poisson process with this rate as (only) parameter.
New rips occur in a net at rate X~Pois(hR/T) where h is the number
of existing holes and T the number of time-steps per year. R is
sampled from log-normal: R ~ log N( log(mean)-sigma/2, sigma )
and is covariant with holeRate and insecticideDecay. (To be exact, a
single Gaussian sample is taken, adjusted for the each and sigma
then exponentiated.)

units:	Rips per existing hole per annum
min:	0
name:	Rate at which holes are enlarged
Type:
A parameter with optional log-normal heterogeneity.
The mean value must be specified. Optionally, a distribution ("distr")
and coefficient of variation ("CV") may be specified.

name:	Sampled value
Base Type:
A parameter with optional heterogeneity.
The mean cannot be specified (unless this type is extended).
Optionally, a distribution ("distr") and coefficient of variation ("CV") may be specified.

name:	Sampled value (log normal)"""
        self._metadata: dict = {'type': 'om:SampledValueLN', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'CV': 'optional', 'distr': 'optional', 'variance': 'optional'}, 'children': {}}
        self.mean: OM193RipRate._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.CV: OM193RipRate._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.distr: OM193RipRate._Distr = self._Distr(xml_tree=xml_tree, parent=self)
        self.variance: OM193RipRate._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) coefficient of variation.
This value must be specified when a (non-constant) distribution is used. 
Note: since version 46, variance can be used instead.
Note that specifying CV="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"lognormal": the parameter is sampled from a log-normal distribution.
Note that the "mean" and "CV" values are linear (arithmetic) properties
of the distribution and not log-space properties.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'lognormal', 'gamma']}, 'type': 'xs:string'}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The variance parameter of the distirbution.
This value can be specified when a (non-constant) distribution is used.
Note that specifying variance="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM194RipFactor(Node):
    """Generated class for 'ripFactor'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='ripFactor', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
This factor expresses how important rips are in increasing the hole.
The hole index of a net is h + Fx where h and x are the total numbers
of holes and rips respectively and F is the rip factor.

units:	none
min:	0
name:	Rip factor"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM194RipFactor._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM195InitialInsecticide(Node):
    """Generated class for 'initialInsecticide'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='initialInsecticide', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
The insecticide concentration of new nets is Gaussian distributed with
mean "mu" and a standard deviation "sigma". The standard deviation
should be small relative to the mean to avoid negative initial
concentration. Any negative values sampled are set to 0.

units:	mg/m
min:	0
name:	Initial insecticide
Type:
A parameter with optional heterogeneity.
Optionally, a distribution ("distr") and standard of deviation ("SD") may be specified.

name:	Sampled value (normal)"""
        self._metadata: dict = {'type': 'om:SampledValueN', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'SD': 'optional', 'distr': 'optional'}, 'children': {}}
        self.mean: OM195InitialInsecticide._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.SD: OM195InitialInsecticide._SD = self._SD(xml_tree=xml_tree, parent=self)
        self.distr: OM195InitialInsecticide._Distr = self._Distr(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _SD(AttributeNode):
        """Generated class for 'SD'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='SD', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The standard deviation of variates.

name:	standard deviation"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"normal": the parameter is sampled from a normal distribution.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'normal']}, 'type': 'xs:string'}


class OM196InsecticideDecay(Node):
    """Generated class for 'insecticideDecay'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='insecticideDecay', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Decay curve for insecticide content of nets. Documentation: see DecayFunction
type or https://github.com/SwissTPH/openmalaria/wiki/ModelDecayFunctions
The distribution of decay rates over nets is covariant with the
distribution of ripRate and holeRate over nets. This distribution is
generated by taking one sample per net from a Gaussian distribution
with mean 0 and standard deviation 1. For each variable, the sample
is multiplied by the respective sigma and a constant added such that,
once exponentiated, the mean of the variable over nets is 1. The
variable is then exponentiated and multiplied by the required mean
rate for the respective variable.

units:	none
name:	Decay of insecticide
Type:
Specification of decay or survival of a parameter.

name:	Decay or survival of a parameter"""
        self._metadata: dict = {'type': 'om:DecayFunction', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'function': 'required', 'L': 'optional', 'k': '', 'CV': '', 'increasing': '', 'initialEfficacy': 'optional', 'rho': 'optional', 'halflife_short': 'optional', 'halflife_long': 'optional'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.function: OM196InsecticideDecay._Function = self._Function(xml_tree=xml_tree, parent=self)
        self.L: OM196InsecticideDecay._L = self._L(xml_tree=xml_tree, parent=self)
        self.k: OM196InsecticideDecay._K = self._K(xml_tree=xml_tree, parent=self)
        self.CV: OM196InsecticideDecay._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.increasing: OM196InsecticideDecay._Increasing = self._Increasing(xml_tree=xml_tree, parent=self)
        self.initialEfficacy: OM196InsecticideDecay._InitialEfficacy = self._InitialEfficacy(xml_tree=xml_tree, parent=self)
        self.rho: OM196InsecticideDecay._Rho = self._Rho(xml_tree=xml_tree, parent=self)
        self.halflife_short: OM196InsecticideDecay._Halflife_short = self._Halflife_short(xml_tree=xml_tree, parent=self)
        self.halflife_long: OM196InsecticideDecay._Halflife_long = self._Halflife_long(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Function(AttributeNode):
        """Generated class for 'function'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='function', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Determines which decay function to use. Available decay functions,
for age t in years:
constant: 1
step: 1 for t less than L, otherwise 0
linear: 1 - t/L for t less than L, otherwise 0
exponential: exp( - t/L * log(2) )
weibull: exp( -(t/L)^k * log(2) )
hill: 1 / (1 + (t/L)^k)
smooth-compact: exp( k - k / (1 - (t/L)^2) ) for t less than L, otherwise 0

units:	None
min:	0
max:	1
name:	function"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['constant', 'step', 'linear', 'exponential', 'weibull', 'hill', 'smooth-compact', 'plus', 'minus', 'divides', 'multiplies']}, 'type': 'xs:string'}

    class _L(AttributeNode):
        """Generated class for 'L'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='L', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Time) scale parameter of distribution: this is either the age of
complete decay (smooth-compact, step and linear functions) or the age
at which the parameter has decayed to half its original value
(exponential, weibull and hill). Not used when function="constant"
(i.e. no decay).
This value can be specified in years, days or steps (e.g. 2y, 180d or
100t). When the unit is not specified years are assumed. The value is
used without rounding except when sampling an age of decay, when the
rounding happens as late as possible.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _K(AttributeNode):
        """Generated class for 'k'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='k', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Shape parameter of distribution. If not specified, default value of
1 is used. Meaning depends on function; not used in some cases.

min:	0
name:	k
units:	none"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1.0', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If CV is non-zero, heterogeneity of decay is introduced via a random
variable sampled from the log-normal distribution. This distribution is
parameterised with mean=1 and CV as given.
The effective age of decay is the real age multiplied by this variable
(for decay functions with a half-life, this is equivalent to dividing
the half-life by the variable).

min:	0
name:	Coefficient of Variation"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}

    class _Increasing(AttributeNode):
        """Generated class for 'increasing'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='increasing', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Boolean) If True, this tells OpenMalaria to use the complement of the
DecayFunction defined as 1-f(x). This is useful to model increasing
functions that will "decay" to 1. This only works if f(x) is contained
between 0 and 1.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _InitialEfficacy(AttributeNode):
        """Generated class for 'initialEfficacy'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initialEfficacy', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Efficacy between 0 and 1.
"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}

    class _Rho(AttributeNode):
        """Generated class for 'rho'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='rho', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Proportion between 0 and 1, proportion of the response that is short-lived."""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_short(AttributeNode):
        """Generated class for 'halflife_short'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_short', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of short lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_long(AttributeNode):
        """Generated class for 'halflife_long'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_long', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of long lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM197AttritionOfNets(Node):
    """Generated class for 'attritionOfNets'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='attritionOfNets', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Specifies the rate at which nets are disposed of over time.
Documentation: see DecayFunction type or
https://github.com/SwissTPH/openmalaria/wiki/ModelDecayFunctions
In the current model, nets are disposed of randomly (no correlation
with state of decay) such that the chance of each net surviving until
age t is the value of this decay function at time t. Equivalently
(where a large number of nets are distributed at the same time), the
proportion of nets remaining in use should match this decay function
over time.
Humans are removed from the intervention component's sub-population
on disposal (attrition) of their nets. Currently this event is not 
reported.

units:	dimensionless
name:	Attrition of nets
Type:
Specification of decay or survival of a parameter.

name:	Decay or survival of a parameter"""
        self._metadata: dict = {'type': 'om:DecayFunction', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'function': 'required', 'L': 'optional', 'k': '', 'CV': '', 'increasing': '', 'initialEfficacy': 'optional', 'rho': 'optional', 'halflife_short': 'optional', 'halflife_long': 'optional'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.function: OM197AttritionOfNets._Function = self._Function(xml_tree=xml_tree, parent=self)
        self.L: OM197AttritionOfNets._L = self._L(xml_tree=xml_tree, parent=self)
        self.k: OM197AttritionOfNets._K = self._K(xml_tree=xml_tree, parent=self)
        self.CV: OM197AttritionOfNets._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.increasing: OM197AttritionOfNets._Increasing = self._Increasing(xml_tree=xml_tree, parent=self)
        self.initialEfficacy: OM197AttritionOfNets._InitialEfficacy = self._InitialEfficacy(xml_tree=xml_tree, parent=self)
        self.rho: OM197AttritionOfNets._Rho = self._Rho(xml_tree=xml_tree, parent=self)
        self.halflife_short: OM197AttritionOfNets._Halflife_short = self._Halflife_short(xml_tree=xml_tree, parent=self)
        self.halflife_long: OM197AttritionOfNets._Halflife_long = self._Halflife_long(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Function(AttributeNode):
        """Generated class for 'function'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='function', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Determines which decay function to use. Available decay functions,
for age t in years:
constant: 1
step: 1 for t less than L, otherwise 0
linear: 1 - t/L for t less than L, otherwise 0
exponential: exp( - t/L * log(2) )
weibull: exp( -(t/L)^k * log(2) )
hill: 1 / (1 + (t/L)^k)
smooth-compact: exp( k - k / (1 - (t/L)^2) ) for t less than L, otherwise 0

units:	None
min:	0
max:	1
name:	function"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['constant', 'step', 'linear', 'exponential', 'weibull', 'hill', 'smooth-compact', 'plus', 'minus', 'divides', 'multiplies']}, 'type': 'xs:string'}

    class _L(AttributeNode):
        """Generated class for 'L'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='L', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Time) scale parameter of distribution: this is either the age of
complete decay (smooth-compact, step and linear functions) or the age
at which the parameter has decayed to half its original value
(exponential, weibull and hill). Not used when function="constant"
(i.e. no decay).
This value can be specified in years, days or steps (e.g. 2y, 180d or
100t). When the unit is not specified years are assumed. The value is
used without rounding except when sampling an age of decay, when the
rounding happens as late as possible.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _K(AttributeNode):
        """Generated class for 'k'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='k', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Shape parameter of distribution. If not specified, default value of
1 is used. Meaning depends on function; not used in some cases.

min:	0
name:	k
units:	none"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1.0', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If CV is non-zero, heterogeneity of decay is introduced via a random
variable sampled from the log-normal distribution. This distribution is
parameterised with mean=1 and CV as given.
The effective age of decay is the real age multiplied by this variable
(for decay functions with a half-life, this is equivalent to dividing
the half-life by the variable).

min:	0
name:	Coefficient of Variation"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}

    class _Increasing(AttributeNode):
        """Generated class for 'increasing'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='increasing', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Boolean) If True, this tells OpenMalaria to use the complement of the
DecayFunction defined as 1-f(x). This is useful to model increasing
functions that will "decay" to 1. This only works if f(x) is contained
between 0 and 1.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _InitialEfficacy(AttributeNode):
        """Generated class for 'initialEfficacy'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initialEfficacy', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Efficacy between 0 and 1.
"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}

    class _Rho(AttributeNode):
        """Generated class for 'rho'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='rho', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Proportion between 0 and 1, proportion of the response that is short-lived."""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_short(AttributeNode):
        """Generated class for 'halflife_short'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_short', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of short lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_long(AttributeNode):
        """Generated class for 'halflife_long'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_long', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of long lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM198AnophelesParams(Node):
    """Generated class for 'anophelesParams'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='anophelesParams', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': ['holeIndexMax', ['deterrency', 'twoStageDeterrency'], ['preprandialKillingEffect', 'preprandialKillingEffectLogit'], ['postprandialKillingEffect', 'postprandialKillingEffectLogit'], ['fecundityReduction', 'fecundityReductionLogit']]}, 'attributes': {'mosquito': 'required', 'propActive': ''}, 'children': {'holeIndexMax': {'minOccurs': '0', 'maxOccurs': '1'}, 'deterrency': {'minOccurs': '1', 'maxOccurs': '1'}, 'twoStageDeterrency': {'minOccurs': '1', 'maxOccurs': '1'}, 'preprandialKillingEffect': {'minOccurs': '1', 'maxOccurs': '1'}, 'preprandialKillingEffectLogit': {'minOccurs': '1', 'maxOccurs': '1'}, 'postprandialKillingEffect': {'minOccurs': '1', 'maxOccurs': '1'}, 'postprandialKillingEffectLogit': {'minOccurs': '1', 'maxOccurs': '1'}, 'fecundityReduction': {'minOccurs': '0', 'maxOccurs': '1'}, 'fecundityReductionLogit': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self.mosquito: OM198AnophelesParams._Mosquito = self._Mosquito(xml_tree=xml_tree, parent=self)
        self.propActive: OM198AnophelesParams._PropActive = self._PropActive(xml_tree=xml_tree, parent=self)
        self._holeIndexMax: OM199HoleIndexMax | None = None
        self._deterrency: OM200Deterrency | None = None
        self._twoStageDeterrency: OM201TwoStageDeterrency | None = None
        self._preprandialKillingEffect: OM206PreprandialKillingEffect | None = None
        self._preprandialKillingEffectLogit: OM207PreprandialKillingEffectLogit | None = None
        self._postprandialKillingEffect: OM208PostprandialKillingEffect | None = None
        self._postprandialKillingEffectLogit: OM209PostprandialKillingEffectLogit | None = None
        self._fecundityReduction: OM210FecundityReduction | None = None
        self._fecundityReductionLogit: OM211FecundityReductionLogit | None = None

    @property
    def holeIndexMax(self) -> 'OM199HoleIndexMax':
        """Initialize 'holeIndexMax'."""
        if self._holeIndexMax is None:
            self._holeIndexMax = OM199HoleIndexMax(xml_tree=self.xml_tree, parent=self)
        return self._holeIndexMax

    @property
    def deterrency(self) -> 'OM200Deterrency':
        """Initialize 'deterrency'."""
        if self._deterrency is None:
            self._deterrency = OM200Deterrency(xml_tree=self.xml_tree, parent=self)
        return self._deterrency

    @property
    def twoStageDeterrency(self) -> 'OM201TwoStageDeterrency':
        """Initialize 'twoStageDeterrency'."""
        if self._twoStageDeterrency is None:
            self._twoStageDeterrency = OM201TwoStageDeterrency(xml_tree=self.xml_tree, parent=self)
        return self._twoStageDeterrency

    @property
    def preprandialKillingEffect(self) -> 'OM206PreprandialKillingEffect':
        """Initialize 'preprandialKillingEffect'."""
        if self._preprandialKillingEffect is None:
            self._preprandialKillingEffect = OM206PreprandialKillingEffect(xml_tree=self.xml_tree, parent=self)
        return self._preprandialKillingEffect

    @property
    def preprandialKillingEffectLogit(self) -> 'OM207PreprandialKillingEffectLogit':
        """Initialize 'preprandialKillingEffectLogit'."""
        if self._preprandialKillingEffectLogit is None:
            self._preprandialKillingEffectLogit = OM207PreprandialKillingEffectLogit(xml_tree=self.xml_tree, parent=self)
        return self._preprandialKillingEffectLogit

    @property
    def postprandialKillingEffect(self) -> 'OM208PostprandialKillingEffect':
        """Initialize 'postprandialKillingEffect'."""
        if self._postprandialKillingEffect is None:
            self._postprandialKillingEffect = OM208PostprandialKillingEffect(xml_tree=self.xml_tree, parent=self)
        return self._postprandialKillingEffect

    @property
    def postprandialKillingEffectLogit(self) -> 'OM209PostprandialKillingEffectLogit':
        """Initialize 'postprandialKillingEffectLogit'."""
        if self._postprandialKillingEffectLogit is None:
            self._postprandialKillingEffectLogit = OM209PostprandialKillingEffectLogit(xml_tree=self.xml_tree, parent=self)
        return self._postprandialKillingEffectLogit

    @property
    def fecundityReduction(self) -> 'OM210FecundityReduction':
        """Initialize 'fecundityReduction'."""
        if self._fecundityReduction is None:
            self._fecundityReduction = OM210FecundityReduction(xml_tree=self.xml_tree, parent=self)
        return self._fecundityReduction

    @property
    def fecundityReductionLogit(self) -> 'OM211FecundityReductionLogit':
        """Initialize 'fecundityReductionLogit'."""
        if self._fecundityReductionLogit is None:
            self._fecundityReductionLogit = OM211FecundityReductionLogit(xml_tree=self.xml_tree, parent=self)
        return self._fecundityReductionLogit

    class _Mosquito(AttributeNode):
        """Generated class for 'mosquito'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mosquito', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of the affected anopheles-mosquito species.

name:	Mosquito species"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _PropActive(AttributeNode):
        """Generated class for 'propActive'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='propActive', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Deprecated: propActive can still be used but its value must be set to either 0 or 1.
Any other value will result in an error at initialization.
The proportion of bites, when nets are in use, for which the net
has any action whatsoever on the mosquito.
At the moment this is constant across humans and deterministic:
relative attractiveness and survival factors are
base*(1-usage*propActing) + intervention_factor*usage*propActing.
See also "usage" (proportion of time nets are used by humans).

units:	dimensionless
min:	0
max:	1
name:	Proportion of bites for which net acts"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}


class OM199HoleIndexMax(Node):
    """Generated class for 'holeIndexMax'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='holeIndexMax', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Used by logit attacking and killing models only, holeIndexMax
is a user defined maximum hole index (typically, the total surface area of a net).

units:	in same unit as holeIndex
name:	maximum of holed surface area that has an effect (comparable to no net)"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM199HoleIndexMax._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM200Deterrency(Node):
    """Generated class for 'deterrency'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='deterrency', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of net on attractiveness of humans to mosquitoes relative to
an unprotected adult human. Parameterisations should take into
account that mosquitoes do not always bite indoors.
Attractiveness of the human is multiplied by
exp(log(H)h + log(P)p + log(I)hp
where H, P and I are the hole, insecticide and interaction factors
respectively, h=exp(-holeIndexholeScalingFactor) and
p=1exp(-insecticideContentinsecticideScalingFactor).

units:	dimensionless
min:	0
max:	1
name:	Relative attractiveness"""
        self._metadata: dict = {'type': 'om:ITNDeterrency', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'holeFactor': 'required', 'interactionFactor': 'required', 'holeScalingFactor': 'required', 'insecticideFactor': 'required', 'insecticideScalingFactor': 'required'}, 'children': {}}
        self.holeFactor: OM200Deterrency._HoleFactor = self._HoleFactor(xml_tree=xml_tree, parent=self)
        self.interactionFactor: OM200Deterrency._InteractionFactor = self._InteractionFactor(xml_tree=xml_tree, parent=self)
        self.holeScalingFactor: OM200Deterrency._HoleScalingFactor = self._HoleScalingFactor(xml_tree=xml_tree, parent=self)
        self.insecticideFactor: OM200Deterrency._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)
        self.insecticideScalingFactor: OM200Deterrency._InsecticideScalingFactor = self._InsecticideScalingFactor(xml_tree=xml_tree, parent=self)

    class _HoleFactor(AttributeNode):
        """Generated class for 'holeFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='holeFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Hole factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InteractionFactor(AttributeNode):
        """Generated class for 'interactionFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interactionFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
holeFactor + insecticideFactor + interactionFactor must not be greater
than 1, and is expected to be at least 0. A negative value is not
necessarily invalid, but allows nets to increase transmission.

units:	none
name:	Interaction factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _HoleScalingFactor(AttributeNode):
        """Generated class for 'holeScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='holeScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Hole scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Insecticide factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideScalingFactor(AttributeNode):
        """Generated class for 'insecticideScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Insecticide scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM201TwoStageDeterrency(Node):
    """Generated class for 'twoStageDeterrency'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='twoStageDeterrency', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of net on attractiveness of humans to mosquitoes relative to
an unprotected adult human. Parameterisations should take into
account that mosquitoes do not always bite indoors.
This deterrency model multiplies human attractiveness by
pEntpAtt.

units:	dimensionless
name:	Relative attractiveness"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': [['entering', 'enteringLogit'], ['attacking', 'attackingLogit']]}, 'attributes': {}, 'children': {'entering': {'minOccurs': '1', 'maxOccurs': '1'}, 'enteringLogit': {'minOccurs': '1', 'maxOccurs': '1'}, 'attacking': {'minOccurs': '1', 'maxOccurs': '1'}, 'attackingLogit': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._entering: OM202Entering | None = None
        self._enteringLogit: OM203EnteringLogit | None = None
        self._attacking: OM204Attacking | None = None
        self._attackingLogit: OM205AttackingLogit | None = None

    @property
    def entering(self) -> 'OM202Entering':
        """Initialize 'entering'."""
        if self._entering is None:
            self._entering = OM202Entering(xml_tree=self.xml_tree, parent=self)
        return self._entering

    @property
    def enteringLogit(self) -> 'OM203EnteringLogit':
        """Initialize 'enteringLogit'."""
        if self._enteringLogit is None:
            self._enteringLogit = OM203EnteringLogit(xml_tree=self.xml_tree, parent=self)
        return self._enteringLogit

    @property
    def attacking(self) -> 'OM204Attacking':
        """Initialize 'attacking'."""
        if self._attacking is None:
            self._attacking = OM204Attacking(xml_tree=self.xml_tree, parent=self)
        return self._attacking

    @property
    def attackingLogit(self) -> 'OM205AttackingLogit':
        """Initialize 'attackingLogit'."""
        if self._attackingLogit is None:
            self._attackingLogit = OM205AttackingLogit(xml_tree=self.xml_tree, parent=self)
        return self._attackingLogit


class OM202Entering(Node):
    """Generated class for 'entering'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='entering', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
pEnt represents the relative probability of entering due to
ITNs: pEnt = exp(log(P)p) where P is the insecticide
factor and 
p=1exp(-insecticideContentinsecticideScalingFactor).

units:	dimensionless
name:	Deterrency:	 entering"""
        self._metadata: dict = {'type': 'om:IRSDeterrency', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'insecticideFactor': 'required', 'insecticideScalingFactor': 'required'}, 'children': {}}
        self.insecticideFactor: OM202Entering._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)
        self.insecticideScalingFactor: OM202Entering._InsecticideScalingFactor = self._InsecticideScalingFactor(xml_tree=xml_tree, parent=self)

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Insecticide factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideScalingFactor(AttributeNode):
        """Generated class for 'insecticideScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Insecticide scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM203EnteringLogit(Node):
    """Generated class for 'enteringLogit'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='enteringLogit', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
pEnt represents the relative probability of entering due to insecticide
in the hut:
pEnt = exp(logit.pEnt) / (exp(logit.pEnt) + 1)
logit.pEnt = B + P * p
where B is the basefactor (without net); P is insecticide factor, and
p = log(insecticideContent+1).
Without a net, probability of entering a house is
pEnt0 = exp(logit.pEnt0) / (exp(logit.pEnt0) + 1)
logit.pEnt0 = B
Entering of mosquitoes is adjusted via multiplication by pEnt / pEnt0.
To keep this in the range [0,1], we (normally) require that
pEnt  pEnt0
and thus P  0 and give a warning if this is not fulfilled.

units:	dimensionless
name:	Deterrency:	 entering (logit model)"""
        self._metadata: dict = {'type': 'om:ITNEnteringDeterrencyLogit', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'baseFactor': 'required', 'insecticideFactor': 'required'}, 'children': {}}
        self.baseFactor: OM203EnteringLogit._BaseFactor = self._BaseFactor(xml_tree=xml_tree, parent=self)
        self.insecticideFactor: OM203EnteringLogit._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)

    class _BaseFactor(AttributeNode):
        """Generated class for 'baseFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='baseFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
See parent element documentation

units:	none
name:	Base factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
See parent element documentation

units:	none
name:	Insecticide factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM204Attacking(Node):
    """Generated class for 'attacking'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='attacking', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
pAtt represents the relative probability of attacking a human after
entering a house due to ITNs (i.e. of feeding/dying vs. flying off):
pAtt = B + Hh + Pp + Ihp
where B is the base (without net) probability; H, P and I are the hole,
insecticide and interaction factors respectively,
h=exp(-holeIndex  holeScalingFactor)
and
p=1 - exp(-insecticideContent  insecticideScalingFactor).

units:	dimensionless
name:	Deterrency:	 attacking"""
        self._metadata: dict = {'type': 'om:ITNKillingEffect', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'baseFactor': 'required', 'holeFactor': 'required', 'interactionFactor': 'required', 'holeScalingFactor': 'required', 'insecticideFactor': 'required', 'insecticideScalingFactor': 'required'}, 'children': {}}
        self.baseFactor: OM204Attacking._BaseFactor = self._BaseFactor(xml_tree=xml_tree, parent=self)
        self.holeFactor: OM204Attacking._HoleFactor = self._HoleFactor(xml_tree=xml_tree, parent=self)
        self.interactionFactor: OM204Attacking._InteractionFactor = self._InteractionFactor(xml_tree=xml_tree, parent=self)
        self.holeScalingFactor: OM204Attacking._HoleScalingFactor = self._HoleScalingFactor(xml_tree=xml_tree, parent=self)
        self.insecticideFactor: OM204Attacking._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)
        self.insecticideScalingFactor: OM204Attacking._InsecticideScalingFactor = self._InsecticideScalingFactor(xml_tree=xml_tree, parent=self)

    class _BaseFactor(AttributeNode):
        """Generated class for 'baseFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='baseFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
name:	Probability of mosquito death without intervention"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _HoleFactor(AttributeNode):
        """Generated class for 'holeFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='holeFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Hole factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InteractionFactor(AttributeNode):
        """Generated class for 'interactionFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interactionFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
holeFactor + insecticideFactor + interactionFactor must not be greater
than 1, and is expected to be at least 0. A negative value is not
necessarily invalid, but allows nets to increase transmission.

units:	none
name:	Interaction factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _HoleScalingFactor(AttributeNode):
        """Generated class for 'holeScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='holeScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Hole scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Insecticide factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideScalingFactor(AttributeNode):
        """Generated class for 'insecticideScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Insecticide scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM205AttackingLogit(Node):
    """Generated class for 'attackingLogit'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='attackingLogit', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
pAtt represents the relative probability of attacking a human
after entering a house due to ITNs (i.e. of feeding/dying vs.
flying off):
pAtt = exp(logit.pAtt) / (exp(logit.pAtt) + 1)
logit.pAtt = B + Hmin(h, hMax) + Pp + Imin(h, hMax)p
where B is the base factor (without net); H, P and
I are the hole, insecticide and interaction factors
respectively, and:
h = log(holeIndex + 1)
p = log(insecticideContent + 1)
Without a net, probability of attacking a human
after entering a house is
pAtt0 = exp(logit.pAtt0) / (exp(logit.pAtt0) + 1)
logit.pAtt0 = B + HhMax
where hMax=log(holeIndexMax + 1) and holeIndexMax is a user defined
maximum hole index (typically, the total surface area of a net).
Attacking of mosquitoes is adjusted via multiplication by pAtt / pAtt0.
This may be larger and smaller than 1 (but will not be negative).
By definition (through the logit transformation) pAtt0 > 0.  

units:	dimensionless
name:	Deterrency:	 attacking (logit model)"""
        self._metadata: dict = {'type': 'om:ITNEffectLogit', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'baseFactor': 'required', 'insecticideFactor': 'required', 'holeFactor': 'required', 'interactionFactor': 'required'}, 'children': {}}
        self.baseFactor: OM205AttackingLogit._BaseFactor = self._BaseFactor(xml_tree=xml_tree, parent=self)
        self.insecticideFactor: OM205AttackingLogit._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)
        self.holeFactor: OM205AttackingLogit._HoleFactor = self._HoleFactor(xml_tree=xml_tree, parent=self)
        self.interactionFactor: OM205AttackingLogit._InteractionFactor = self._InteractionFactor(xml_tree=xml_tree, parent=self)

    class _BaseFactor(AttributeNode):
        """Generated class for 'baseFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='baseFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Logit of the probability (e.g. of death, of entry, of attacking) without intervention.

units:	dimensionless
name:	Base factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Coefficient of log(insecticide content+1) in a generalized linear model with logit link
function.

units:	none
name:	Insecticide factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _HoleFactor(AttributeNode):
        """Generated class for 'holeFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='holeFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Coefficient of log(total holed surface area (in cm2) +1) in a generalized linear model
with logit link function.

units:	none
name:	Hole factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InteractionFactor(AttributeNode):
        """Generated class for 'interactionFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interactionFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Coefficient of the interaction term of log(total holed surface area (in cm2) +1) with
log(insecticide content+1) in a generalized linear model with logit link function.

units:	none
name:	Interaction factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM206PreprandialKillingEffect(Node):
    """Generated class for 'preprandialKillingEffect'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='preprandialKillingEffect', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of net on survival mosquitoes as they seek to bite a human
after choosing that human, relative to the same person not
sleeping under a net. Parameterisations should take into
account that mosquitoes do not always bite indoors.
Killing proportion is calculated as K = B + Hh + Pp + Ihp
where B is the base (without net) probability of death,
H, P and I are the hole, insecticide and interaction factors
respectively, h=exp(-holeIndexholeScalingFactor) and
p=1exp(-insecticideContentinsecticideScalingFactor).
Survival of mosquitoes is adjusted via multiplication by (1K) / (1B).
To keep this in the range [0,1], we require that B+H  1, B+P  1,
B+H+P+I  1, H  0, P  0 and H+P+I  0.

units:	dimensionless
min:	0
max:	1
name:	Pre-prandial killing effect"""
        self._metadata: dict = {'type': 'om:ITNKillingEffect', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'baseFactor': 'required', 'holeFactor': 'required', 'interactionFactor': 'required', 'holeScalingFactor': 'required', 'insecticideFactor': 'required', 'insecticideScalingFactor': 'required'}, 'children': {}}
        self.baseFactor: OM206PreprandialKillingEffect._BaseFactor = self._BaseFactor(xml_tree=xml_tree, parent=self)
        self.holeFactor: OM206PreprandialKillingEffect._HoleFactor = self._HoleFactor(xml_tree=xml_tree, parent=self)
        self.interactionFactor: OM206PreprandialKillingEffect._InteractionFactor = self._InteractionFactor(xml_tree=xml_tree, parent=self)
        self.holeScalingFactor: OM206PreprandialKillingEffect._HoleScalingFactor = self._HoleScalingFactor(xml_tree=xml_tree, parent=self)
        self.insecticideFactor: OM206PreprandialKillingEffect._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)
        self.insecticideScalingFactor: OM206PreprandialKillingEffect._InsecticideScalingFactor = self._InsecticideScalingFactor(xml_tree=xml_tree, parent=self)

    class _BaseFactor(AttributeNode):
        """Generated class for 'baseFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='baseFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
name:	Probability of mosquito death without intervention"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _HoleFactor(AttributeNode):
        """Generated class for 'holeFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='holeFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Hole factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InteractionFactor(AttributeNode):
        """Generated class for 'interactionFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interactionFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
holeFactor + insecticideFactor + interactionFactor must not be greater
than 1, and is expected to be at least 0. A negative value is not
necessarily invalid, but allows nets to increase transmission.

units:	none
name:	Interaction factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _HoleScalingFactor(AttributeNode):
        """Generated class for 'holeScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='holeScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Hole scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Insecticide factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideScalingFactor(AttributeNode):
        """Generated class for 'insecticideScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Insecticide scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM207PreprandialKillingEffectLogit(Node):
    """Generated class for 'preprandialKillingEffectLogit'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='preprandialKillingEffectLogit', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of net on survival mosquitoes as they seek to bite a human
after choosing that human, relative to the same person not
sleeping under a net.                 
Killing proportion is calculated as 
K=exp(logit.K)/(exp(logit.K)+1)
logit.K = B + Hmin(h,hMax) + Pp + Imin(h,hMax)p
where B is the basefactor (without net),
H, P and I are the hole, insecticide and interaction factors
respectively, h=log(holeIndex+1) and
p=log(insecticideContent+1).
Without a net, the killing proportion
K0=exp(logit.K0)/(exp(logit.K0)+1)
logit.K0 = B + HhMax
where hMax=log(holeIndexMax+1) and holeIndexMax is a user defined maximum hole index (typically, the total surface area of a net).
Survival of mosquitoes is adjusted via multiplication by (1K) / (1K0).
To keep this in the range [0,1], we require that K  K0. We enforce that P  0 (It would not make sense biologically if P were negative) and P+I*hMax  0 and H  0 and holeIndex  holeIndexMax and give a warning if these conditions are not fulfilled.

units:	dimensionless
min:	0
max:	1
name:	Pre-prandial killing effect (logit)"""
        self._metadata: dict = {'type': 'om:ITNEffectLogit', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'baseFactor': 'required', 'insecticideFactor': 'required', 'holeFactor': 'required', 'interactionFactor': 'required'}, 'children': {}}
        self.baseFactor: OM207PreprandialKillingEffectLogit._BaseFactor = self._BaseFactor(xml_tree=xml_tree, parent=self)
        self.insecticideFactor: OM207PreprandialKillingEffectLogit._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)
        self.holeFactor: OM207PreprandialKillingEffectLogit._HoleFactor = self._HoleFactor(xml_tree=xml_tree, parent=self)
        self.interactionFactor: OM207PreprandialKillingEffectLogit._InteractionFactor = self._InteractionFactor(xml_tree=xml_tree, parent=self)

    class _BaseFactor(AttributeNode):
        """Generated class for 'baseFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='baseFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Logit of the probability (e.g. of death, of entry, of attacking) without intervention.

units:	dimensionless
name:	Base factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Coefficient of log(insecticide content+1) in a generalized linear model with logit link
function.

units:	none
name:	Insecticide factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _HoleFactor(AttributeNode):
        """Generated class for 'holeFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='holeFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Coefficient of log(total holed surface area (in cm2) +1) in a generalized linear model
with logit link function.

units:	none
name:	Hole factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InteractionFactor(AttributeNode):
        """Generated class for 'interactionFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interactionFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Coefficient of the interaction term of log(total holed surface area (in cm2) +1) with
log(insecticide content+1) in a generalized linear model with logit link function.

units:	none
name:	Interaction factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM208PostprandialKillingEffect(Node):
    """Generated class for 'postprandialKillingEffect'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='postprandialKillingEffect', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of net on survival mosquitoes as they seek to escape from
a human host and rest after a blood meal, relative to the same
person not sleeping under a net. Parameterisations should take
into account that mosquitoes do not always bite indoors.
Killing proportion is calculated as K = B + Hh + Pp + Ihp
where B is the base (without net) probability of death,
H, P and I are the hole, insecticide and interaction factors
respectively, h=exp(-holeIndexholeScalingFactor) and
p=1exp(-insecticideContentinsecticideScalingFactor).
Survival of mosquitoes is adjusted via multiplication by (1K) / (1B).
To keep this in the range [0,1], we require that B+H  1, B+P  1,
B+H+P+I  1, H  0, P  0 and H+P+I  0.

units:	dimensionless
min:	0
max:	1
name:	Post-prandial killing effect"""
        self._metadata: dict = {'type': 'om:ITNKillingEffect', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'baseFactor': 'required', 'holeFactor': 'required', 'interactionFactor': 'required', 'holeScalingFactor': 'required', 'insecticideFactor': 'required', 'insecticideScalingFactor': 'required'}, 'children': {}}
        self.baseFactor: OM208PostprandialKillingEffect._BaseFactor = self._BaseFactor(xml_tree=xml_tree, parent=self)
        self.holeFactor: OM208PostprandialKillingEffect._HoleFactor = self._HoleFactor(xml_tree=xml_tree, parent=self)
        self.interactionFactor: OM208PostprandialKillingEffect._InteractionFactor = self._InteractionFactor(xml_tree=xml_tree, parent=self)
        self.holeScalingFactor: OM208PostprandialKillingEffect._HoleScalingFactor = self._HoleScalingFactor(xml_tree=xml_tree, parent=self)
        self.insecticideFactor: OM208PostprandialKillingEffect._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)
        self.insecticideScalingFactor: OM208PostprandialKillingEffect._InsecticideScalingFactor = self._InsecticideScalingFactor(xml_tree=xml_tree, parent=self)

    class _BaseFactor(AttributeNode):
        """Generated class for 'baseFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='baseFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
name:	Probability of mosquito death without intervention"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _HoleFactor(AttributeNode):
        """Generated class for 'holeFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='holeFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Hole factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InteractionFactor(AttributeNode):
        """Generated class for 'interactionFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interactionFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
holeFactor + insecticideFactor + interactionFactor must not be greater
than 1, and is expected to be at least 0. A negative value is not
necessarily invalid, but allows nets to increase transmission.

units:	none
name:	Interaction factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _HoleScalingFactor(AttributeNode):
        """Generated class for 'holeScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='holeScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Hole scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Insecticide factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideScalingFactor(AttributeNode):
        """Generated class for 'insecticideScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Insecticide scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM209PostprandialKillingEffectLogit(Node):
    """Generated class for 'postprandialKillingEffectLogit'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='postprandialKillingEffectLogit', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of net on survival mosquitoes as they seek to escape from
a human host and rest after a blood meal, relative to the same
person not sleeping under a net.
Killing proportion is calculated as 
K=exp(logit.K)/(exp(logit.K)+1)
logit.K = B + Hmin(h,hMax) + Pp + Imin(h,hMax)p
where B is the basefactor (without net),
H, P and I are the hole, insecticide and interaction factors
respectively, h=log(holeIndex+1) and
p=log(insecticideContent+1).
Without a net, the killing proportion
K0=exp(logit.K0)/(exp(logit.K0)+1)
logit.K0 = B + HhMax
where hMax=log(holeIndexMax+1) and holeIndexMax is a user defined maximum hole index (typically, the total surface area of a net).
Survival of mosquitoes is adjusted via multiplication by (1K) / (1K0).
To keep this in the range [0,1], we require that K  K0. We enforce that P  0 (It would not make sense biologically if P were negative) and P+I*hMax  0 and H  0 and holeIndex  holeIndexMax and give a warning if these conditions are not fulfilled.

units:	dimensionless
min:	0
max:	1
name:	Post-prandial killing effect (logit)"""
        self._metadata: dict = {'type': 'om:ITNEffectLogit', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'baseFactor': 'required', 'insecticideFactor': 'required', 'holeFactor': 'required', 'interactionFactor': 'required'}, 'children': {}}
        self.baseFactor: OM209PostprandialKillingEffectLogit._BaseFactor = self._BaseFactor(xml_tree=xml_tree, parent=self)
        self.insecticideFactor: OM209PostprandialKillingEffectLogit._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)
        self.holeFactor: OM209PostprandialKillingEffectLogit._HoleFactor = self._HoleFactor(xml_tree=xml_tree, parent=self)
        self.interactionFactor: OM209PostprandialKillingEffectLogit._InteractionFactor = self._InteractionFactor(xml_tree=xml_tree, parent=self)

    class _BaseFactor(AttributeNode):
        """Generated class for 'baseFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='baseFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Logit of the probability (e.g. of death, of entry, of attacking) without intervention.

units:	dimensionless
name:	Base factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Coefficient of log(insecticide content+1) in a generalized linear model with logit link
function.

units:	none
name:	Insecticide factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _HoleFactor(AttributeNode):
        """Generated class for 'holeFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='holeFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Coefficient of log(total holed surface area (in cm2) +1) in a generalized linear model
with logit link function.

units:	none
name:	Hole factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InteractionFactor(AttributeNode):
        """Generated class for 'interactionFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interactionFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Coefficient of the interaction term of log(total holed surface area (in cm2) +1) with
log(insecticide content+1) in a generalized linear model with logit link function.

units:	none
name:	Interaction factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM210FecundityReduction(Node):
    """Generated class for 'fecundityReduction'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='fecundityReduction', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of net on fertility of mosquitoes who survive feeding
on a protected human, relative to an unprotected human.
Fertility (number of eggs laid) is multiplied by (1-K) / (1-B),
similar to killing effects. This is not allowed to be greater than 1.

name:	Fecundity reduction"""
        self._metadata: dict = {'type': 'om:ITNKillingEffect', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'baseFactor': 'required', 'holeFactor': 'required', 'interactionFactor': 'required', 'holeScalingFactor': 'required', 'insecticideFactor': 'required', 'insecticideScalingFactor': 'required'}, 'children': {}}
        self.baseFactor: OM210FecundityReduction._BaseFactor = self._BaseFactor(xml_tree=xml_tree, parent=self)
        self.holeFactor: OM210FecundityReduction._HoleFactor = self._HoleFactor(xml_tree=xml_tree, parent=self)
        self.interactionFactor: OM210FecundityReduction._InteractionFactor = self._InteractionFactor(xml_tree=xml_tree, parent=self)
        self.holeScalingFactor: OM210FecundityReduction._HoleScalingFactor = self._HoleScalingFactor(xml_tree=xml_tree, parent=self)
        self.insecticideFactor: OM210FecundityReduction._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)
        self.insecticideScalingFactor: OM210FecundityReduction._InsecticideScalingFactor = self._InsecticideScalingFactor(xml_tree=xml_tree, parent=self)

    class _BaseFactor(AttributeNode):
        """Generated class for 'baseFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='baseFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
name:	Probability of mosquito death without intervention"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _HoleFactor(AttributeNode):
        """Generated class for 'holeFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='holeFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Hole factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InteractionFactor(AttributeNode):
        """Generated class for 'interactionFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interactionFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
holeFactor + insecticideFactor + interactionFactor must not be greater
than 1, and is expected to be at least 0. A negative value is not
necessarily invalid, but allows nets to increase transmission.

units:	none
name:	Interaction factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _HoleScalingFactor(AttributeNode):
        """Generated class for 'holeScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='holeScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Hole scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Insecticide factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideScalingFactor(AttributeNode):
        """Generated class for 'insecticideScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Insecticide scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM211FecundityReductionLogit(Node):
    """Generated class for 'fecundityReductionLogit'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='fecundityReductionLogit', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of net on fertility of mosquitoes who survive feeding
on a protected human, relative to an unprotected human.
Fertility (number of eggs laid) is multiplied by (1-K) / (1-K0),
similar to killing effects. This is not allowed to be greater than 1.

name:	Fecundity reduction (logit)"""
        self._metadata: dict = {'type': 'om:ITNEffectLogit', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'baseFactor': 'required', 'insecticideFactor': 'required', 'holeFactor': 'required', 'interactionFactor': 'required'}, 'children': {}}
        self.baseFactor: OM211FecundityReductionLogit._BaseFactor = self._BaseFactor(xml_tree=xml_tree, parent=self)
        self.insecticideFactor: OM211FecundityReductionLogit._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)
        self.holeFactor: OM211FecundityReductionLogit._HoleFactor = self._HoleFactor(xml_tree=xml_tree, parent=self)
        self.interactionFactor: OM211FecundityReductionLogit._InteractionFactor = self._InteractionFactor(xml_tree=xml_tree, parent=self)

    class _BaseFactor(AttributeNode):
        """Generated class for 'baseFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='baseFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Logit of the probability (e.g. of death, of entry, of attacking) without intervention.

units:	dimensionless
name:	Base factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Coefficient of log(insecticide content+1) in a generalized linear model with logit link
function.

units:	none
name:	Insecticide factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _HoleFactor(AttributeNode):
        """Generated class for 'holeFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='holeFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Coefficient of log(total holed surface area (in cm2) +1) in a generalized linear model
with logit link function.

units:	none
name:	Hole factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InteractionFactor(AttributeNode):
        """Generated class for 'interactionFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='interactionFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Coefficient of the interaction term of log(total holed surface area (in cm2) +1) with
log(insecticide content+1) in a generalized linear model with logit link function.

units:	none
name:	Interaction factor"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM212Usage(Node):
    """Generated class for 'usage'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='usage', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Usage of Generic vector interventions, from 0 to 1.

units:	dimensionless
min:	0
max:	1
name:	Proportion of generic vector interventions"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM212Usage._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM213Decay(Node):
    """Generated class for 'decay'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='decay', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Description of decay of all intervention effects.
Documentation: see DecayFunction type or
https://github.com/SwissTPH/openmalaria/wiki/ModelDecayFunctions

name:	Decay
Type:
Specification of decay or survival of a parameter.

name:	Decay or survival of a parameter"""
        self._metadata: dict = {'type': 'om:DecayFunction', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'function': 'required', 'L': 'optional', 'k': '', 'CV': '', 'increasing': '', 'initialEfficacy': 'optional', 'rho': 'optional', 'halflife_short': 'optional', 'halflife_long': 'optional'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.function: OM213Decay._Function = self._Function(xml_tree=xml_tree, parent=self)
        self.L: OM213Decay._L = self._L(xml_tree=xml_tree, parent=self)
        self.k: OM213Decay._K = self._K(xml_tree=xml_tree, parent=self)
        self.CV: OM213Decay._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.increasing: OM213Decay._Increasing = self._Increasing(xml_tree=xml_tree, parent=self)
        self.initialEfficacy: OM213Decay._InitialEfficacy = self._InitialEfficacy(xml_tree=xml_tree, parent=self)
        self.rho: OM213Decay._Rho = self._Rho(xml_tree=xml_tree, parent=self)
        self.halflife_short: OM213Decay._Halflife_short = self._Halflife_short(xml_tree=xml_tree, parent=self)
        self.halflife_long: OM213Decay._Halflife_long = self._Halflife_long(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Function(AttributeNode):
        """Generated class for 'function'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='function', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Determines which decay function to use. Available decay functions,
for age t in years:
constant: 1
step: 1 for t less than L, otherwise 0
linear: 1 - t/L for t less than L, otherwise 0
exponential: exp( - t/L * log(2) )
weibull: exp( -(t/L)^k * log(2) )
hill: 1 / (1 + (t/L)^k)
smooth-compact: exp( k - k / (1 - (t/L)^2) ) for t less than L, otherwise 0

units:	None
min:	0
max:	1
name:	function"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['constant', 'step', 'linear', 'exponential', 'weibull', 'hill', 'smooth-compact', 'plus', 'minus', 'divides', 'multiplies']}, 'type': 'xs:string'}

    class _L(AttributeNode):
        """Generated class for 'L'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='L', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Time) scale parameter of distribution: this is either the age of
complete decay (smooth-compact, step and linear functions) or the age
at which the parameter has decayed to half its original value
(exponential, weibull and hill). Not used when function="constant"
(i.e. no decay).
This value can be specified in years, days or steps (e.g. 2y, 180d or
100t). When the unit is not specified years are assumed. The value is
used without rounding except when sampling an age of decay, when the
rounding happens as late as possible.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _K(AttributeNode):
        """Generated class for 'k'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='k', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Shape parameter of distribution. If not specified, default value of
1 is used. Meaning depends on function; not used in some cases.

min:	0
name:	k
units:	none"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1.0', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If CV is non-zero, heterogeneity of decay is introduced via a random
variable sampled from the log-normal distribution. This distribution is
parameterised with mean=1 and CV as given.
The effective age of decay is the real age multiplied by this variable
(for decay functions with a half-life, this is equivalent to dividing
the half-life by the variable).

min:	0
name:	Coefficient of Variation"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}

    class _Increasing(AttributeNode):
        """Generated class for 'increasing'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='increasing', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Boolean) If True, this tells OpenMalaria to use the complement of the
DecayFunction defined as 1-f(x). This is useful to model increasing
functions that will "decay" to 1. This only works if f(x) is contained
between 0 and 1.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _InitialEfficacy(AttributeNode):
        """Generated class for 'initialEfficacy'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initialEfficacy', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Efficacy between 0 and 1.
"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}

    class _Rho(AttributeNode):
        """Generated class for 'rho'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='rho', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Proportion between 0 and 1, proportion of the response that is short-lived."""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_short(AttributeNode):
        """Generated class for 'halflife_short'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_short', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of short lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_long(AttributeNode):
        """Generated class for 'halflife_long'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_long', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of long lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM214AnophelesParams(Node):
    """Generated class for 'anophelesParams'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='anophelesParams', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """name:	Per-mosquito species parameters"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': ['deterrency', 'preprandialKillingEffect', 'postprandialKillingEffect', 'fecundityReduction']}, 'attributes': {'mosquito': 'required', 'propActive': ''}, 'children': {'deterrency': {'minOccurs': '0', 'maxOccurs': '1'}, 'preprandialKillingEffect': {'minOccurs': '0', 'maxOccurs': '1'}, 'postprandialKillingEffect': {'minOccurs': '0', 'maxOccurs': '1'}, 'fecundityReduction': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self.mosquito: OM214AnophelesParams._Mosquito = self._Mosquito(xml_tree=xml_tree, parent=self)
        self.propActive: OM214AnophelesParams._PropActive = self._PropActive(xml_tree=xml_tree, parent=self)
        self._deterrency: OM215Deterrency | None = None
        self._preprandialKillingEffect: OM216PreprandialKillingEffect | None = None
        self._postprandialKillingEffect: OM217PostprandialKillingEffect | None = None
        self._fecundityReduction: OM218FecundityReduction | None = None

    @property
    def deterrency(self) -> 'OM215Deterrency':
        """Initialize 'deterrency'."""
        if self._deterrency is None:
            self._deterrency = OM215Deterrency(xml_tree=self.xml_tree, parent=self)
        return self._deterrency

    @property
    def preprandialKillingEffect(self) -> 'OM216PreprandialKillingEffect':
        """Initialize 'preprandialKillingEffect'."""
        if self._preprandialKillingEffect is None:
            self._preprandialKillingEffect = OM216PreprandialKillingEffect(xml_tree=self.xml_tree, parent=self)
        return self._preprandialKillingEffect

    @property
    def postprandialKillingEffect(self) -> 'OM217PostprandialKillingEffect':
        """Initialize 'postprandialKillingEffect'."""
        if self._postprandialKillingEffect is None:
            self._postprandialKillingEffect = OM217PostprandialKillingEffect(xml_tree=self.xml_tree, parent=self)
        return self._postprandialKillingEffect

    @property
    def fecundityReduction(self) -> 'OM218FecundityReduction':
        """Initialize 'fecundityReduction'."""
        if self._fecundityReduction is None:
            self._fecundityReduction = OM218FecundityReduction(xml_tree=self.xml_tree, parent=self)
        return self._fecundityReduction

    class _Mosquito(AttributeNode):
        """Generated class for 'mosquito'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mosquito', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of the affected anopheles-mosquito species.

name:	Mosquito species"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _PropActive(AttributeNode):
        """Generated class for 'propActive'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='propActive', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The proportion of bites for which the IRS
has any action whatsoever on the mosquito.
At the moment this is constant across humans and deterministic:
relative attractiveness and survival factors are
base*(1-propActing) + intervention_factor*propActing.

units:	dimensionless
min:	0
max:	1
name:	Proportion of bites for which IRS acts"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}


class OM215Deterrency(Node):
    """Generated class for 'deterrency'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='deterrency', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of intervention on attractiveness of humans to mosquitoes relative to
an unprotected adult human. Parameterisations should take into
account that mosquitoes do not always bite indoors.
Attractiveness of the human is multiplied this factor times
survival of effect.

units:	dimensionless
min:	0
max:	1
name:	Relative attractiveness"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM215Deterrency._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM216PreprandialKillingEffect(Node):
    """Generated class for 'preprandialKillingEffect'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='preprandialKillingEffect', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of intervention on survival of mosquitoes as they seek to bite a human
after choosing that human, relative to the same person not
protected by the intervention. Parameterisations should take into account
that mosquitoes do not always bite indoors. This parameter has
been added since some data shows IRS to have a preprandial
killing effect.
Killing proportion is this factor multiplied by survival of effect.

units:	dimensionless
min:	0
max:	1
name:	Pre-prandial killing effect"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM216PreprandialKillingEffect._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM217PostprandialKillingEffect(Node):
    """Generated class for 'postprandialKillingEffect'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='postprandialKillingEffect', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of intervention on survival of mosquitoes as they seek to escape from
a human host and rest after a blood meal, relative to the same
person not protected by the intervention. Parameterisations should take
into account that mosquitoes do not always bite indoors.
Killing proportion is this factor multiplied by survival of effect.

units:	dimensionless
min:	0
max:	1
name:	Post-prandial killing effect"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM217PostprandialKillingEffect._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM218FecundityReduction(Node):
    """Generated class for 'fecundityReduction'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='fecundityReduction', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of intervention on fertility mosquitoes after successfully feeding on
a human host, relative to an unproteced human. Parameterisations should take
into account that mosquitoes do not always bite indoors.
Fertility is multiplied by 1 - (fecundityReduction * decay).

min:	0
name:	Fecundity reduction effect"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM218FecundityReduction._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM219Usage(Node):
    """Generated class for 'usage'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='usage', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Usage of Indoor residual spraying (IRS) interventions, from 0 to 1.

units:	dimensionless
min:	0
max:	1
name:	Proportion of Indoor residual spraying (IRS) interventions"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM219Usage._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM220InitialInsecticide(Node):
    """Generated class for 'initialInsecticide'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='initialInsecticide', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
The insecticide concentration of IRS (at time of spraying) is
Gaussian distributed with mean "mu" and a standard deviation "sigma".
The standard deviation should be small relative to the mean to avoid
negative initial concentration. Any negative values sampled are set
to 0.

units:	g/cm
min:	0
name:	Initial insecticide
Type:
A parameter with optional heterogeneity.
Optionally, a distribution ("distr") and standard of deviation ("SD") may be specified.

name:	Sampled value (normal)"""
        self._metadata: dict = {'type': 'om:SampledValueN', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'SD': 'optional', 'distr': 'optional'}, 'children': {}}
        self.mean: OM220InitialInsecticide._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.SD: OM220InitialInsecticide._SD = self._SD(xml_tree=xml_tree, parent=self)
        self.distr: OM220InitialInsecticide._Distr = self._Distr(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _SD(AttributeNode):
        """Generated class for 'SD'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='SD', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The standard deviation of variates.

name:	standard deviation"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"normal": the parameter is sampled from a normal distribution.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'normal']}, 'type': 'xs:string'}


class OM221InsecticideDecay(Node):
    """Generated class for 'insecticideDecay'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='insecticideDecay', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Decay curve for insecticide content of IRS. Documentation: see DecayFunction
type or https://github.com/SwissTPH/openmalaria/wiki/ModelDecayFunctions

units:	none
name:	Decay of insecticide
Type:
Specification of decay or survival of a parameter.

name:	Decay or survival of a parameter"""
        self._metadata: dict = {'type': 'om:DecayFunction', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'function': 'required', 'L': 'optional', 'k': '', 'CV': '', 'increasing': '', 'initialEfficacy': 'optional', 'rho': 'optional', 'halflife_short': 'optional', 'halflife_long': 'optional'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.function: OM221InsecticideDecay._Function = self._Function(xml_tree=xml_tree, parent=self)
        self.L: OM221InsecticideDecay._L = self._L(xml_tree=xml_tree, parent=self)
        self.k: OM221InsecticideDecay._K = self._K(xml_tree=xml_tree, parent=self)
        self.CV: OM221InsecticideDecay._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.increasing: OM221InsecticideDecay._Increasing = self._Increasing(xml_tree=xml_tree, parent=self)
        self.initialEfficacy: OM221InsecticideDecay._InitialEfficacy = self._InitialEfficacy(xml_tree=xml_tree, parent=self)
        self.rho: OM221InsecticideDecay._Rho = self._Rho(xml_tree=xml_tree, parent=self)
        self.halflife_short: OM221InsecticideDecay._Halflife_short = self._Halflife_short(xml_tree=xml_tree, parent=self)
        self.halflife_long: OM221InsecticideDecay._Halflife_long = self._Halflife_long(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Function(AttributeNode):
        """Generated class for 'function'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='function', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Determines which decay function to use. Available decay functions,
for age t in years:
constant: 1
step: 1 for t less than L, otherwise 0
linear: 1 - t/L for t less than L, otherwise 0
exponential: exp( - t/L * log(2) )
weibull: exp( -(t/L)^k * log(2) )
hill: 1 / (1 + (t/L)^k)
smooth-compact: exp( k - k / (1 - (t/L)^2) ) for t less than L, otherwise 0

units:	None
min:	0
max:	1
name:	function"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['constant', 'step', 'linear', 'exponential', 'weibull', 'hill', 'smooth-compact', 'plus', 'minus', 'divides', 'multiplies']}, 'type': 'xs:string'}

    class _L(AttributeNode):
        """Generated class for 'L'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='L', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Time) scale parameter of distribution: this is either the age of
complete decay (smooth-compact, step and linear functions) or the age
at which the parameter has decayed to half its original value
(exponential, weibull and hill). Not used when function="constant"
(i.e. no decay).
This value can be specified in years, days or steps (e.g. 2y, 180d or
100t). When the unit is not specified years are assumed. The value is
used without rounding except when sampling an age of decay, when the
rounding happens as late as possible.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _K(AttributeNode):
        """Generated class for 'k'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='k', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Shape parameter of distribution. If not specified, default value of
1 is used. Meaning depends on function; not used in some cases.

min:	0
name:	k
units:	none"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1.0', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If CV is non-zero, heterogeneity of decay is introduced via a random
variable sampled from the log-normal distribution. This distribution is
parameterised with mean=1 and CV as given.
The effective age of decay is the real age multiplied by this variable
(for decay functions with a half-life, this is equivalent to dividing
the half-life by the variable).

min:	0
name:	Coefficient of Variation"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}

    class _Increasing(AttributeNode):
        """Generated class for 'increasing'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='increasing', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Boolean) If True, this tells OpenMalaria to use the complement of the
DecayFunction defined as 1-f(x). This is useful to model increasing
functions that will "decay" to 1. This only works if f(x) is contained
between 0 and 1.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _InitialEfficacy(AttributeNode):
        """Generated class for 'initialEfficacy'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initialEfficacy', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Efficacy between 0 and 1.
"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}

    class _Rho(AttributeNode):
        """Generated class for 'rho'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='rho', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Proportion between 0 and 1, proportion of the response that is short-lived."""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_short(AttributeNode):
        """Generated class for 'halflife_short'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_short', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of short lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_long(AttributeNode):
        """Generated class for 'halflife_long'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_long', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of long lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM222AnophelesParams(Node):
    """Generated class for 'anophelesParams'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='anophelesParams', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """name:	Per-mosquito species parameters"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': ['deterrency', 'preprandialKillingEffect', 'postprandialKillingEffect', 'fecundityReduction']}, 'attributes': {'mosquito': 'required', 'propActive': ''}, 'children': {'deterrency': {'minOccurs': '1', 'maxOccurs': '1'}, 'preprandialKillingEffect': {'minOccurs': '1', 'maxOccurs': '1'}, 'postprandialKillingEffect': {'minOccurs': '1', 'maxOccurs': '1'}, 'fecundityReduction': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self.mosquito: OM222AnophelesParams._Mosquito = self._Mosquito(xml_tree=xml_tree, parent=self)
        self.propActive: OM222AnophelesParams._PropActive = self._PropActive(xml_tree=xml_tree, parent=self)
        self._deterrency: OM223Deterrency | None = None
        self._preprandialKillingEffect: OM224PreprandialKillingEffect | None = None
        self._postprandialKillingEffect: OM225PostprandialKillingEffect | None = None
        self._fecundityReduction: OM226FecundityReduction | None = None

    @property
    def deterrency(self) -> 'OM223Deterrency':
        """Initialize 'deterrency'."""
        if self._deterrency is None:
            self._deterrency = OM223Deterrency(xml_tree=self.xml_tree, parent=self)
        return self._deterrency

    @property
    def preprandialKillingEffect(self) -> 'OM224PreprandialKillingEffect':
        """Initialize 'preprandialKillingEffect'."""
        if self._preprandialKillingEffect is None:
            self._preprandialKillingEffect = OM224PreprandialKillingEffect(xml_tree=self.xml_tree, parent=self)
        return self._preprandialKillingEffect

    @property
    def postprandialKillingEffect(self) -> 'OM225PostprandialKillingEffect':
        """Initialize 'postprandialKillingEffect'."""
        if self._postprandialKillingEffect is None:
            self._postprandialKillingEffect = OM225PostprandialKillingEffect(xml_tree=self.xml_tree, parent=self)
        return self._postprandialKillingEffect

    @property
    def fecundityReduction(self) -> 'OM226FecundityReduction':
        """Initialize 'fecundityReduction'."""
        if self._fecundityReduction is None:
            self._fecundityReduction = OM226FecundityReduction(xml_tree=self.xml_tree, parent=self)
        return self._fecundityReduction

    class _Mosquito(AttributeNode):
        """Generated class for 'mosquito'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mosquito', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of the affected anopheles-mosquito species.

name:	Mosquito species"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _PropActive(AttributeNode):
        """Generated class for 'propActive'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='propActive', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The proportion of bites for which the IRS
has any action whatsoever on the mosquito.
At the moment this is constant across humans and deterministic:
relative attractiveness and survival factors are
base*(1-propActing) + intervention_factor*propActing.

units:	dimensionless
min:	0
max:	1
name:	Proportion of bites for which IRS acts"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}


class OM223Deterrency(Node):
    """Generated class for 'deterrency'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='deterrency', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of IRS on attractiveness of humans to mosquitoes relative to
an unprotected adult human. Parameterisations should take into
account that mosquitoes do not always bite indoors.
Attractiveness of the human is multiplied by exp(Plog(p))
where P is the insecticide factor,
p=1exp(-insecticideContentinsecticideScalingFactor).

units:	dimensionless
min:	0
max:	1
name:	Relative attractiveness"""
        self._metadata: dict = {'type': 'om:IRSDeterrency', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'insecticideFactor': 'required', 'insecticideScalingFactor': 'required'}, 'children': {}}
        self.insecticideFactor: OM223Deterrency._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)
        self.insecticideScalingFactor: OM223Deterrency._InsecticideScalingFactor = self._InsecticideScalingFactor(xml_tree=xml_tree, parent=self)

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Insecticide factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideScalingFactor(AttributeNode):
        """Generated class for 'insecticideScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Insecticide scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM224PreprandialKillingEffect(Node):
    """Generated class for 'preprandialKillingEffect'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='preprandialKillingEffect', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of IRS on survival mosquitoes as they seek to bite a human
after choosing that human, relative to the same person not
protected by IRS. Parameterisations should take into account
that mosquitoes do not always bite indoors. This parameter has
been added since some data shows IRS to have a preprandial
killing effect.
Killing proportion is calculated as K = B + Pp where B is the
base (without protection) probability of death, and P is the
insecticide factor,
p=1exp(-insecticideContentinsecticideScalingFactor).
Survival of mosquitoes is adjusted via multiplication by (1K) / (1B).
To keep this in the range [0,1], we require that B+P  1 and P  0.

units:	dimensionless
min:	0
max:	1
name:	Pre-prandial killing effect"""
        self._metadata: dict = {'type': 'om:IRSKillingEffect', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'baseFactor': 'required', 'insecticideFactor': 'required', 'insecticideScalingFactor': 'required'}, 'children': {}}
        self.baseFactor: OM224PreprandialKillingEffect._BaseFactor = self._BaseFactor(xml_tree=xml_tree, parent=self)
        self.insecticideFactor: OM224PreprandialKillingEffect._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)
        self.insecticideScalingFactor: OM224PreprandialKillingEffect._InsecticideScalingFactor = self._InsecticideScalingFactor(xml_tree=xml_tree, parent=self)

    class _BaseFactor(AttributeNode):
        """Generated class for 'baseFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='baseFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
name:	Probability of mosquito death without intervention"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Insecticide factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideScalingFactor(AttributeNode):
        """Generated class for 'insecticideScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Insecticide scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM225PostprandialKillingEffect(Node):
    """Generated class for 'postprandialKillingEffect'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='postprandialKillingEffect', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of IRS on survival mosquitoes as they seek to escape from
a human host and rest after a blood meal, relative to the same
person not protected by IRS. Parameterisations should take
into account that mosquitoes do not always bite indoors.
Killing proportion is calculated as K = B + Pp where B is the
base (without protection) probability of death, and P is the
insecticide factor,
p=1exp(-insecticideContentinsecticideScalingFactor).
Survival of mosquitoes is adjusted via multiplication by (1K) / (1B).
To keep this in the range [0,1], we require that B+P  1 and P  0.

units:	dimensionless
min:	0
max:	1
name:	Post-prandial killing effect"""
        self._metadata: dict = {'type': 'om:IRSKillingEffect', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'baseFactor': 'required', 'insecticideFactor': 'required', 'insecticideScalingFactor': 'required'}, 'children': {}}
        self.baseFactor: OM225PostprandialKillingEffect._BaseFactor = self._BaseFactor(xml_tree=xml_tree, parent=self)
        self.insecticideFactor: OM225PostprandialKillingEffect._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)
        self.insecticideScalingFactor: OM225PostprandialKillingEffect._InsecticideScalingFactor = self._InsecticideScalingFactor(xml_tree=xml_tree, parent=self)

    class _BaseFactor(AttributeNode):
        """Generated class for 'baseFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='baseFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
name:	Probability of mosquito death without intervention"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Insecticide factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideScalingFactor(AttributeNode):
        """Generated class for 'insecticideScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Insecticide scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM226FecundityReduction(Node):
    """Generated class for 'fecundityReduction'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='fecundityReduction', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Effect of IRS on fertility mosquitoes after successfully feeding on
a human host, relative to an unproteced human. Parameterisations should take
into account that mosquitoes do not always bite indoors.
First, we calculate K = B + Pp where B is the
base (without protection) probability of death, and P is the
insecticide factor,
p=1exp(-insecticideContentinsecticideScalingFactor).
Fecundity is multiplied by (1K) / (1B). It is not allowed to be greater than 1.
To keep this in the range [0,1], we require that B+P  1 and P  0.

name:	Fecundity reduction"""
        self._metadata: dict = {'type': 'om:IRSKillingEffect', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'baseFactor': 'required', 'insecticideFactor': 'required', 'insecticideScalingFactor': 'required'}, 'children': {}}
        self.baseFactor: OM226FecundityReduction._BaseFactor = self._BaseFactor(xml_tree=xml_tree, parent=self)
        self.insecticideFactor: OM226FecundityReduction._InsecticideFactor = self._InsecticideFactor(xml_tree=xml_tree, parent=self)
        self.insecticideScalingFactor: OM226FecundityReduction._InsecticideScalingFactor = self._InsecticideScalingFactor(xml_tree=xml_tree, parent=self)

    class _BaseFactor(AttributeNode):
        """Generated class for 'baseFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='baseFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
name:	Probability of mosquito death without intervention"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideFactor(AttributeNode):
        """Generated class for 'insecticideFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Value expected to be at least 0. Negative values are not
necessarily invalid, but allow nets to increase transmission.

units:	none
name:	Insecticide factor
max:	1"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _InsecticideScalingFactor(AttributeNode):
        """Generated class for 'insecticideScalingFactor'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='insecticideScalingFactor', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	none
name:	Insecticide scaling factor
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM227SeekingDeathRateIncrease(Node):
    """Generated class for 'seekingDeathRateIncrease'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='seekingDeathRateIncrease', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describe an effect on the increase in the death rate while host
seeking (mu_vA) due to this intervention.
Enter the rate increase (i.e. if rate increases to 120% of normal,
give 0.2). New death rate while seeking is old  (1 + increase)
where increase is this factor given. Must have increas  -1.

units:	dimensionless
name:	Proportional increase in deaths while host searching"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'initial': 'required'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.initial: OM227SeekingDeathRateIncrease._Initial = self._Initial(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Initial(AttributeNode):
        """Generated class for 'initial'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initial', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
min:	-1
max:	inf
name:	Initial proportion increase"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM228Decay(Node):
    """Generated class for 'decay'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='decay', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Specification of decay or survival of a parameter.

name:	Decay or survival of a parameter"""
        self._metadata: dict = {'type': 'om:DecayFunction', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'function': 'required', 'L': 'optional', 'k': '', 'CV': '', 'increasing': '', 'initialEfficacy': 'optional', 'rho': 'optional', 'halflife_short': 'optional', 'halflife_long': 'optional'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.function: OM228Decay._Function = self._Function(xml_tree=xml_tree, parent=self)
        self.L: OM228Decay._L = self._L(xml_tree=xml_tree, parent=self)
        self.k: OM228Decay._K = self._K(xml_tree=xml_tree, parent=self)
        self.CV: OM228Decay._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.increasing: OM228Decay._Increasing = self._Increasing(xml_tree=xml_tree, parent=self)
        self.initialEfficacy: OM228Decay._InitialEfficacy = self._InitialEfficacy(xml_tree=xml_tree, parent=self)
        self.rho: OM228Decay._Rho = self._Rho(xml_tree=xml_tree, parent=self)
        self.halflife_short: OM228Decay._Halflife_short = self._Halflife_short(xml_tree=xml_tree, parent=self)
        self.halflife_long: OM228Decay._Halflife_long = self._Halflife_long(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Function(AttributeNode):
        """Generated class for 'function'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='function', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Determines which decay function to use. Available decay functions,
for age t in years:
constant: 1
step: 1 for t less than L, otherwise 0
linear: 1 - t/L for t less than L, otherwise 0
exponential: exp( - t/L * log(2) )
weibull: exp( -(t/L)^k * log(2) )
hill: 1 / (1 + (t/L)^k)
smooth-compact: exp( k - k / (1 - (t/L)^2) ) for t less than L, otherwise 0

units:	None
min:	0
max:	1
name:	function"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['constant', 'step', 'linear', 'exponential', 'weibull', 'hill', 'smooth-compact', 'plus', 'minus', 'divides', 'multiplies']}, 'type': 'xs:string'}

    class _L(AttributeNode):
        """Generated class for 'L'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='L', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Time) scale parameter of distribution: this is either the age of
complete decay (smooth-compact, step and linear functions) or the age
at which the parameter has decayed to half its original value
(exponential, weibull and hill). Not used when function="constant"
(i.e. no decay).
This value can be specified in years, days or steps (e.g. 2y, 180d or
100t). When the unit is not specified years are assumed. The value is
used without rounding except when sampling an age of decay, when the
rounding happens as late as possible.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _K(AttributeNode):
        """Generated class for 'k'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='k', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Shape parameter of distribution. If not specified, default value of
1 is used. Meaning depends on function; not used in some cases.

min:	0
name:	k
units:	none"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1.0', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If CV is non-zero, heterogeneity of decay is introduced via a random
variable sampled from the log-normal distribution. This distribution is
parameterised with mean=1 and CV as given.
The effective age of decay is the real age multiplied by this variable
(for decay functions with a half-life, this is equivalent to dividing
the half-life by the variable).

min:	0
name:	Coefficient of Variation"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}

    class _Increasing(AttributeNode):
        """Generated class for 'increasing'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='increasing', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Boolean) If True, this tells OpenMalaria to use the complement of the
DecayFunction defined as 1-f(x). This is useful to model increasing
functions that will "decay" to 1. This only works if f(x) is contained
between 0 and 1.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _InitialEfficacy(AttributeNode):
        """Generated class for 'initialEfficacy'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initialEfficacy', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Efficacy between 0 and 1.
"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}

    class _Rho(AttributeNode):
        """Generated class for 'rho'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='rho', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Proportion between 0 and 1, proportion of the response that is short-lived."""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_short(AttributeNode):
        """Generated class for 'halflife_short'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_short', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of short lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_long(AttributeNode):
        """Generated class for 'halflife_long'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_long', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of long lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM229ProbDeathOvipositing(Node):
    """Generated class for 'probDeathOvipositing'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='probDeathOvipositing', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describe an effect of increased mortality while ovipositing
due to this intervention. Enter the probability of dying due to
this intervention.

units:	dimensionless
name:	Proportion ovipositing mosquitoes killed"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'initial': 'required'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.initial: OM229ProbDeathOvipositing._Initial = self._Initial(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Initial(AttributeNode):
        """Generated class for 'initial'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initial', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
min:	0
max:	1
name:	Initial probability of killing"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM230Decay(Node):
    """Generated class for 'decay'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='decay', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Specification of decay or survival of a parameter.

name:	Decay or survival of a parameter"""
        self._metadata: dict = {'type': 'om:DecayFunction', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'function': 'required', 'L': 'optional', 'k': '', 'CV': '', 'increasing': '', 'initialEfficacy': 'optional', 'rho': 'optional', 'halflife_short': 'optional', 'halflife_long': 'optional'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.function: OM230Decay._Function = self._Function(xml_tree=xml_tree, parent=self)
        self.L: OM230Decay._L = self._L(xml_tree=xml_tree, parent=self)
        self.k: OM230Decay._K = self._K(xml_tree=xml_tree, parent=self)
        self.CV: OM230Decay._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.increasing: OM230Decay._Increasing = self._Increasing(xml_tree=xml_tree, parent=self)
        self.initialEfficacy: OM230Decay._InitialEfficacy = self._InitialEfficacy(xml_tree=xml_tree, parent=self)
        self.rho: OM230Decay._Rho = self._Rho(xml_tree=xml_tree, parent=self)
        self.halflife_short: OM230Decay._Halflife_short = self._Halflife_short(xml_tree=xml_tree, parent=self)
        self.halflife_long: OM230Decay._Halflife_long = self._Halflife_long(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Function(AttributeNode):
        """Generated class for 'function'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='function', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Determines which decay function to use. Available decay functions,
for age t in years:
constant: 1
step: 1 for t less than L, otherwise 0
linear: 1 - t/L for t less than L, otherwise 0
exponential: exp( - t/L * log(2) )
weibull: exp( -(t/L)^k * log(2) )
hill: 1 / (1 + (t/L)^k)
smooth-compact: exp( k - k / (1 - (t/L)^2) ) for t less than L, otherwise 0

units:	None
min:	0
max:	1
name:	function"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['constant', 'step', 'linear', 'exponential', 'weibull', 'hill', 'smooth-compact', 'plus', 'minus', 'divides', 'multiplies']}, 'type': 'xs:string'}

    class _L(AttributeNode):
        """Generated class for 'L'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='L', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Time) scale parameter of distribution: this is either the age of
complete decay (smooth-compact, step and linear functions) or the age
at which the parameter has decayed to half its original value
(exponential, weibull and hill). Not used when function="constant"
(i.e. no decay).
This value can be specified in years, days or steps (e.g. 2y, 180d or
100t). When the unit is not specified years are assumed. The value is
used without rounding except when sampling an age of decay, when the
rounding happens as late as possible.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _K(AttributeNode):
        """Generated class for 'k'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='k', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Shape parameter of distribution. If not specified, default value of
1 is used. Meaning depends on function; not used in some cases.

min:	0
name:	k
units:	none"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1.0', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If CV is non-zero, heterogeneity of decay is introduced via a random
variable sampled from the log-normal distribution. This distribution is
parameterised with mean=1 and CV as given.
The effective age of decay is the real age multiplied by this variable
(for decay functions with a half-life, this is equivalent to dividing
the half-life by the variable).

min:	0
name:	Coefficient of Variation"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}

    class _Increasing(AttributeNode):
        """Generated class for 'increasing'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='increasing', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Boolean) If True, this tells OpenMalaria to use the complement of the
DecayFunction defined as 1-f(x). This is useful to model increasing
functions that will "decay" to 1. This only works if f(x) is contained
between 0 and 1.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _InitialEfficacy(AttributeNode):
        """Generated class for 'initialEfficacy'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initialEfficacy', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Efficacy between 0 and 1.
"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}

    class _Rho(AttributeNode):
        """Generated class for 'rho'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='rho', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Proportion between 0 and 1, proportion of the response that is short-lived."""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_short(AttributeNode):
        """Generated class for 'halflife_short'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_short', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of short lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_long(AttributeNode):
        """Generated class for 'halflife_long'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_long', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of long lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM231EmergenceReduction(Node):
    """Generated class for 'emergenceReduction'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='emergenceReduction', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describe an effect on emergence of pupa into adults: this value is the
proportion of emerging pupa which are killed by this intervention.
This can be used as a crude way of modelling larviciding. It ca
also be used to increase emergence by giving a negative value.
The emergence rate is "old rate"  (1 - factor) where factor is the
value given here; thus, for example, using -1 will double emergence.

units:	dimensionless
name:	Proportion of emerging pupa killed"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'initial': 'required'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.initial: OM231EmergenceReduction._Initial = self._Initial(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Initial(AttributeNode):
        """Generated class for 'initial'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initial', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
min:	-inf
max:	1
name:	Initial proportion reduction"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM232Decay(Node):
    """Generated class for 'decay'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='decay', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Specification of decay or survival of a parameter.

name:	Decay or survival of a parameter"""
        self._metadata: dict = {'type': 'om:DecayFunction', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'function': 'required', 'L': 'optional', 'k': '', 'CV': '', 'increasing': '', 'initialEfficacy': 'optional', 'rho': 'optional', 'halflife_short': 'optional', 'halflife_long': 'optional'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.function: OM232Decay._Function = self._Function(xml_tree=xml_tree, parent=self)
        self.L: OM232Decay._L = self._L(xml_tree=xml_tree, parent=self)
        self.k: OM232Decay._K = self._K(xml_tree=xml_tree, parent=self)
        self.CV: OM232Decay._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.increasing: OM232Decay._Increasing = self._Increasing(xml_tree=xml_tree, parent=self)
        self.initialEfficacy: OM232Decay._InitialEfficacy = self._InitialEfficacy(xml_tree=xml_tree, parent=self)
        self.rho: OM232Decay._Rho = self._Rho(xml_tree=xml_tree, parent=self)
        self.halflife_short: OM232Decay._Halflife_short = self._Halflife_short(xml_tree=xml_tree, parent=self)
        self.halflife_long: OM232Decay._Halflife_long = self._Halflife_long(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Function(AttributeNode):
        """Generated class for 'function'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='function', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Determines which decay function to use. Available decay functions,
for age t in years:
constant: 1
step: 1 for t less than L, otherwise 0
linear: 1 - t/L for t less than L, otherwise 0
exponential: exp( - t/L * log(2) )
weibull: exp( -(t/L)^k * log(2) )
hill: 1 / (1 + (t/L)^k)
smooth-compact: exp( k - k / (1 - (t/L)^2) ) for t less than L, otherwise 0

units:	None
min:	0
max:	1
name:	function"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['constant', 'step', 'linear', 'exponential', 'weibull', 'hill', 'smooth-compact', 'plus', 'minus', 'divides', 'multiplies']}, 'type': 'xs:string'}

    class _L(AttributeNode):
        """Generated class for 'L'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='L', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Time) scale parameter of distribution: this is either the age of
complete decay (smooth-compact, step and linear functions) or the age
at which the parameter has decayed to half its original value
(exponential, weibull and hill). Not used when function="constant"
(i.e. no decay).
This value can be specified in years, days or steps (e.g. 2y, 180d or
100t). When the unit is not specified years are assumed. The value is
used without rounding except when sampling an age of decay, when the
rounding happens as late as possible.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _K(AttributeNode):
        """Generated class for 'k'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='k', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Shape parameter of distribution. If not specified, default value of
1 is used. Meaning depends on function; not used in some cases.

min:	0
name:	k
units:	none"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1.0', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If CV is non-zero, heterogeneity of decay is introduced via a random
variable sampled from the log-normal distribution. This distribution is
parameterised with mean=1 and CV as given.
The effective age of decay is the real age multiplied by this variable
(for decay functions with a half-life, this is equivalent to dividing
the half-life by the variable).

min:	0
name:	Coefficient of Variation"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}

    class _Increasing(AttributeNode):
        """Generated class for 'increasing'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='increasing', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Boolean) If True, this tells OpenMalaria to use the complement of the
DecayFunction defined as 1-f(x). This is useful to model increasing
functions that will "decay" to 1. This only works if f(x) is contained
between 0 and 1.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _InitialEfficacy(AttributeNode):
        """Generated class for 'initialEfficacy'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initialEfficacy', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Efficacy between 0 and 1.
"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}

    class _Rho(AttributeNode):
        """Generated class for 'rho'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='rho', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Proportion between 0 and 1, proportion of the response that is short-lived."""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_short(AttributeNode):
        """Generated class for 'halflife_short'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_short', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of short lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_long(AttributeNode):
        """Generated class for 'halflife_long'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_long', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of long lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM233ProbAdditionalDeathSugarFeeding(Node):
    """Generated class for 'probAdditionalDeathSugarFeeding'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='probAdditionalDeathSugarFeeding', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Describe an effect on the increase in the death rate while host
seeking (mu_vA) due to this intervention. This works like 
adding an non-human host with its own availability. The
difference is that biting this sugar bait is associated with a 
probability of dying of 1: all mosquitoes biting the sugar bait
will die. OpenMalaria will automatically compute the 
availability for this host so that the probability of biting this
'host' (and thus dying) is equal to the input parameter.
Enter the probability of dying while host seeking due to this 
intervention. If multiple interventions overlap, the cumulative 
probability will be used. Note that it cannot exceed 1, and 
OpenMalaria will return an error during the simulation if this
ever happens.
OpenMalaria will dynamically compute the necessary increase 
in mu_vA based on the given probability. Note that this is done 
by solving an equation numerically every timestep, which can 
cause a small drop in performance.
units:	dimensionless
name:	Probability of death while host searching as a result of feeding on a sugar bait (used to dynamically adjust mu_vA)"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'initial': 'required'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.initial: OM233ProbAdditionalDeathSugarFeeding._Initial = self._Initial(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Initial(AttributeNode):
        """Generated class for 'initial'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initial', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
min:	-1
max:	inf
name:	Initial proportion increase"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM234Decay(Node):
    """Generated class for 'decay'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='decay', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Specification of decay or survival of a parameter.

name:	Decay or survival of a parameter"""
        self._metadata: dict = {'type': 'om:DecayFunction', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'function': 'required', 'L': 'optional', 'k': '', 'CV': '', 'increasing': '', 'initialEfficacy': 'optional', 'rho': 'optional', 'halflife_short': 'optional', 'halflife_long': 'optional'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.function: OM234Decay._Function = self._Function(xml_tree=xml_tree, parent=self)
        self.L: OM234Decay._L = self._L(xml_tree=xml_tree, parent=self)
        self.k: OM234Decay._K = self._K(xml_tree=xml_tree, parent=self)
        self.CV: OM234Decay._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.increasing: OM234Decay._Increasing = self._Increasing(xml_tree=xml_tree, parent=self)
        self.initialEfficacy: OM234Decay._InitialEfficacy = self._InitialEfficacy(xml_tree=xml_tree, parent=self)
        self.rho: OM234Decay._Rho = self._Rho(xml_tree=xml_tree, parent=self)
        self.halflife_short: OM234Decay._Halflife_short = self._Halflife_short(xml_tree=xml_tree, parent=self)
        self.halflife_long: OM234Decay._Halflife_long = self._Halflife_long(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Function(AttributeNode):
        """Generated class for 'function'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='function', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Determines which decay function to use. Available decay functions,
for age t in years:
constant: 1
step: 1 for t less than L, otherwise 0
linear: 1 - t/L for t less than L, otherwise 0
exponential: exp( - t/L * log(2) )
weibull: exp( -(t/L)^k * log(2) )
hill: 1 / (1 + (t/L)^k)
smooth-compact: exp( k - k / (1 - (t/L)^2) ) for t less than L, otherwise 0

units:	None
min:	0
max:	1
name:	function"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['constant', 'step', 'linear', 'exponential', 'weibull', 'hill', 'smooth-compact', 'plus', 'minus', 'divides', 'multiplies']}, 'type': 'xs:string'}

    class _L(AttributeNode):
        """Generated class for 'L'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='L', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Time) scale parameter of distribution: this is either the age of
complete decay (smooth-compact, step and linear functions) or the age
at which the parameter has decayed to half its original value
(exponential, weibull and hill). Not used when function="constant"
(i.e. no decay).
This value can be specified in years, days or steps (e.g. 2y, 180d or
100t). When the unit is not specified years are assumed. The value is
used without rounding except when sampling an age of decay, when the
rounding happens as late as possible.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _K(AttributeNode):
        """Generated class for 'k'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='k', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Shape parameter of distribution. If not specified, default value of
1 is used. Meaning depends on function; not used in some cases.

min:	0
name:	k
units:	none"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1.0', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If CV is non-zero, heterogeneity of decay is introduced via a random
variable sampled from the log-normal distribution. This distribution is
parameterised with mean=1 and CV as given.
The effective age of decay is the real age multiplied by this variable
(for decay functions with a half-life, this is equivalent to dividing
the half-life by the variable).

min:	0
name:	Coefficient of Variation"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}

    class _Increasing(AttributeNode):
        """Generated class for 'increasing'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='increasing', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Boolean) If True, this tells OpenMalaria to use the complement of the
DecayFunction defined as 1-f(x). This is useful to model increasing
functions that will "decay" to 1. This only works if f(x) is contained
between 0 and 1.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _InitialEfficacy(AttributeNode):
        """Generated class for 'initialEfficacy'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initialEfficacy', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Efficacy between 0 and 1.
"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}

    class _Rho(AttributeNode):
        """Generated class for 'rho'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='rho', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Proportion between 0 and 1, proportion of the response that is short-lived."""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_short(AttributeNode):
        """Generated class for 'halflife_short'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_short', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of short lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_long(AttributeNode):
        """Generated class for 'halflife_long'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_long', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of long lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM235Decay(Node):
    """Generated class for 'decay'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='decay', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Specification of decay or survival of a parameter.

name:	Decay or survival of a parameter"""
        self._metadata: dict = {'type': 'om:DecayFunction', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'function': 'required', 'L': 'optional', 'k': '', 'CV': '', 'increasing': '', 'initialEfficacy': 'optional', 'rho': 'optional', 'halflife_short': 'optional', 'halflife_long': 'optional'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.function: OM235Decay._Function = self._Function(xml_tree=xml_tree, parent=self)
        self.L: OM235Decay._L = self._L(xml_tree=xml_tree, parent=self)
        self.k: OM235Decay._K = self._K(xml_tree=xml_tree, parent=self)
        self.CV: OM235Decay._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.increasing: OM235Decay._Increasing = self._Increasing(xml_tree=xml_tree, parent=self)
        self.initialEfficacy: OM235Decay._InitialEfficacy = self._InitialEfficacy(xml_tree=xml_tree, parent=self)
        self.rho: OM235Decay._Rho = self._Rho(xml_tree=xml_tree, parent=self)
        self.halflife_short: OM235Decay._Halflife_short = self._Halflife_short(xml_tree=xml_tree, parent=self)
        self.halflife_long: OM235Decay._Halflife_long = self._Halflife_long(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Function(AttributeNode):
        """Generated class for 'function'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='function', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Determines which decay function to use. Available decay functions,
for age t in years:
constant: 1
step: 1 for t less than L, otherwise 0
linear: 1 - t/L for t less than L, otherwise 0
exponential: exp( - t/L * log(2) )
weibull: exp( -(t/L)^k * log(2) )
hill: 1 / (1 + (t/L)^k)
smooth-compact: exp( k - k / (1 - (t/L)^2) ) for t less than L, otherwise 0

units:	None
min:	0
max:	1
name:	function"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['constant', 'step', 'linear', 'exponential', 'weibull', 'hill', 'smooth-compact', 'plus', 'minus', 'divides', 'multiplies']}, 'type': 'xs:string'}

    class _L(AttributeNode):
        """Generated class for 'L'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='L', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Time) scale parameter of distribution: this is either the age of
complete decay (smooth-compact, step and linear functions) or the age
at which the parameter has decayed to half its original value
(exponential, weibull and hill). Not used when function="constant"
(i.e. no decay).
This value can be specified in years, days or steps (e.g. 2y, 180d or
100t). When the unit is not specified years are assumed. The value is
used without rounding except when sampling an age of decay, when the
rounding happens as late as possible.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _K(AttributeNode):
        """Generated class for 'k'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='k', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Shape parameter of distribution. If not specified, default value of
1 is used. Meaning depends on function; not used in some cases.

min:	0
name:	k
units:	none"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1.0', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If CV is non-zero, heterogeneity of decay is introduced via a random
variable sampled from the log-normal distribution. This distribution is
parameterised with mean=1 and CV as given.
The effective age of decay is the real age multiplied by this variable
(for decay functions with a half-life, this is equivalent to dividing
the half-life by the variable).

min:	0
name:	Coefficient of Variation"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}

    class _Increasing(AttributeNode):
        """Generated class for 'increasing'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='increasing', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Boolean) If True, this tells OpenMalaria to use the complement of the
DecayFunction defined as 1-f(x). This is useful to model increasing
functions that will "decay" to 1. This only works if f(x) is contained
between 0 and 1.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _InitialEfficacy(AttributeNode):
        """Generated class for 'initialEfficacy'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initialEfficacy', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Efficacy between 0 and 1.
"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}

    class _Rho(AttributeNode):
        """Generated class for 'rho'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='rho', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Proportion between 0 and 1, proportion of the response that is short-lived."""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_short(AttributeNode):
        """Generated class for 'halflife_short'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_short', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of short lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_long(AttributeNode):
        """Generated class for 'halflife_long'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_long', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of long lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM236Description(Node):
    """Generated class for 'description'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='description', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': ['anopheles']}, 'attributes': {}, 'children': {'anopheles': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._anopheles: OM237Anopheles | None = None

    @property
    def anopheles(self) -> 'OM237Anopheles':
        """Initialize 'anopheles'."""
        if self._anopheles is None:
            self._anopheles = OM237Anopheles(xml_tree=self.xml_tree, parent=self)
        return self._anopheles


class OM237Anopheles(Node):
    """Generated class for 'anopheles'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='anopheles', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Descriptions of the effects of non human hosts interventions with per-species effects.
"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'type': 'om:NonHumanHostsSpeciesIntervention', 'children_metadata': {'ordered': 'all', 'order': ['availabilityReduction', 'preprandialKillingEffect', 'postprandialKillingEffect', 'restingKillingEffect', 'fecundityReduction']}, 'attributes': {'mosquito': 'required'}, 'children': {'availabilityReduction': {'minOccurs': '0', 'maxOccurs': '1'}, 'preprandialKillingEffect': {'minOccurs': '1', 'maxOccurs': '1'}, 'postprandialKillingEffect': {'minOccurs': '1', 'maxOccurs': '1'}, 'restingKillingEffect': {'minOccurs': '0', 'maxOccurs': '1'}, 'fecundityReduction': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self.mosquito: OM237Anopheles._Mosquito = self._Mosquito(xml_tree=xml_tree, parent=self)
        self._availabilityReduction: OM239AvailabilityReduction | None = None
        self._preprandialKillingEffect: OM206PreprandialKillingEffect | None = None
        self._postprandialKillingEffect: OM208PostprandialKillingEffect | None = None
        self._restingKillingEffect: OM242RestingKillingEffect | None = None
        self._fecundityReduction: OM210FecundityReduction | None = None

    @property
    def availabilityReduction(self) -> 'OM239AvailabilityReduction':
        """Initialize 'availabilityReduction'."""
        if self._availabilityReduction is None:
            self._availabilityReduction = OM239AvailabilityReduction(xml_tree=self.xml_tree, parent=self)
        return self._availabilityReduction

    @property
    def preprandialKillingEffect(self) -> 'OM206PreprandialKillingEffect':
        """Initialize 'preprandialKillingEffect'."""
        if self._preprandialKillingEffect is None:
            self._preprandialKillingEffect = OM206PreprandialKillingEffect(xml_tree=self.xml_tree, parent=self)
        return self._preprandialKillingEffect

    @property
    def postprandialKillingEffect(self) -> 'OM208PostprandialKillingEffect':
        """Initialize 'postprandialKillingEffect'."""
        if self._postprandialKillingEffect is None:
            self._postprandialKillingEffect = OM208PostprandialKillingEffect(xml_tree=self.xml_tree, parent=self)
        return self._postprandialKillingEffect

    @property
    def restingKillingEffect(self) -> 'OM242RestingKillingEffect':
        """Initialize 'restingKillingEffect'."""
        if self._restingKillingEffect is None:
            self._restingKillingEffect = OM242RestingKillingEffect(xml_tree=self.xml_tree, parent=self)
        return self._restingKillingEffect

    @property
    def fecundityReduction(self) -> 'OM210FecundityReduction':
        """Initialize 'fecundityReduction'."""
        if self._fecundityReduction is None:
            self._fecundityReduction = OM210FecundityReduction(xml_tree=self.xml_tree, parent=self)
        return self._fecundityReduction

    class _Mosquito(AttributeNode):
        """Generated class for 'mosquito'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mosquito', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of the species/subspecies/variant.

name:	Species/subspecies/variant name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM238Timed(Node):
    """Generated class for 'timed'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='timed', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
List of timed vector population intervention deployment

name:	Vector population intervention deployment"""
        self._metadata: dict = {'minOccurs': '0', 'type': 'om:TimedBaseList', 'children_metadata': {'ordered': 'sequence', 'order': ['deploy']}, 'attributes': {}, 'children': {'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self._deploy: OM180Deploy | None = None

    @property
    def deploy(self) -> 'OM180Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM180Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy


class OM239AvailabilityReduction(Node):
    """Generated class for 'availabilityReduction'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='availabilityReduction', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Reduction in the availability rate, i. For example a value of 0 will result in no change; a value of 0.2 will reduce the availability to 0.8 of its initial value; and a value of 1 will set the availability to 0;"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'initial': 'required'}, 'children': {}}
        self.initial: OM239AvailabilityReduction._Initial = self._Initial(xml_tree=xml_tree, parent=self)

    class _Initial(AttributeNode):
        """Generated class for 'initial'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initial', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
min:	-1
max:	inf
name:	Initial proportion increase"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM240PreprandialKillingEffect(Node):
    """Generated class for 'preprandialKillingEffect'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='preprandialKillingEffect', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Reduction in the pre-prandial survival probability, PBi. For example a value of 0 will result in no change; a value of 0.2 will reduce PBi to 0.8 of its initial value; and a value of 1 will set PBi to 0;"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'initial': 'required'}, 'children': {}}
        self.initial: OM240PreprandialKillingEffect._Initial = self._Initial(xml_tree=xml_tree, parent=self)

    class _Initial(AttributeNode):
        """Generated class for 'initial'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initial', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
min:	-1
max:	inf
name:	Initial proportion increase"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM241PostprandialKillingEffect(Node):
    """Generated class for 'postprandialKillingEffect'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='postprandialKillingEffect', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Reduction in the post-prandial survival probability, PCi. For example a value of 0 will result in no change; a value of 0.2 will reduce PCi to 0.8 of its initial value; and a value of 1 will set PCi to 0;"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'initial': 'required'}, 'children': {}}
        self.initial: OM241PostprandialKillingEffect._Initial = self._Initial(xml_tree=xml_tree, parent=self)

    class _Initial(AttributeNode):
        """Generated class for 'initial'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initial', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
min:	-1
max:	inf
name:	Initial proportion increase"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM242RestingKillingEffect(Node):
    """Generated class for 'restingKillingEffect'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='restingKillingEffect', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Reduction in the survival probability of the resting period, PDi. For example a value of 0 will result in no change; a value of 0.2 will reduce PDi to 0.8 of its initial value; and a value of 1 will set PDi to 0;"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'initial': 'required'}, 'children': {}}
        self.initial: OM242RestingKillingEffect._Initial = self._Initial(xml_tree=xml_tree, parent=self)

    class _Initial(AttributeNode):
        """Generated class for 'initial'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initial', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
min:	-1
max:	inf
name:	Initial proportion increase"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM243FecundityReduction(Node):
    """Generated class for 'fecundityReduction'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='fecundityReduction', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Reduction in the number of fertile eggs laid by a mosquito after biting this type of host, relative to an unprotected human. For example a value of 0 will result in no change; a value of 0.2 will reduce the fecundity factor to 0.8 of its initial value; and a value of 1 will set the fecundity factor to 0;"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'initial': 'required'}, 'children': {}}
        self.initial: OM243FecundityReduction._Initial = self._Initial(xml_tree=xml_tree, parent=self)

    class _Initial(AttributeNode):
        """Generated class for 'initial'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initial', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """units:	dimensionless
min:	-1
max:	inf
name:	Initial proportion increase"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM244Description(Node):
    """Generated class for 'description'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='description', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': ['anopheles']}, 'attributes': {}, 'children': {'anopheles': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._anopheles: OM245Anopheles | None = None

    @property
    def anopheles(self) -> 'OM245Anopheles':
        """Initialize 'anopheles'."""
        if self._anopheles is None:
            self._anopheles = OM245Anopheles(xml_tree=self.xml_tree, parent=self)
        return self._anopheles


class OM245Anopheles(Node):
    """Generated class for 'anopheles'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='anopheles', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Descriptions of the effects of new non human hosts with per-species effects.
"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'type': 'om:NonHumanHostsVectorSpecies', 'children_metadata': {'ordered': 'all', 'order': ['mosqRelativeAvailabilityHuman', 'mosqProbBiting', 'mosqProbFindRestSite', 'mosqProbResting', 'hostFecundityFactor']}, 'attributes': {'mosquito': 'required'}, 'children': {'mosqRelativeAvailabilityHuman': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosqProbBiting': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosqProbFindRestSite': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosqProbResting': {'minOccurs': '1', 'maxOccurs': '1'}, 'hostFecundityFactor': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.mosquito: OM245Anopheles._Mosquito = self._Mosquito(xml_tree=xml_tree, parent=self)
        self._mosqRelativeAvailabilityHuman: OM248MosqRelativeAvailabilityHuman | None = None
        self._mosqProbBiting: OM249MosqProbBiting | None = None
        self._mosqProbFindRestSite: OM250MosqProbFindRestSite | None = None
        self._mosqProbResting: OM251MosqProbResting | None = None
        self._hostFecundityFactor: OM252HostFecundityFactor | None = None

    @property
    def mosqRelativeAvailabilityHuman(self) -> 'OM248MosqRelativeAvailabilityHuman':
        """Initialize 'mosqRelativeAvailabilityHuman'."""
        if self._mosqRelativeAvailabilityHuman is None:
            self._mosqRelativeAvailabilityHuman = OM248MosqRelativeAvailabilityHuman(xml_tree=self.xml_tree, parent=self)
        return self._mosqRelativeAvailabilityHuman

    @property
    def mosqProbBiting(self) -> 'OM249MosqProbBiting':
        """Initialize 'mosqProbBiting'."""
        if self._mosqProbBiting is None:
            self._mosqProbBiting = OM249MosqProbBiting(xml_tree=self.xml_tree, parent=self)
        return self._mosqProbBiting

    @property
    def mosqProbFindRestSite(self) -> 'OM250MosqProbFindRestSite':
        """Initialize 'mosqProbFindRestSite'."""
        if self._mosqProbFindRestSite is None:
            self._mosqProbFindRestSite = OM250MosqProbFindRestSite(xml_tree=self.xml_tree, parent=self)
        return self._mosqProbFindRestSite

    @property
    def mosqProbResting(self) -> 'OM251MosqProbResting':
        """Initialize 'mosqProbResting'."""
        if self._mosqProbResting is None:
            self._mosqProbResting = OM251MosqProbResting(xml_tree=self.xml_tree, parent=self)
        return self._mosqProbResting

    @property
    def hostFecundityFactor(self) -> 'OM252HostFecundityFactor':
        """Initialize 'hostFecundityFactor'."""
        if self._hostFecundityFactor is None:
            self._hostFecundityFactor = OM252HostFecundityFactor(xml_tree=self.xml_tree, parent=self)
        return self._hostFecundityFactor

    class _Mosquito(AttributeNode):
        """Generated class for 'mosquito'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mosquito', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of the species/subspecies/variant.

name:	Species/subspecies/variant name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM246Timed(Node):
    """Generated class for 'timed'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='timed', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
List of timed vector trap intervention deployment

name:	Vector trap intervention deployment"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'sequence', 'order': ['deploy']}, 'attributes': {}, 'children': {'deploy': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self._deploy: OM180Deploy | None = None

    @property
    def deploy(self) -> 'OM180Deploy':
        """Initialize 'deploy'."""
        if self._deploy is None:
            self._deploy = OM180Deploy(xml_tree=self.xml_tree, parent=self)
        return self._deploy


class OM247Deploy(Node):
    """Generated class for 'deploy'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='deploy', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'type': 'om:TimedBase', 'attributes': {'lifespan': 'required', 'time': 'required'}, 'children': {}}
        self.lifespan: OM247Deploy._Lifespan = self._Lifespan(xml_tree=xml_tree, parent=self)
        self.time: OM247Deploy._Time = self._Time(xml_tree=xml_tree, parent=self)

    class _Lifespan(AttributeNode):
        """Generated class for 'lifespan'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='lifespan', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Life of the trap until replaced or removed, e.g.
"73t" or "1y". After this time period, these traps
will be removed from the simulation.
New deployments do not automatically remove old
traps. Existing traps cannot be refurbished in the
model. It may make sense to make the end-of-life
coincide with a new deployment.

name:	Lifespan
units:	Steps or Days or Years"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Time(AttributeNode):
        """Generated class for 'time'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='time', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Element:
Time at which this deployment occurs.
See doc on intervention period and on monitoring/startDate for
details of how times work. Can be specified in steps, days,
years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).

name:	Time
units:	User defined (defauls to steps)
min:	0
Type:
Time at which this deployment occurs.
See doc on intervention period and on monitoring/startDate for
details of how times work. Can be specified in steps, days,
years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).

name:	Time
units:	User defined (defauls to steps)
min:	0"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM248MosqRelativeAvailabilityHuman(Node):
    """Generated class for 'mosqRelativeAvailabilityHuman'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqRelativeAvailabilityHuman', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Relative availability of the population of non-human hosts of
type i to other non-human hosts; the sum of this across all
non-human hosts must be 1.

units:	Proportion
 name:	Relative availability of non-human host (_i)"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM248MosqRelativeAvailabilityHuman._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM249MosqProbBiting(Node):
    """Generated class for 'mosqProbBiting'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqProbBiting', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability of mosquito successfully biting host
units:	Proportion
name:	Probability of mosquito successfully biting host"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM249MosqProbBiting._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM250MosqProbFindRestSite(Node):
    """Generated class for 'mosqProbFindRestSite'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqProbFindRestSite', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that the mosquito escapes host and finds a resting place after biting
units:	Proportion
name:	Probability that the mosquito escapes host and finds a resting place after biting"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM250MosqProbFindRestSite._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM251MosqProbResting(Node):
    """Generated class for 'mosqProbResting'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqProbResting', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability of mosquito successfully resting after finding a resting site
units:	Proportion
name:	Probability of mosquito successfully resting after finding a resting site"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM251MosqProbResting._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM252HostFecundityFactor(Node):
    """Generated class for 'hostFecundityFactor'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='hostFecundityFactor', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Multiplicative factor for the number of fertile eggs laid by a mosquito after biting this type of host, relative to an unprotected human.
units:	Proportion
name:	Probability of mosquito successfully resting after finding a resting site"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM252HostFecundityFactor._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM253Restriction(Node):
    """Generated class for 'restriction'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='restriction', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Specifies the mapping from genotype to phenotype. For each drug
type, if only one phenotype is present, restrictions need not be
specified, but otherwise restrictions must be specified.
The set of loci affecting phenotypes of this drug's action must be
fixed for any drug type. Each phenotype must list, for each of
these loci, a restriction to one or more alleles under the locus.

name:	Restrict phenotype applicability to certain alleles"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'type': 'om:PhenotypeRestriction', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'onLocus': 'required', 'toAllele': 'required'}, 'children': {}}
        self.onLocus: OM253Restriction._OnLocus = self._OnLocus(xml_tree=xml_tree, parent=self)
        self.toAllele: OM253Restriction._ToAllele = self._ToAllele(xml_tree=xml_tree, parent=self)

    class _OnLocus(AttributeNode):
        """Generated class for 'onLocus'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='onLocus', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A locus under which only a restricted set of alleles map to
this phenotype.

name:	Locus relevant to the mapping of alleles to this phenotype"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _ToAllele(AttributeNode):
        """Generated class for 'toAllele'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='toAllele', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
One allele of a locus upon which phenotype choice depends.
If multiple alleles under this locus should map to the same
phenotype, repeat the whole "restriction onLocus..." element.

name:	Alleles mapping to this phenotype"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM254InitialEfficacy(Node):
    """Generated class for 'initialEfficacy'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='initialEfficacy', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Mean efficacy values before decay (see efficacyB and decay parameter
descriptions for sampling and decay). The i-th value in this list
is used for the efficacy of the vaccine after the i-th dose. Where
more doses are given than there are values in this list, the last
value is repeated.

units:	dimensionless
min:	0
max:	1
name:	Initial mean efficacy"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'minOccurs': '1', 'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM254InitialEfficacy._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM255Treatments(Node):
    """Generated class for 'treatments'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='treatments', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A library of drug deployment schedules and dosages.

name:	Treatments library"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': ['schedule', 'dosages']}, 'attributes': {}, 'children': {'schedule': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'dosages': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._schedule: OM256Schedule | None = None
        self._dosages: OM257Dosages | None = None

    @property
    def schedule(self) -> 'OM256Schedule':
        """Initialize 'schedule'."""
        if self._schedule is None:
            self._schedule = OM256Schedule(xml_tree=self.xml_tree, parent=self)
        return self._schedule

    @property
    def dosages(self) -> 'OM257Dosages':
        """Initialize 'dosages'."""
        if self._dosages is None:
            self._dosages = OM257Dosages(xml_tree=self.xml_tree, parent=self)
        return self._dosages


class OM256Schedule(Node):
    """Generated class for 'schedule'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='schedule', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A schedule for the administration of drugs in a course of treatment.
Note that dose sizes are multiplied by some multiplier (see dosages)
and the times of all doses may be delayed.

name:	Schedule of doses taken as a course of treatment"""
        self._metadata: dict = {'type': 'om:PKPDSchedule', 'minOccurs': '1', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': ['medicate']}, 'attributes': {'name': 'required'}, 'children': {'medicate': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.name: OM256Schedule._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._medicate: OM260Medicate | None = None

    @property
    def medicate(self) -> 'OM260Medicate':
        """Initialize 'medicate'."""
        if self._medicate is None:
            self._medicate = OM260Medicate(xml_tree=self.xml_tree, parent=self)
        return self._medicate

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name for referring to this deployment schedule

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM257Dosages(Node):
    """Generated class for 'dosages'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='dosages', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A table for selecting a dose size. There are several ways this can
work: using the patient's age or body mass in a look-up table to get a
multplier, or directly using body mass as the multiplier.
The doses specified in "mg" in the treatment schedule are then
multiplied by this multiplier.

name:	Dosage table"""
        self._metadata: dict = {'type': 'om:PKPDDosages', 'minOccurs': '1', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': [['age', 'bodymass', 'multiply']]}, 'attributes': {'name': 'required'}, 'children': {'age': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'bodymass': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'multiply': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM257Dosages._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._age: OM261Age | None = None
        self._bodymass: OM262Bodymass | None = None
        self._multiply: OM263Multiply | None = None

    @property
    def age(self) -> 'OM261Age':
        """Initialize 'age'."""
        if self._age is None:
            self._age = OM261Age(xml_tree=self.xml_tree, parent=self)
        return self._age

    @property
    def bodymass(self) -> 'OM262Bodymass':
        """Initialize 'bodymass'."""
        if self._bodymass is None:
            self._bodymass = OM262Bodymass(xml_tree=self.xml_tree, parent=self)
        return self._bodymass

    @property
    def multiply(self) -> 'OM263Multiply':
        """Initialize 'multiply'."""
        if self._multiply is None:
            self._multiply = OM263Multiply(xml_tree=self.xml_tree, parent=self)
        return self._multiply

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name for referring to this dosage table

name:	Name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM258Drugs(Node):
    """Generated class for 'drugs'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='drugs', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A library of drug PK/PD data.

name:	Drug library"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': ['drug']}, 'attributes': {}, 'children': {'drug': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._drug: OM259Drug | None = None

    @property
    def drug(self) -> 'OM259Drug':
        """Initialize 'drug'."""
        if self._drug is None:
            self._drug = OM259Drug(xml_tree=self.xml_tree, parent=self)
        return self._drug


class OM259Drug(Node):
    """Generated class for 'drug'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='drug', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A drug description with PK/PD parameters.

name:	Drug parameters"""
        self._metadata: dict = {'type': 'om:PKPDDrug', 'minOccurs': '1', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': ['PD', 'PK']}, 'attributes': {'abbrev': 'required'}, 'children': {'PD': {'minOccurs': '1', 'maxOccurs': '1'}, 'PK': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.abbrev: OM259Drug._Abbrev = self._Abbrev(xml_tree=xml_tree, parent=self)
        self._PD: OM264PD | None = None
        self._PK: OM266PK | None = None

    @property
    def PD(self) -> 'OM264PD':
        """Initialize 'PD'."""
        if self._PD is None:
            self._PD = OM264PD(xml_tree=self.xml_tree, parent=self)
        return self._PD

    @property
    def PK(self) -> 'OM266PK':
        """Initialize 'PK'."""
        if self._PK is None:
            self._PK = OM266PK(xml_tree=self.xml_tree, parent=self)
        return self._PK

    class _Abbrev(AttributeNode):
        """Generated class for 'abbrev'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='abbrev', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """"""
            self._metadata: dict = {'use': 'required', 'type': 'xs:string', 'children_metadata': {'ordered': None, 'order': []}}


class OM260Medicate(Node):
    """Generated class for 'medicate'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='medicate', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'type': 'om:PKPDMedication', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'drug': 'required', 'mg': 'required', 'hour': 'required'}, 'children': {}}
        self.drug: OM260Medicate._Drug = self._Drug(xml_tree=xml_tree, parent=self)
        self.mg: OM260Medicate._Mg = self._Mg(xml_tree=xml_tree, parent=self)
        self.hour: OM260Medicate._Hour = self._Hour(xml_tree=xml_tree, parent=self)

    class _Drug(AttributeNode):
        """Generated class for 'drug'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='drug', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Abbreviated name of drug compound

name:	drug"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Mg(AttributeNode):
        """Generated class for 'mg'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mg', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Quantity of drug compound in mg per *something*. A separate dosage
table must be used when medicating, which may specify multipliers of
this number based on patient age or weight.

units:	mg per something
name:	Drug dose (mg with multiplier)"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Hour(AttributeNode):
        """Generated class for 'hour'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='hour', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Number of hours past start of timestep this drug dose is administered
at (first dose should be at hour 0).

units:	Hours
min:	0
name:	Time of administration"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM261Age(Node):
    """Generated class for 'age'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='age', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Select dose multiplier from a look-up table using the patient's age.

name:	Look-up table (age)
Type:
A look-up table which uses patient age (in years) or weight (in kg) to
find a multiplier.

name:	Age/weight range"""
        self._metadata: dict = {'type': 'om:PKPDDosageRange', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'lowerbound': 'required', 'dose_mult': 'required'}, 'children': {}}
        self.lowerbound: OM261Age._Lowerbound = self._Lowerbound(xml_tree=xml_tree, parent=self)
        self.dose_mult: OM261Age._Dose_mult = self._Dose_mult(xml_tree=xml_tree, parent=self)

    class _Lowerbound(AttributeNode):
        """Generated class for 'lowerbound'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='lowerbound', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """name:	Lower bound (inclusive)
min:	0
units:	years or kg"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Dose_mult(AttributeNode):
        """Generated class for 'dose_mult'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='dose_mult', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The dose size given in the schedule (in "mg") is multiplied by
this value for patients falling into this range when this
dosage table is used.

name:	Dose multiplier
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM262Bodymass(Node):
    """Generated class for 'bodymass'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='bodymass', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Select dose multiplier from a look-up table using the patient's body mass.

name:	Look-up table (weight)
Type:
A look-up table which uses patient age (in years) or weight (in kg) to
find a multiplier.

name:	Age/weight range"""
        self._metadata: dict = {'type': 'om:PKPDDosageRange', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'lowerbound': 'required', 'dose_mult': 'required'}, 'children': {}}
        self.lowerbound: OM262Bodymass._Lowerbound = self._Lowerbound(xml_tree=xml_tree, parent=self)
        self.dose_mult: OM262Bodymass._Dose_mult = self._Dose_mult(xml_tree=xml_tree, parent=self)

    class _Lowerbound(AttributeNode):
        """Generated class for 'lowerbound'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='lowerbound', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """name:	Lower bound (inclusive)
min:	0
units:	years or kg"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Dose_mult(AttributeNode):
        """Generated class for 'dose_mult'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='dose_mult', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The dose size given in the schedule (in "mg") is multiplied by
this value for patients falling into this range when this
dosage table is used.

name:	Dose multiplier
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM263Multiply(Node):
    """Generated class for 'multiply'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='multiply', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Multiply the dose by some quantity, such as patient weight.

name:	Multiply dose"""
        self._metadata: dict = {'maxOccurs': '1', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'by': 'required'}, 'children': {}}
        self.by: OM263Multiply._By = self._By(xml_tree=xml_tree, parent=self)

    class _By(AttributeNode):
        """Generated class for 'by'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='by', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Quantity to multiply the dose by. Only option is "kg"
(patient weight in kg).

name:	By what?"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['kg']}, 'type': 'xs:string'}


class OM264PD(Node):
    """Generated class for 'PD'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='PD', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': ['phenotype']}, 'attributes': {'locus': 'optional'}, 'children': {'phenotype': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.locus: OM264PD._Locus = self._Locus(xml_tree=xml_tree, parent=self)
        self._phenotype: OM265Phenotype | None = None

    @property
    def phenotype(self) -> 'OM265Phenotype':
        """Initialize 'phenotype'."""
        if self._phenotype is None:
            self._phenotype = OM265Phenotype(xml_tree=self.xml_tree, parent=self)
        return self._phenotype

    class _Locus(AttributeNode):
        """Generated class for 'locus'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='locus', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Optional; if present specifies the locus corresponding to this
drug's PD phenotypes: each phenotype must then match one of
that locus's alleles. Otherwise the drug should specify only
one phenotype.
There is currently a one-to-many correspondance between loci
and drugs.

name:	Locus"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM265Phenotype(Node):
    """Generated class for 'phenotype'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='phenotype', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Pharmaco-Dynamic parameters for some resistance phenotype.
To model resistance to this drug, describe multiple infection
phenotypes (with respect to these PD parameters) and list one
or more "restrict" elements for each phenotype.
Loci are specified elsewhere. Multiple loci may influence the
action of a single drug and each locus may influence multiple
drugs.

name:	PD parameters for some allele / resistance phenotype"""
        self._metadata: dict = {'type': 'om:Phenotype', 'minOccurs': '1', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': ['restriction', 'max_killing_rate', 'IC50', 'slope']}, 'attributes': {'name': 'optional'}, 'children': {'restriction': {'minOccurs': '0', 'maxOccurs': 'unbounded'}, 'max_killing_rate': {'minOccurs': '1', 'maxOccurs': '1'}, 'IC50': {'minOccurs': '1', 'maxOccurs': '1'}, 'slope': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM265Phenotype._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._restriction: OM253Restriction | None = None
        self._max_killing_rate: OM285Max_killing_rate | None = None
        self._IC50: OM286IC50 | None = None
        self._slope: OM287Slope | None = None

    @property
    def restriction(self) -> 'OM253Restriction':
        """Initialize 'restriction'."""
        if self._restriction is None:
            self._restriction = OM253Restriction(xml_tree=self.xml_tree, parent=self)
        return self._restriction

    @property
    def max_killing_rate(self) -> 'OM285Max_killing_rate':
        """Initialize 'max_killing_rate'."""
        if self._max_killing_rate is None:
            self._max_killing_rate = OM285Max_killing_rate(xml_tree=self.xml_tree, parent=self)
        return self._max_killing_rate

    @property
    def IC50(self) -> 'OM286IC50':
        """Initialize 'IC50'."""
        if self._IC50 is None:
            self._IC50 = OM286IC50(xml_tree=self.xml_tree, parent=self)
        return self._IC50

    @property
    def slope(self) -> 'OM287Slope':
        """Initialize 'slope'."""
        if self._slope is None:
            self._slope = OM287Slope(xml_tree=self.xml_tree, parent=self)
        return self._slope

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of the phenotype; for documentation use only.

name:	Name of phenotype"""
            self._metadata: dict = {'use': 'optional', 'type': 'xs:string', 'children_metadata': {'ordered': None, 'order': []}}


class OM266PK(Node):
    """Generated class for 'PK'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='PK', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': ['negligible_concentration', ['half_life', ['k', 'm_exponent']], 'k_a', 'conversion', 'vol_dist', 'compartment2', 'compartment3']}, 'attributes': {}, 'children': {'negligible_concentration': {'minOccurs': '1', 'maxOccurs': '1'}, 'half_life': {'minOccurs': '1', 'maxOccurs': '1'}, 'k': {'minOccurs': '1', 'maxOccurs': '1'}, 'm_exponent': {'minOccurs': '1', 'maxOccurs': '1'}, 'k_a': {'minOccurs': '0', 'maxOccurs': '1'}, 'conversion': {'minOccurs': '0', 'maxOccurs': '1'}, 'vol_dist': {'minOccurs': '1', 'maxOccurs': '1'}, 'compartment2': {'minOccurs': '0', 'maxOccurs': '1'}, 'compartment3': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self._negligible_concentration: OM267Negligible_concentration | None = None
        self._half_life: OM268Half_life | None = None
        self._k: OM269K | None = None
        self._m_exponent: OM270M_exponent | None = None
        self._k_a: OM271K_a | None = None
        self._conversion: OM272Conversion | None = None
        self._vol_dist: OM277Vol_dist | None = None
        self._compartment2: OM278Compartment2 | None = None
        self._compartment3: OM281Compartment3 | None = None

    @property
    def negligible_concentration(self) -> 'OM267Negligible_concentration':
        """Initialize 'negligible_concentration'."""
        if self._negligible_concentration is None:
            self._negligible_concentration = OM267Negligible_concentration(xml_tree=self.xml_tree, parent=self)
        return self._negligible_concentration

    @property
    def half_life(self) -> 'OM268Half_life':
        """Initialize 'half_life'."""
        if self._half_life is None:
            self._half_life = OM268Half_life(xml_tree=self.xml_tree, parent=self)
        return self._half_life

    @property
    def k(self) -> 'OM269K':
        """Initialize 'k'."""
        if self._k is None:
            self._k = OM269K(xml_tree=self.xml_tree, parent=self)
        return self._k

    @property
    def m_exponent(self) -> 'OM270M_exponent':
        """Initialize 'm_exponent'."""
        if self._m_exponent is None:
            self._m_exponent = OM270M_exponent(xml_tree=self.xml_tree, parent=self)
        return self._m_exponent

    @property
    def k_a(self) -> 'OM271K_a':
        """Initialize 'k_a'."""
        if self._k_a is None:
            self._k_a = OM271K_a(xml_tree=self.xml_tree, parent=self)
        return self._k_a

    @property
    def conversion(self) -> 'OM272Conversion':
        """Initialize 'conversion'."""
        if self._conversion is None:
            self._conversion = OM272Conversion(xml_tree=self.xml_tree, parent=self)
        return self._conversion

    @property
    def vol_dist(self) -> 'OM277Vol_dist':
        """Initialize 'vol_dist'."""
        if self._vol_dist is None:
            self._vol_dist = OM277Vol_dist(xml_tree=self.xml_tree, parent=self)
        return self._vol_dist

    @property
    def compartment2(self) -> 'OM278Compartment2':
        """Initialize 'compartment2'."""
        if self._compartment2 is None:
            self._compartment2 = OM278Compartment2(xml_tree=self.xml_tree, parent=self)
        return self._compartment2

    @property
    def compartment3(self) -> 'OM281Compartment3':
        """Initialize 'compartment3'."""
        if self._compartment3 is None:
            self._compartment3 = OM281Compartment3(xml_tree=self.xml_tree, parent=self)
        return self._compartment3


class OM267Negligible_concentration(ElementNode):
    """Generated class for 'negligible_concentration'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='negligible_concentration', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Concentration below which drug's effects are deemed negligible and can
be removed from simulation.

units:	mg/l
min:	0
name:	Drug concentration considered negligible"""
        self._metadata: dict = {'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM268Half_life(ElementNode):
    """Generated class for 'half_life'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='half_life', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Used to calculate elimination rate , calculated as
 = ln(2) / half_life. The basic form of decay is
C(t) = C0 * exp(-*t).
Alternatively, elimination rate can be specified via k
and m_exponent.

units:	days
min:	0
name:	drug half-life"""
        self._metadata: dict = {'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM269K(Node):
    """Generated class for 'k'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='k', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Constant used to calculate the elimination rate , which
is calculated as  = k / (body_mass ^ m_exponent), where
body_mass is the patient's weight in kg and m_exponent is
the next parameter. The basic form of decay is
C(t) = C0 * exp(-*t).
If CV > 0, k is sampled per-human from the log-normal
distribution: ln N( ln(mean) - ^2 / 2, ^2).
Alternatively, elimination rate can be specified via half_life.

units:	day^-1
min:	0
name:	Constant associated with elimination rate (k)
Type:
A parameter with optional log-normal heterogeneity.
The mean value must be specified. Optionally, a distribution ("distr")
and coefficient of variation ("CV") may be specified.

name:	Sampled value
Base Type:
A parameter with optional heterogeneity.
The mean cannot be specified (unless this type is extended).
Optionally, a distribution ("distr") and coefficient of variation ("CV") may be specified.

name:	Sampled value (log normal)"""
        self._metadata: dict = {'type': 'om:SampledValueLN', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'CV': 'optional', 'distr': 'optional', 'variance': 'optional'}, 'children': {}}
        self.mean: OM269K._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.CV: OM269K._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.distr: OM269K._Distr = self._Distr(xml_tree=xml_tree, parent=self)
        self.variance: OM269K._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) coefficient of variation.
This value must be specified when a (non-constant) distribution is used. 
Note: since version 46, variance can be used instead.
Note that specifying CV="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"lognormal": the parameter is sampled from a log-normal distribution.
Note that the "mean" and "CV" values are linear (arithmetic) properties
of the distribution and not log-space properties.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'lognormal', 'gamma']}, 'type': 'xs:string'}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The variance parameter of the distirbution.
This value can be specified when a (non-constant) distribution is used.
Note that specifying variance="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM270M_exponent(ElementNode):
    """Generated class for 'm_exponent'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='m_exponent', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Constant used to calculate the elimination rate , which
is calculated as  = k / (body_mass ^ m_exponent), where
body_mass is the patient's weight in kg and k is the
previous parameter. The basic form of decay is
C(t) = C0 * exp(-*t).
Alternatively, elimination rate can be specified via half_life.
Note that in the case of a conversion model, this applies
to *both* the elimination and the conversion rates.

units:	day^-1
min:	0
name:	Constant associated with elimination rate (m_exponent)"""
        self._metadata: dict = {'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM271K_a(Node):
    """Generated class for 'k_a'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='k_a', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Absorption rate parameter. Not allowed for one compartment
models, but required for two and three compartment models and
one compartment with conversion model (for the parent drug
only).

name:	Absorption rate constant (k_a)
min:	0
Type:
A parameter with optional log-normal heterogeneity.
The mean value must be specified. Optionally, a distribution ("distr")
and coefficient of variation ("CV") may be specified.

name:	Sampled value
Base Type:
A parameter with optional heterogeneity.
The mean cannot be specified (unless this type is extended).
Optionally, a distribution ("distr") and coefficient of variation ("CV") may be specified.

name:	Sampled value (log normal)"""
        self._metadata: dict = {'type': 'om:SampledValueLN', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'CV': 'optional', 'distr': 'optional', 'variance': 'optional'}, 'children': {}}
        self.mean: OM271K_a._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.CV: OM271K_a._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.distr: OM271K_a._Distr = self._Distr(xml_tree=xml_tree, parent=self)
        self.variance: OM271K_a._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) coefficient of variation.
This value must be specified when a (non-constant) distribution is used. 
Note: since version 46, variance can be used instead.
Note that specifying CV="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"lognormal": the parameter is sampled from a log-normal distribution.
Note that the "mean" and "CV" values are linear (arithmetic) properties
of the distribution and not log-space properties.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'lognormal', 'gamma']}, 'type': 'xs:string'}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The variance parameter of the distirbution.
This value can be specified when a (non-constant) distribution is used.
Note that specifying variance="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM272Conversion(Node):
    """Generated class for 'conversion'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='conversion', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Configures the parent drug in a conversion model.
To use a conversion model, the parent drug should have this
section defined as well as half-life or k (direct
elimination; this may be zero) and k_a (absorption rate;
this may be large).
The metabolite drug should define half-life or k (elimination
of metabolite), but not k_a (absorption rate) or this section
(conversion). It is not possible for the metabolite to itself
undergo conversion with the current models.

name:	Conversion parameters (parent drug)"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'all', 'order': ['metabolite', 'rate', 'molRatio', 'IC50_log_correlation']}, 'attributes': {}, 'children': {'metabolite': {'minOccurs': '1', 'maxOccurs': '1'}, 'rate': {'minOccurs': '1', 'maxOccurs': '1'}, 'molRatio': {'minOccurs': '1', 'maxOccurs': '1'}, 'IC50_log_correlation': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._metabolite: OM273Metabolite | None = None
        self._rate: OM274Rate | None = None
        self._molRatio: OM275MolRatio | None = None
        self._IC50_log_correlation: OM276IC50_log_correlation | None = None

    @property
    def metabolite(self) -> 'OM273Metabolite':
        """Initialize 'metabolite'."""
        if self._metabolite is None:
            self._metabolite = OM273Metabolite(xml_tree=self.xml_tree, parent=self)
        return self._metabolite

    @property
    def rate(self) -> 'OM274Rate':
        """Initialize 'rate'."""
        if self._rate is None:
            self._rate = OM274Rate(xml_tree=self.xml_tree, parent=self)
        return self._rate

    @property
    def molRatio(self) -> 'OM275MolRatio':
        """Initialize 'molRatio'."""
        if self._molRatio is None:
            self._molRatio = OM275MolRatio(xml_tree=self.xml_tree, parent=self)
        return self._molRatio

    @property
    def IC50_log_correlation(self) -> 'OM276IC50_log_correlation':
        """Initialize 'IC50_log_correlation'."""
        if self._IC50_log_correlation is None:
            self._IC50_log_correlation = OM276IC50_log_correlation(xml_tree=self.xml_tree, parent=self)
        return self._IC50_log_correlation


class OM273Metabolite(ElementNode):
    """Generated class for 'metabolite'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='metabolite', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The abbreviation of the metabolite drug (e.g. "DHA" or
"DHA_AR").

name:	Metabolite drug (abbreviation)"""
        self._metadata: dict = {'type': 'xs:string', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM274Rate(Node):
    """Generated class for 'rate'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='rate', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Rate of conversion of parent drug to metabolite.

name:	Rate of conversion
unit:	Per day
Type:
A parameter with optional log-normal heterogeneity.
The mean value must be specified. Optionally, a distribution ("distr")
and coefficient of variation ("CV") may be specified.

name:	Sampled value
Base Type:
A parameter with optional heterogeneity.
The mean cannot be specified (unless this type is extended).
Optionally, a distribution ("distr") and coefficient of variation ("CV") may be specified.

name:	Sampled value (log normal)"""
        self._metadata: dict = {'type': 'om:SampledValueLN', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'CV': 'optional', 'distr': 'optional', 'variance': 'optional'}, 'children': {}}
        self.mean: OM274Rate._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.CV: OM274Rate._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.distr: OM274Rate._Distr = self._Distr(xml_tree=xml_tree, parent=self)
        self.variance: OM274Rate._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) coefficient of variation.
This value must be specified when a (non-constant) distribution is used. 
Note: since version 46, variance can be used instead.
Note that specifying CV="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"lognormal": the parameter is sampled from a log-normal distribution.
Note that the "mean" and "CV" values are linear (arithmetic) properties
of the distribution and not log-space properties.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'lognormal', 'gamma']}, 'type': 'xs:string'}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The variance parameter of the distirbution.
This value can be specified when a (non-constant) distribution is used.
Note that specifying variance="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM275MolRatio(ElementNode):
    """Generated class for 'molRatio'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='molRatio', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Ratio of molecular weights: molecular weight of the
metabolite divided by molecular weight of the parent.

name:	Molecular weight ratio
unit:	unitless"""
        self._metadata: dict = {'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM276IC50_log_correlation(ElementNode):
    """Generated class for 'IC50_log_correlation'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='IC50_log_correlation', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The IC50 values of parent and metabolite drugs may be
sampled from the log-normal distribution (if CV is greater than 0).
This parameter controls correlation between these samples,
measured in log-space.
If this value is 1, samples are fully correlated: a single z-score is
used to calculate both samples. If this is 0, two independent
samples are used.
Values between 0 and 1 (partial correlation) are supported;
in this case IC50 values are sampled such that
cor(log(x), log(y)) matches this value (where x, y are parent and
metabolite IC50 values).

name:	IC50 log correlation
min:	0
max:	1"""
        self._metadata: dict = {'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM277Vol_dist(Node):
    """Generated class for 'vol_dist'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='vol_dist', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Volume of Distribution.
If CV > 0 this is sampled from a log-normal distribution.

units:	l/kg
min:	0
name:	Volume of Distribution (Vd)
Type:
A parameter with optional log-normal heterogeneity.
The mean value must be specified. Optionally, a distribution ("distr")
and coefficient of variation ("CV") may be specified.

name:	Sampled value
Base Type:
A parameter with optional heterogeneity.
The mean cannot be specified (unless this type is extended).
Optionally, a distribution ("distr") and coefficient of variation ("CV") may be specified.

name:	Sampled value (log normal)"""
        self._metadata: dict = {'type': 'om:SampledValueLN', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'CV': 'optional', 'distr': 'optional', 'variance': 'optional'}, 'children': {}}
        self.mean: OM277Vol_dist._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.CV: OM277Vol_dist._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.distr: OM277Vol_dist._Distr = self._Distr(xml_tree=xml_tree, parent=self)
        self.variance: OM277Vol_dist._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) coefficient of variation.
This value must be specified when a (non-constant) distribution is used. 
Note: since version 46, variance can be used instead.
Note that specifying CV="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"lognormal": the parameter is sampled from a log-normal distribution.
Note that the "mean" and "CV" values are linear (arithmetic) properties
of the distribution and not log-space properties.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'lognormal', 'gamma']}, 'type': 'xs:string'}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The variance parameter of the distirbution.
This value can be specified when a (non-constant) distribution is used.
Note that specifying variance="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM278Compartment2(Node):
    """Generated class for 'compartment2'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='compartment2', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Optional element specifying conversion parameters to- and
from- a second compartment.

name:	Second compartment parameters"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'all', 'order': ['k12', 'k21']}, 'attributes': {}, 'children': {'k12': {'minOccurs': '1', 'maxOccurs': '1'}, 'k21': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._k12: OM279K12 | None = None
        self._k21: OM280K21 | None = None

    @property
    def k12(self) -> 'OM279K12':
        """Initialize 'k12'."""
        if self._k12 is None:
            self._k12 = OM279K12(xml_tree=self.xml_tree, parent=self)
        return self._k12

    @property
    def k21(self) -> 'OM280K21':
        """Initialize 'k21'."""
        if self._k21 is None:
            self._k21 = OM280K21(xml_tree=self.xml_tree, parent=self)
        return self._k21


class OM279K12(Node):
    """Generated class for 'k12'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='k12', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Absorption rate from the central compartment to the
first periphery compartment (2).
It is sampled per-patient when CV > 0.

units:	day^-1
min:	0
name:	Absorption rate to compartment 2 (k12)
Type:
A parameter with optional log-normal heterogeneity.
The mean value must be specified. Optionally, a distribution ("distr")
and coefficient of variation ("CV") may be specified.

name:	Sampled value
Base Type:
A parameter with optional heterogeneity.
The mean cannot be specified (unless this type is extended).
Optionally, a distribution ("distr") and coefficient of variation ("CV") may be specified.

name:	Sampled value (log normal)"""
        self._metadata: dict = {'type': 'om:SampledValueLN', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'CV': 'optional', 'distr': 'optional', 'variance': 'optional'}, 'children': {}}
        self.mean: OM279K12._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.CV: OM279K12._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.distr: OM279K12._Distr = self._Distr(xml_tree=xml_tree, parent=self)
        self.variance: OM279K12._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) coefficient of variation.
This value must be specified when a (non-constant) distribution is used. 
Note: since version 46, variance can be used instead.
Note that specifying CV="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"lognormal": the parameter is sampled from a log-normal distribution.
Note that the "mean" and "CV" values are linear (arithmetic) properties
of the distribution and not log-space properties.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'lognormal', 'gamma']}, 'type': 'xs:string'}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The variance parameter of the distirbution.
This value can be specified when a (non-constant) distribution is used.
Note that specifying variance="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM280K21(Node):
    """Generated class for 'k21'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='k21', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Absorption rate from the first periphery compartment
(2) to the central compartment.
It is sampled per-patient when CV > 0.

units:	day^-1
min:	0
name:	Absorption rate from compartment 2 (k21)
Type:
A parameter with optional log-normal heterogeneity.
The mean value must be specified. Optionally, a distribution ("distr")
and coefficient of variation ("CV") may be specified.

name:	Sampled value
Base Type:
A parameter with optional heterogeneity.
The mean cannot be specified (unless this type is extended).
Optionally, a distribution ("distr") and coefficient of variation ("CV") may be specified.

name:	Sampled value (log normal)"""
        self._metadata: dict = {'type': 'om:SampledValueLN', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'CV': 'optional', 'distr': 'optional', 'variance': 'optional'}, 'children': {}}
        self.mean: OM280K21._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.CV: OM280K21._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.distr: OM280K21._Distr = self._Distr(xml_tree=xml_tree, parent=self)
        self.variance: OM280K21._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) coefficient of variation.
This value must be specified when a (non-constant) distribution is used. 
Note: since version 46, variance can be used instead.
Note that specifying CV="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"lognormal": the parameter is sampled from a log-normal distribution.
Note that the "mean" and "CV" values are linear (arithmetic) properties
of the distribution and not log-space properties.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'lognormal', 'gamma']}, 'type': 'xs:string'}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The variance parameter of the distirbution.
This value can be specified when a (non-constant) distribution is used.
Note that specifying variance="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM281Compartment3(Node):
    """Generated class for 'compartment3'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='compartment3', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Optional element specifying conversion parameters to- and
from- a third compartment.

name:	Third compartment parameters"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'all', 'order': ['k13', 'k31']}, 'attributes': {}, 'children': {'k13': {'minOccurs': '1', 'maxOccurs': '1'}, 'k31': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._k13: OM282K13 | None = None
        self._k31: OM283K31 | None = None

    @property
    def k13(self) -> 'OM282K13':
        """Initialize 'k13'."""
        if self._k13 is None:
            self._k13 = OM282K13(xml_tree=self.xml_tree, parent=self)
        return self._k13

    @property
    def k31(self) -> 'OM283K31':
        """Initialize 'k31'."""
        if self._k31 is None:
            self._k31 = OM283K31(xml_tree=self.xml_tree, parent=self)
        return self._k31


class OM282K13(Node):
    """Generated class for 'k13'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='k13', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Absorption rate from the central compartment to the
second periphery compartment (3).
It is sampled per-patient when CV > 0.

units:	day^-1
min:	0
name:	Absorption rate to compartment 3 (k13)
Type:
A parameter with optional log-normal heterogeneity.
The mean value must be specified. Optionally, a distribution ("distr")
and coefficient of variation ("CV") may be specified.

name:	Sampled value
Base Type:
A parameter with optional heterogeneity.
The mean cannot be specified (unless this type is extended).
Optionally, a distribution ("distr") and coefficient of variation ("CV") may be specified.

name:	Sampled value (log normal)"""
        self._metadata: dict = {'type': 'om:SampledValueLN', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'CV': 'optional', 'distr': 'optional', 'variance': 'optional'}, 'children': {}}
        self.mean: OM282K13._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.CV: OM282K13._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.distr: OM282K13._Distr = self._Distr(xml_tree=xml_tree, parent=self)
        self.variance: OM282K13._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) coefficient of variation.
This value must be specified when a (non-constant) distribution is used. 
Note: since version 46, variance can be used instead.
Note that specifying CV="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"lognormal": the parameter is sampled from a log-normal distribution.
Note that the "mean" and "CV" values are linear (arithmetic) properties
of the distribution and not log-space properties.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'lognormal', 'gamma']}, 'type': 'xs:string'}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The variance parameter of the distirbution.
This value can be specified when a (non-constant) distribution is used.
Note that specifying variance="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM283K31(Node):
    """Generated class for 'k31'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='k31', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Absorption rate from the second periphery compartment
(3) to the central compartment.
It is sampled per-patient when CV > 0.

units:	day^-1
min:	0
name:	Absorption rate from compartment 3 (k31)
Type:
A parameter with optional log-normal heterogeneity.
The mean value must be specified. Optionally, a distribution ("distr")
and coefficient of variation ("CV") may be specified.

name:	Sampled value
Base Type:
A parameter with optional heterogeneity.
The mean cannot be specified (unless this type is extended).
Optionally, a distribution ("distr") and coefficient of variation ("CV") may be specified.

name:	Sampled value (log normal)"""
        self._metadata: dict = {'type': 'om:SampledValueLN', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'CV': 'optional', 'distr': 'optional', 'variance': 'optional'}, 'children': {}}
        self.mean: OM283K31._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.CV: OM283K31._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.distr: OM283K31._Distr = self._Distr(xml_tree=xml_tree, parent=self)
        self.variance: OM283K31._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) coefficient of variation.
This value must be specified when a (non-constant) distribution is used. 
Note: since version 46, variance can be used instead.
Note that specifying CV="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"lognormal": the parameter is sampled from a log-normal distribution.
Note that the "mean" and "CV" values are linear (arithmetic) properties
of the distribution and not log-space properties.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'lognormal', 'gamma']}, 'type': 'xs:string'}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The variance parameter of the distirbution.
This value can be specified when a (non-constant) distribution is used.
Note that specifying variance="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM284Restriction(Node):
    """Generated class for 'restriction'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='restriction', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Specifies the mapping from genotype to phenotype. For each drug
type, if only one phenotype is present, restrictions need not be
specified, but otherwise restrictions must be specified.
The set of loci affecting phenotypes of this drug's action must be
fixed for any drug type. Each phenotype must list, for each of
these loci, a restriction to one or more alleles under the locus.

name:	Restrict phenotype applicability to certain alleles"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'onLocus': 'required', 'toAllele': 'required'}, 'children': {}}
        self.onLocus: OM284Restriction._OnLocus = self._OnLocus(xml_tree=xml_tree, parent=self)
        self.toAllele: OM284Restriction._ToAllele = self._ToAllele(xml_tree=xml_tree, parent=self)

    class _OnLocus(AttributeNode):
        """Generated class for 'onLocus'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='onLocus', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A locus under which only a restricted set of alleles map to
this phenotype.

name:	Locus relevant to the mapping of alleles to this phenotype"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _ToAllele(AttributeNode):
        """Generated class for 'toAllele'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='toAllele', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
One allele of a locus upon which phenotype choice depends.
If multiple alleles under this locus should map to the same
phenotype, repeat the whole "restriction onLocus..." element.

name:	Alleles mapping to this phenotype"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM285Max_killing_rate(ElementNode):
    """Generated class for 'max_killing_rate'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='max_killing_rate', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
k1  Maximal parasite killing rate.

units:	1/days
min:	0
name:	Maximal parasite killing rate"""
        self._metadata: dict = {'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM286IC50(Node):
    """Generated class for 'IC50'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='IC50', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Half maximal effect concentration.
If CV > 0, the IC50 is sampled from a log-normal distribution.

units:	mg/l
min:	0
name:	IC50
Type:
A parameter with optional log-normal heterogeneity.
The mean value must be specified. Optionally, a distribution ("distr")
and coefficient of variation ("CV") may be specified.

name:	Sampled value
Base Type:
A parameter with optional heterogeneity.
The mean cannot be specified (unless this type is extended).
Optionally, a distribution ("distr") and coefficient of variation ("CV") may be specified.

name:	Sampled value (log normal)"""
        self._metadata: dict = {'type': 'om:SampledValueLN', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'CV': 'optional', 'distr': 'optional', 'variance': 'optional'}, 'children': {}}
        self.mean: OM286IC50._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.CV: OM286IC50._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.distr: OM286IC50._Distr = self._Distr(xml_tree=xml_tree, parent=self)
        self.variance: OM286IC50._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) coefficient of variation.
This value must be specified when a (non-constant) distribution is used. 
Note: since version 46, variance can be used instead.
Note that specifying CV="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"lognormal": the parameter is sampled from a log-normal distribution.
Note that the "mean" and "CV" values are linear (arithmetic) properties
of the distribution and not log-space properties.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'lognormal', 'gamma']}, 'type': 'xs:string'}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The variance parameter of the distirbution.
This value can be specified when a (non-constant) distribution is used.
Note that specifying variance="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM287Slope(ElementNode):
    """Generated class for 'slope'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='slope', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
n  Slope of the concentration effect curve

units:	dimensionless
name:	Slope of effect curve"""
        self._metadata: dict = {'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM288Deploy(Node):
    """Generated class for 'deploy'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='deploy', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': 'sequence', 'order': ['component']}, 'attributes': {'maxAge': 'optional', 'minAge': '', 'p': ''}, 'children': {'component': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.maxAge: OM288Deploy._MaxAge = self._MaxAge(xml_tree=xml_tree, parent=self)
        self.minAge: OM288Deploy._MinAge = self._MinAge(xml_tree=xml_tree, parent=self)
        self.p: OM288Deploy._P = self._P(xml_tree=xml_tree, parent=self)
        self._component: OM154Component | None = None

    @property
    def component(self) -> 'OM154Component':
        """Initialize 'component'."""
        if self._component is None:
            self._component = OM154Component(xml_tree=self.xml_tree, parent=self)
        return self._component

    class _MaxAge(AttributeNode):
        """Generated class for 'maxAge'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='maxAge', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Maximum age of eligible humans (defaults to no limit).
Input is rounded to the nearest time step.

units:	Years
min:	0
name:	Maximum age of eligible humans"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _MinAge(AttributeNode):
        """Generated class for 'minAge'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='minAge', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Minimum age of eligible humans (defaults to 0).
Input is rounded to the nearest time step.

units:	Years
min:	0
name:	Minimum age of eligible humans"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}

    class _P(AttributeNode):
        """Generated class for 'p'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='p', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Probability of this list of components being deployed, given
that other constraints are met.

units:	dimensionless
min:	0
max:	1
name:	Probability of delivery to eligible humans"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}


class OM289Component(Node):
    """Generated class for 'component'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='component', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The list of components deployed to eligible humans.

name:	Component to be deployed"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'type': 'om:Component', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'id': 'required'}, 'children': {}}
        self.id: OM289Component._Id = self._Id(xml_tree=xml_tree, parent=self)

    class _Id(AttributeNode):
        """Generated class for 'id'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='id', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The identifier (short name) of a component.

name:	Identifier"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM290Option(Node):
    """Generated class for 'option'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='option', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'type': 'om:Option', 'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'name': 'required', 'value': ''}, 'children': {}}
        self.name: OM290Option._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.value: OM290Option._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of an option (monitoring measure or model option).

name:	Option name"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Option on/off switch (true/false). Specifying value="true" is
the same as not specifying a value; specifying value="false"
explicitly turns the option off. If an option is not mentioned
at all, it is left at its default value (normally off, but
in a few cases, such as some bug-fix options, on).

name:	Indicator of whether option is required"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'true', 'children_metadata': {'ordered': None, 'order': []}}


class OM291Item(ElementNode):
    """Generated class for 'item'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='item', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM292Decay(Node):
    """Generated class for 'decay'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='decay', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Specification of decay or survival of a parameter.

name:	Decay or survival of a parameter"""
        self._metadata: dict = {'type': 'om:DecayFunction', 'children_metadata': {'ordered': 'sequence', 'order': ['decay']}, 'attributes': {'function': 'required', 'L': 'optional', 'k': '', 'CV': '', 'increasing': '', 'initialEfficacy': 'optional', 'rho': 'optional', 'halflife_short': 'optional', 'halflife_long': 'optional'}, 'children': {'decay': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.function: OM292Decay._Function = self._Function(xml_tree=xml_tree, parent=self)
        self.L: OM292Decay._L = self._L(xml_tree=xml_tree, parent=self)
        self.k: OM292Decay._K = self._K(xml_tree=xml_tree, parent=self)
        self.CV: OM292Decay._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.increasing: OM292Decay._Increasing = self._Increasing(xml_tree=xml_tree, parent=self)
        self.initialEfficacy: OM292Decay._InitialEfficacy = self._InitialEfficacy(xml_tree=xml_tree, parent=self)
        self.rho: OM292Decay._Rho = self._Rho(xml_tree=xml_tree, parent=self)
        self.halflife_short: OM292Decay._Halflife_short = self._Halflife_short(xml_tree=xml_tree, parent=self)
        self.halflife_long: OM292Decay._Halflife_long = self._Halflife_long(xml_tree=xml_tree, parent=self)
        self._decay: OM187Decay | None = None

    @property
    def decay(self) -> 'OM187Decay':
        """Initialize 'decay'."""
        if self._decay is None:
            self._decay = OM187Decay(xml_tree=self.xml_tree, parent=self)
        return self._decay

    class _Function(AttributeNode):
        """Generated class for 'function'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='function', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Determines which decay function to use. Available decay functions,
for age t in years:
constant: 1
step: 1 for t less than L, otherwise 0
linear: 1 - t/L for t less than L, otherwise 0
exponential: exp( - t/L * log(2) )
weibull: exp( -(t/L)^k * log(2) )
hill: 1 / (1 + (t/L)^k)
smooth-compact: exp( k - k / (1 - (t/L)^2) ) for t less than L, otherwise 0

units:	None
min:	0
max:	1
name:	function"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['constant', 'step', 'linear', 'exponential', 'weibull', 'hill', 'smooth-compact', 'plus', 'minus', 'divides', 'multiplies']}, 'type': 'xs:string'}

    class _L(AttributeNode):
        """Generated class for 'L'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='L', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Time) scale parameter of distribution: this is either the age of
complete decay (smooth-compact, step and linear functions) or the age
at which the parameter has decayed to half its original value
(exponential, weibull and hill). Not used when function="constant"
(i.e. no decay).
This value can be specified in years, days or steps (e.g. 2y, 180d or
100t). When the unit is not specified years are assumed. The value is
used without rounding except when sampling an age of decay, when the
rounding happens as late as possible.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _K(AttributeNode):
        """Generated class for 'k'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='k', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Shape parameter of distribution. If not specified, default value of
1 is used. Meaning depends on function; not used in some cases.

min:	0
name:	k
units:	none"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1.0', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If CV is non-zero, heterogeneity of decay is introduced via a random
variable sampled from the log-normal distribution. This distribution is
parameterised with mean=1 and CV as given.
The effective age of decay is the real age multiplied by this variable
(for decay functions with a half-life, this is equivalent to dividing
the half-life by the variable).

min:	0
name:	Coefficient of Variation"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}

    class _Increasing(AttributeNode):
        """Generated class for 'increasing'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='increasing', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
(Boolean) If True, this tells OpenMalaria to use the complement of the
DecayFunction defined as 1-f(x). This is useful to model increasing
functions that will "decay" to 1. This only works if f(x) is contained
between 0 and 1.

units:	User-defined (defaults to years)
min:	0
name:	L"""
            self._metadata: dict = {'type': 'xs:boolean', 'default': 'false', 'children_metadata': {'ordered': None, 'order': []}}

    class _InitialEfficacy(AttributeNode):
        """Generated class for 'initialEfficacy'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='initialEfficacy', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Efficacy between 0 and 1.
"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'default': '1', 'children_metadata': {'ordered': None, 'order': []}}

    class _Rho(AttributeNode):
        """Generated class for 'rho'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='rho', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: Proportion between 0 and 1, proportion of the response that is short-lived."""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_short(AttributeNode):
        """Generated class for 'halflife_short'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_short', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of short lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Halflife_long(AttributeNode):
        """Generated class for 'halflife_long'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='halflife_long', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
biphasic: halflife of long lived component (default to years).
"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM293Group(Node):
    """Generated class for 'group'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='group', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A series of values according to age groups, each specified with
a lower-bound and a value. The first lower-bound specified must be
zero; a final upper-bound of infinity is added to complete the last
age group. At least one age group is required. Normally these are
interpolated by a continuous function (see interpolation attribute).

name:	age group"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'type': 'om:DoubleValue', 'attributes': {'lowerbound': 'required', 'value': 'required'}, 'children': {}}
        self.lowerbound: OM293Group._Lowerbound = self._Lowerbound(xml_tree=xml_tree, parent=self)
        self.value: OM293Group._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Lowerbound(AttributeNode):
        """Generated class for 'lowerbound'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='lowerbound', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Lower bound of age group

units:	Years
min:	0
max:	100
name:	Lower bound"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Element:
A double-precision floating-point value.
name:	Input parameter value
exposed:	false
Type:
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM294AgeGroup(Node):
    """Generated class for 'ageGroup'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='ageGroup', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
list of age groups included in demography

name:	Age groups
Type:
list of age groups included in demography or surveys

name:	list of age groups"""
        self._metadata: dict = {'type': 'om:DemogAgeGroup', 'children_metadata': {'ordered': 'sequence', 'order': ['group']}, 'attributes': {'lowerbound': 'required'}, 'children': {'group': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.lowerbound: OM294AgeGroup._Lowerbound = self._Lowerbound(xml_tree=xml_tree, parent=self)
        self._group: OM295Group | None = None

    @property
    def group(self) -> 'OM295Group':
        """Initialize 'group'."""
        if self._group is None:
            self._group = OM295Group(xml_tree=self.xml_tree, parent=self)
        return self._group

    class _Lowerbound(AttributeNode):
        """Generated class for 'lowerbound'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='lowerbound', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Lower bound of age group

units:	Years
min:	0
max:	100
name:	Lower bound of age group"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM295Group(Node):
    """Generated class for 'group'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='group', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'type': 'om:DemogGroupBounds', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'poppercent': 'required', 'upperbound': 'required'}, 'children': {}}
        self.poppercent: OM295Group._Poppercent = self._Poppercent(xml_tree=xml_tree, parent=self)
        self.upperbound: OM295Group._Upperbound = self._Upperbound(xml_tree=xml_tree, parent=self)

    class _Poppercent(AttributeNode):
        """Generated class for 'poppercent'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='poppercent', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Percentage of human population in age group

units:	Percentage
min:	0
max:	100
name:	Percentage in age group"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Upperbound(AttributeNode):
        """Generated class for 'upperbound'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='upperbound', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Upper bound of age group

units:	Years
min:	0
max:	100
name:	Upper bound of age group"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM296ProbBloodStageInfectiousToMosq(Node):
    """Generated class for 'probBloodStageInfectiousToMosq'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='probBloodStageInfectiousToMosq', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The chance of a feeding mosquito becoming infected, given that the
host is patent. (This may be adjusted by transmission-blocking vaccines.)

name:	Probability of mosquito infection
units:	None
min:	0
max:	1"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM296ProbBloodStageInfectiousToMosq._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM297HypnozoiteRelease(Node):
    """Generated class for 'hypnozoiteRelease'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='hypnozoiteRelease', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Describes the number and times of hypnozoite releases.

name:	Hypnozoite releases
Type:
This element defines probabilites when and how many hypnozoites are released from the liverstage into the blood.
The gap between the start of a new brood of hypnozoites and its release are defined as follows:
latentP + latentRelapse + randomReleaseDelay
randomReleaseDelay is based on one or two lognormal distributions, which are defined in firstRelease and optionally secondRelease.
You can define 2 release distributions, which get added together and represent the probability of hypnozoites which get released before winter (first release) or after (second release).
You can omit the secondRelease element if no release to the blood happens after winter.

name:	Hypnozoite release"""
        self._metadata: dict = {'type': 'om:HypnozoiteRelease', 'children_metadata': {'ordered': 'all', 'order': ['numberHypnozoites', 'firstReleaseDays', 'secondReleaseDays']}, 'attributes': {'pSecondRelease': ''}, 'children': {'numberHypnozoites': {'minOccurs': '1', 'maxOccurs': '1'}, 'firstReleaseDays': {'minOccurs': '1', 'maxOccurs': '1'}, 'secondReleaseDays': {'minOccurs': '0', 'maxOccurs': '1'}}}
        self.pSecondRelease: OM297HypnozoiteRelease._PSecondRelease = self._PSecondRelease(xml_tree=xml_tree, parent=self)
        self._numberHypnozoites: OM301NumberHypnozoites | None = None
        self._firstReleaseDays: OM302FirstReleaseDays | None = None
        self._secondReleaseDays: OM303SecondReleaseDays | None = None

    @property
    def numberHypnozoites(self) -> 'OM301NumberHypnozoites':
        """Initialize 'numberHypnozoites'."""
        if self._numberHypnozoites is None:
            self._numberHypnozoites = OM301NumberHypnozoites(xml_tree=self.xml_tree, parent=self)
        return self._numberHypnozoites

    @property
    def firstReleaseDays(self) -> 'OM302FirstReleaseDays':
        """Initialize 'firstReleaseDays'."""
        if self._firstReleaseDays is None:
            self._firstReleaseDays = OM302FirstReleaseDays(xml_tree=self.xml_tree, parent=self)
        return self._firstReleaseDays

    @property
    def secondReleaseDays(self) -> 'OM303SecondReleaseDays':
        """Initialize 'secondReleaseDays'."""
        if self._secondReleaseDays is None:
            self._secondReleaseDays = OM303SecondReleaseDays(xml_tree=self.xml_tree, parent=self)
        return self._secondReleaseDays

    class _PSecondRelease(AttributeNode):
        """Generated class for 'pSecondRelease'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='pSecondRelease', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Probability of a second release. If undefined it is zero.

name:	latent relapse days"""
            self._metadata: dict = {'type': 'xs:double', 'default': '0', 'children_metadata': {'ordered': None, 'order': []}}


class OM298BloodStageProtectionLatency(Node):
    """Generated class for 'bloodStageProtectionLatency'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='bloodStageProtectionLatency', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The length of time after expiry of a blood-stage infection during
which relapses from the same brood are supressed by the immune
system.
This is rounded to the nearest time-step.

name:	Blood stage protection latency
min:	0"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM298BloodStageProtectionLatency._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM299BloodStageLengthDays(Node):
    """Generated class for 'bloodStageLengthDays'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='bloodStageLengthDays', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Parameters used to sample the length of blood-stage infections from
a Weibull distribution (scale parameter lambda, shape parameter k).

name:	Blood stage length
units:	Days
Type:
Parameters of a Weibull distribution.

name:	Weibull parameters"""
        self._metadata: dict = {'type': 'om:WeibullSample', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'scale': 'required', 'shape': 'required', 'distr': 'required'}, 'children': {}}
        self.scale: OM299BloodStageLengthDays._Scale = self._Scale(xml_tree=xml_tree, parent=self)
        self.shape: OM299BloodStageLengthDays._Shape = self._Shape(xml_tree=xml_tree, parent=self)
        self.distr: OM299BloodStageLengthDays._Distr = self._Distr(xml_tree=xml_tree, parent=self)

    class _Scale(AttributeNode):
        """Generated class for 'scale'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='scale', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The Weibull scale parameter ().

name:	Scale"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Shape(AttributeNode):
        """Generated class for 'shape'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='shape', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The Weibull shape parameter (k).

name:	shape"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
In this case, only "weibull" is allowed.

name:	Distribution"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['weibull']}, 'type': 'xs:string'}


class OM300ClinicalEvents(Node):
    """Generated class for 'clinicalEvents'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='clinicalEvents', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
This elements holds all information about probabilites for clinical events from infections and relapses.

name:	Vivax Clinical Events"""
        self._metadata: dict = {'type': 'om:ClinicalEvents', 'children_metadata': {'ordered': 'sequence', 'order': ['pPrimaryInfection', 'pRelapseOne', 'pRelapseTwoPlus', 'pEventIsSevere']}, 'attributes': {}, 'children': {'pPrimaryInfection': {'minOccurs': '1', 'maxOccurs': '1'}, 'pRelapseOne': {'minOccurs': '1', 'maxOccurs': '1'}, 'pRelapseTwoPlus': {'minOccurs': '1', 'maxOccurs': '1'}, 'pEventIsSevere': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._pPrimaryInfection: OM304PPrimaryInfection | None = None
        self._pRelapseOne: OM305PRelapseOne | None = None
        self._pRelapseTwoPlus: OM306PRelapseTwoPlus | None = None
        self._pEventIsSevere: OM307PEventIsSevere | None = None

    @property
    def pPrimaryInfection(self) -> 'OM304PPrimaryInfection':
        """Initialize 'pPrimaryInfection'."""
        if self._pPrimaryInfection is None:
            self._pPrimaryInfection = OM304PPrimaryInfection(xml_tree=self.xml_tree, parent=self)
        return self._pPrimaryInfection

    @property
    def pRelapseOne(self) -> 'OM305PRelapseOne':
        """Initialize 'pRelapseOne'."""
        if self._pRelapseOne is None:
            self._pRelapseOne = OM305PRelapseOne(xml_tree=self.xml_tree, parent=self)
        return self._pRelapseOne

    @property
    def pRelapseTwoPlus(self) -> 'OM306PRelapseTwoPlus':
        """Initialize 'pRelapseTwoPlus'."""
        if self._pRelapseTwoPlus is None:
            self._pRelapseTwoPlus = OM306PRelapseTwoPlus(xml_tree=self.xml_tree, parent=self)
        return self._pRelapseTwoPlus

    @property
    def pEventIsSevere(self) -> 'OM307PEventIsSevere':
        """Initialize 'pEventIsSevere'."""
        if self._pEventIsSevere is None:
            self._pEventIsSevere = OM307PEventIsSevere(xml_tree=self.xml_tree, parent=self)
        return self._pEventIsSevere


class OM301NumberHypnozoites(Node):
    """Generated class for 'numberHypnozoites'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='numberHypnozoites', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
numberHypnozoites calculates the number of hypnozoites in the liver stage based on a base which is between 0 and 1.
This number is random based on the following distribution and normalized:
max
 (base ^ n)
n = 0

name:	Number of Hypnozoites"""
        self._metadata: dict = {'maxOccurs': '1', 'minOccurs': '1', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'max': 'required', 'base': 'required'}, 'children': {}}
        self.max: OM301NumberHypnozoites._Max = self._Max(xml_tree=xml_tree, parent=self)
        self.base: OM301NumberHypnozoites._Base = self._Base(xml_tree=xml_tree, parent=self)

    class _Max(AttributeNode):
        """Generated class for 'max'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='max', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Base(AttributeNode):
        """Generated class for 'base'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='base', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM302FirstReleaseDays(Node):
    """Generated class for 'firstReleaseDays'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='firstReleaseDays', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Hypnozoites are released after a delay, calculated as:
roundToTSFromDays(delay + latentRelapse)
Here, roundToTSFromDays rounds the input (in days) to the nearest timestep,
delay is sampled from a log-normal, and latentRelapse is the
parameter specified here.
The delay is sampled from a log-normal distribution, parameterised via
the (linear) mean and CV (coefficient of variation) given here.

name:	Hypnozoite release delay
Base Type:
A parameter with optional log-normal heterogeneity.
The mean value must be specified. Optionally, a distribution ("distr")
and coefficient of variation ("CV") may be specified.

name:	Sampled value
Base Type:
A parameter with optional heterogeneity.
The mean cannot be specified (unless this type is extended).
Optionally, a distribution ("distr") and coefficient of variation ("CV") may be specified.

name:	Sampled value (log normal)"""
        self._metadata: dict = {'type': 'om:HypnozoiteReleaseDistribution', 'maxOccurs': '1', 'minOccurs': '1', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'latentRelapse': 'required', 'mean': 'required', 'CV': 'optional', 'distr': 'optional', 'variance': 'optional'}, 'children': {}}
        self.latentRelapse: OM302FirstReleaseDays._LatentRelapse = self._LatentRelapse(xml_tree=xml_tree, parent=self)
        self.mean: OM302FirstReleaseDays._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.CV: OM302FirstReleaseDays._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.distr: OM302FirstReleaseDays._Distr = self._Distr(xml_tree=xml_tree, parent=self)
        self.variance: OM302FirstReleaseDays._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _LatentRelapse(AttributeNode):
        """Generated class for 'latentRelapse'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='latentRelapse', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Usually between 10 and 15 days.

name:	latent relapse days"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) coefficient of variation.
This value must be specified when a (non-constant) distribution is used. 
Note: since version 46, variance can be used instead.
Note that specifying CV="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"lognormal": the parameter is sampled from a log-normal distribution.
Note that the "mean" and "CV" values are linear (arithmetic) properties
of the distribution and not log-space properties.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'lognormal', 'gamma']}, 'type': 'xs:string'}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The variance parameter of the distirbution.
This value can be specified when a (non-constant) distribution is used.
Note that specifying variance="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM303SecondReleaseDays(Node):
    """Generated class for 'secondReleaseDays'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='secondReleaseDays', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Hypnozoites are released after a delay, calculated as:
roundToTSFromDays(delay + latentRelapse)
Here, roundToTSFromDays rounds the input (in days) to the nearest timestep,
delay is sampled from a log-normal, and latentRelapse is the
parameter specified here.
The delay is sampled from a log-normal distribution, parameterised via
the (linear) mean and CV (coefficient of variation) given here.

name:	Hypnozoite release delay
Base Type:
A parameter with optional log-normal heterogeneity.
The mean value must be specified. Optionally, a distribution ("distr")
and coefficient of variation ("CV") may be specified.

name:	Sampled value
Base Type:
A parameter with optional heterogeneity.
The mean cannot be specified (unless this type is extended).
Optionally, a distribution ("distr") and coefficient of variation ("CV") may be specified.

name:	Sampled value (log normal)"""
        self._metadata: dict = {'type': 'om:HypnozoiteReleaseDistribution', 'maxOccurs': '1', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'latentRelapse': 'required', 'mean': 'required', 'CV': 'optional', 'distr': 'optional', 'variance': 'optional'}, 'children': {}}
        self.latentRelapse: OM303SecondReleaseDays._LatentRelapse = self._LatentRelapse(xml_tree=xml_tree, parent=self)
        self.mean: OM303SecondReleaseDays._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.CV: OM303SecondReleaseDays._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.distr: OM303SecondReleaseDays._Distr = self._Distr(xml_tree=xml_tree, parent=self)
        self.variance: OM303SecondReleaseDays._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _LatentRelapse(AttributeNode):
        """Generated class for 'latentRelapse'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='latentRelapse', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Usually between 10 and 15 days.

name:	latent relapse days"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) mean value.

name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) coefficient of variation.
This value must be specified when a (non-constant) distribution is used. 
Note: since version 46, variance can be used instead.
Note that specifying CV="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"lognormal": the parameter is sampled from a log-normal distribution.
Note that the "mean" and "CV" values are linear (arithmetic) properties
of the distribution and not log-space properties.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'lognormal', 'gamma']}, 'type': 'xs:string'}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The variance parameter of the distirbution.
This value can be specified when a (non-constant) distribution is used.
Note that specifying variance="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM304PPrimaryInfection(Node):
    """Generated class for 'pPrimaryInfection'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pPrimaryInfection', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'type': 'om:ProbVivaxEvent', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'a': 'required', 'b': 'required'}, 'children': {}}
        self.a: OM304PPrimaryInfection._A = self._A(xml_tree=xml_tree, parent=self)
        self.b: OM304PPrimaryInfection._B = self._B(xml_tree=xml_tree, parent=self)

    class _A(AttributeNode):
        """Generated class for 'a'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='a', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _B(AttributeNode):
        """Generated class for 'b'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='b', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM305PRelapseOne(Node):
    """Generated class for 'pRelapseOne'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pRelapseOne', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'type': 'om:ProbVivaxEvent', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'a': 'required', 'b': 'required'}, 'children': {}}
        self.a: OM305PRelapseOne._A = self._A(xml_tree=xml_tree, parent=self)
        self.b: OM305PRelapseOne._B = self._B(xml_tree=xml_tree, parent=self)

    class _A(AttributeNode):
        """Generated class for 'a'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='a', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _B(AttributeNode):
        """Generated class for 'b'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='b', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM306PRelapseTwoPlus(Node):
    """Generated class for 'pRelapseTwoPlus'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pRelapseTwoPlus', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'type': 'om:ProbVivaxEvent', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'a': 'required', 'b': 'required'}, 'children': {}}
        self.a: OM306PRelapseTwoPlus._A = self._A(xml_tree=xml_tree, parent=self)
        self.b: OM306PRelapseTwoPlus._B = self._B(xml_tree=xml_tree, parent=self)

    class _A(AttributeNode):
        """Generated class for 'a'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='a', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _B(AttributeNode):
        """Generated class for 'b'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='b', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM307PEventIsSevere(Node):
    """Generated class for 'pEventIsSevere'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pEventIsSevere', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM307PEventIsSevere._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM308NonVector(Node):
    """Generated class for 'nonVector'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='nonVector', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of transmission setting for models without vector control interventions
(included for backward compatibility)

name:	Transmission setting (vector control not enabled)"""
        self._metadata: dict = {'type': 'om:NonVector', 'children_metadata': {'ordered': 'sequence', 'order': ['EIRDaily']}, 'attributes': {'eipDuration': 'required'}, 'children': {'EIRDaily': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.eipDuration: OM308NonVector._EipDuration = self._EipDuration(xml_tree=xml_tree, parent=self)
        self._EIRDaily: OM312EIRDaily | None = None

    @property
    def EIRDaily(self) -> 'OM312EIRDaily':
        """Initialize 'EIRDaily'."""
        if self._EIRDaily is None:
            self._EIRDaily = OM312EIRDaily(xml_tree=self.xml_tree, parent=self)
        return self._EIRDaily

    class _EipDuration(AttributeNode):
        """Generated class for 'eipDuration'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='eipDuration', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The duration of sporogony in days
units:	Days
name:	Duration of sporogony"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM309Vector(Node):
    """Generated class for 'vector'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='vector', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Parameters of the transmission model
name:	Transmission setting (vector control enabled)"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': ['anopheles', 'nonHumanHosts']}, 'attributes': {}, 'children': {'anopheles': {'minOccurs': '1', 'maxOccurs': 'unbounded'}, 'nonHumanHosts': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self._anopheles: OM310Anopheles | None = None
        self._nonHumanHosts: OM150NonHumanHosts | None = None

    @property
    def anopheles(self) -> 'OM310Anopheles':
        """Initialize 'anopheles'."""
        if self._anopheles is None:
            self._anopheles = OM310Anopheles(xml_tree=self.xml_tree, parent=self)
        return self._anopheles

    @property
    def nonHumanHosts(self) -> 'OM150NonHumanHosts':
        """Initialize 'nonHumanHosts'."""
        if self._nonHumanHosts is None:
            self._nonHumanHosts = OM150NonHumanHosts(xml_tree=self.xml_tree, parent=self)
        return self._nonHumanHosts


class OM310Anopheles(Node):
    """Generated class for 'anopheles'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='anopheles', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of input EIR for
one specific vector species in terms of a Fourier approximation
to the ln of the EIR during the burn in period
name:	Description of input EIR for one vector"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'minOccurs': '1', 'type': 'om:AnophelesParams', 'children_metadata': {'ordered': 'sequence', 'order': ['seasonality', 'mosq', 'lifeCycle', 'simpleMPD', 'nonHumanHosts']}, 'attributes': {'mosquito': 'required', 'propInfected': 'required', 'propInfectious': 'required'}, 'children': {'seasonality': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosq': {'minOccurs': '1', 'maxOccurs': '1'}, 'lifeCycle': {'minOccurs': '0', 'maxOccurs': '1'}, 'simpleMPD': {'minOccurs': '0', 'maxOccurs': '1'}, 'nonHumanHosts': {'minOccurs': '1', 'maxOccurs': 'unbounded'}}}
        self.mosquito: OM310Anopheles._Mosquito = self._Mosquito(xml_tree=xml_tree, parent=self)
        self.propInfected: OM310Anopheles._PropInfected = self._PropInfected(xml_tree=xml_tree, parent=self)
        self.propInfectious: OM310Anopheles._PropInfectious = self._PropInfectious(xml_tree=xml_tree, parent=self)
        self._seasonality: OM313Seasonality | None = None
        self._mosq: OM320Mosq | None = None
        self._lifeCycle: OM332LifeCycle | None = None
        self._simpleMPD: OM338SimpleMPD | None = None
        self._nonHumanHosts: OM150NonHumanHosts | None = None

    @property
    def seasonality(self) -> 'OM313Seasonality':
        """Initialize 'seasonality'."""
        if self._seasonality is None:
            self._seasonality = OM313Seasonality(xml_tree=self.xml_tree, parent=self)
        return self._seasonality

    @property
    def mosq(self) -> 'OM320Mosq':
        """Initialize 'mosq'."""
        if self._mosq is None:
            self._mosq = OM320Mosq(xml_tree=self.xml_tree, parent=self)
        return self._mosq

    @property
    def lifeCycle(self) -> 'OM332LifeCycle':
        """Initialize 'lifeCycle'."""
        if self._lifeCycle is None:
            self._lifeCycle = OM332LifeCycle(xml_tree=self.xml_tree, parent=self)
        return self._lifeCycle

    @property
    def simpleMPD(self) -> 'OM338SimpleMPD':
        """Initialize 'simpleMPD'."""
        if self._simpleMPD is None:
            self._simpleMPD = OM338SimpleMPD(xml_tree=self.xml_tree, parent=self)
        return self._simpleMPD

    @property
    def nonHumanHosts(self) -> 'OM150NonHumanHosts':
        """Initialize 'nonHumanHosts'."""
        if self._nonHumanHosts is None:
            self._nonHumanHosts = OM150NonHumanHosts(xml_tree=self.xml_tree, parent=self)
        return self._nonHumanHosts

    class _Mosquito(AttributeNode):
        """Generated class for 'mosquito'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mosquito', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Identifier for this anopheles species
name:	Identifier for this anopheles species"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _PropInfected(AttributeNode):
        """Generated class for 'propInfected'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='propInfected', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Initial guess of the proportion of mosquitoes which are infected, o: O_v(t) = o*N_v(t). Only used as a starting value.
units:	Proportion
min:	0
max:	1
name:	Initial estimate of proportion of mosquitoes infected (_O)
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _PropInfectious(AttributeNode):
        """Generated class for 'propInfectious'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='propInfectious', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Initial estimate of the proportion of mosquitoes which are infectious, s: S_v(t) = s*N_v(t). Used as a starting value and then fit.
units:	Proportion
min:	0
max:	1
name:	Initial estimate of proportion of mosquitoes infectious (_S)
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM311NonHumanHosts(Node):
    """Generated class for 'nonHumanHosts'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='nonHumanHosts', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'name': 'required', 'number': 'required'}, 'children': {}}
        self.name: OM311NonHumanHosts._Name = self._Name(xml_tree=xml_tree, parent=self)
        self.number: OM311NonHumanHosts._Number = self._Number(xml_tree=xml_tree, parent=self)

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Name of this species of non human hosts (must match up
with those described per anopheles section).

name:	Species of alternative host"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Number(AttributeNode):
        """Generated class for 'number'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='number', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Population size of this non-human host.
Note: the availability of the population of this type of non-human host is
determined by mosqRelativeEntoAvailability and mosqHumanBloodIndex.
NHHs are not modelled individually, thus this parameter is not used. It
might be useful in the future if there is ever an intervention to change
the number of non-human hosts.

units:	Animals
name:	Population size of non-human host species"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM312EIRDaily(Node):
    """Generated class for 'EIRDaily'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='EIRDaily', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
In the non-vector model, EIR is input as a sequence of daily values.
There must be at least one years' worth of entries (365), and if there
are more, values are wrapped and averaged (i.e. value for first day
of year is taken as the mean of values for days 0, 365+0, 2*365+0,
etc.).

units:	Infectious bites per adult per day
name:	Daily Entomological Inoculation Rate
exposed:	false"""
        self._metadata: dict = {'minOccurs': '1', 'maxOccurs': 'unbounded', 'type': 'om:EIRDaily', 'children_metadata': {'ordered': None, 'order': []}, 'base_type': 'xs:double', 'attributes': {'origin': 'optional'}, 'children': {}}
        self.origin: OM312EIRDaily._Origin = self._Origin(xml_tree=xml_tree, parent=self)

    class _Origin(AttributeNode):
        """Generated class for 'origin'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='origin', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """name:	Time origin of EIR sequence
exposed:	false"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM313Seasonality(Node):
    """Generated class for 'seasonality'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='seasonality', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Specifies the seasonality of transmission
and optionally the level of annual transmission.
name:	Seasonality of transmission"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': [['fourierSeries', 'monthlyValues', 'dailyValues']]}, 'attributes': {'input': 'required', 'annualEIR': 'optional'}, 'children': {'fourierSeries': {'minOccurs': '1', 'maxOccurs': '1'}, 'monthlyValues': {'minOccurs': '1', 'maxOccurs': '1'}, 'dailyValues': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.input: OM313Seasonality._Input = self._Input(xml_tree=xml_tree, parent=self)
        self.annualEIR: OM313Seasonality._AnnualEIR = self._AnnualEIR(xml_tree=xml_tree, parent=self)
        self._fourierSeries: OM314FourierSeries | None = None
        self._monthlyValues: OM316MonthlyValues | None = None
        self._dailyValues: OM318DailyValues | None = None

    @property
    def fourierSeries(self) -> 'OM314FourierSeries':
        """Initialize 'fourierSeries'."""
        if self._fourierSeries is None:
            self._fourierSeries = OM314FourierSeries(xml_tree=self.xml_tree, parent=self)
        return self._fourierSeries

    @property
    def monthlyValues(self) -> 'OM316MonthlyValues':
        """Initialize 'monthlyValues'."""
        if self._monthlyValues is None:
            self._monthlyValues = OM316MonthlyValues(xml_tree=self.xml_tree, parent=self)
        return self._monthlyValues

    @property
    def dailyValues(self) -> 'OM318DailyValues':
        """Initialize 'dailyValues'."""
        if self._dailyValues is None:
            self._dailyValues = OM318DailyValues(xml_tree=self.xml_tree, parent=self)
        return self._dailyValues

    class _Input(AttributeNode):
        """Generated class for 'input'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='input', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Specify what seasonality measure is given.
At the moment, only EIR is supported, but in the future, all the
below should be supported.
EIR: seasonality of entomological inoculations is input.
Units: entomological inoculations per adult per annum.
hostSeeking: seasonality of densities of flying host-seeking
mosquitoes is input (in the model this is notated N_v).
Units: mosquitoes.
emergence: seasonality of emergence pupa into adults.
Units: mosquitoes.
larvalResources: seasonality of larval resources. Units: X.

name:	Seasonality input"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['EIR']}, 'type': 'xs:string'}

    class _AnnualEIR(AttributeNode):
        """Generated class for 'annualEIR'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='annualEIR', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If this attribute is included, EIR for this
species is scaled to this level. Note that if the scaledAnnualEIR
attribute of the entomology element is also used, EIR is scaled
again, making this attribute the EIR relative to other species.
With some seasonality inputs, this attribute is optional, in which
case (if scaledAnnualEIR is also not specified) transmission depends
on all parameters of the vector. With some seasonality inputs,
however, this parameter must be specified.
name:	Annual EIR
units:	Inoculations per adult per annum
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM314FourierSeries(Node):
    """Generated class for 'fourierSeries'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='fourierSeries', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Seasonality is reproduced from the exponential of a fourier
series specified by the following coefficients. Note that
the a0 term is not needed; the annualEIR attribute of the
seasonality element should be used to scale EIR instead.

units:	Infectious bites per adult per day
name:	Fourier approximation to pre-intervention EIR"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': ['coeffic']}, 'attributes': {'EIRRotateAngle': 'required'}, 'children': {'coeffic': {'minOccurs': '0', 'maxOccurs': 'unbounded'}}}
        self.EIRRotateAngle: OM314FourierSeries._EIRRotateAngle = self._EIRRotateAngle(xml_tree=xml_tree, parent=self)
        self._coeffic: OM315Coeffic | None = None

    @property
    def coeffic(self) -> 'OM315Coeffic':
        """Initialize 'coeffic'."""
        if self._coeffic is None:
            self._coeffic = OM315Coeffic(xml_tree=self.xml_tree, parent=self)
        return self._coeffic

    class _EIRRotateAngle(AttributeNode):
        """Generated class for 'EIRRotateAngle'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='EIRRotateAngle', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Rotation angle defining the origin of the Fourier approximation to ln (EIR)

units:	Radians
name:	Rotation angle defining the origin of the Fourier approximation to ln (EIR)"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM315Coeffic(Node):
    """Generated class for 'coeffic'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='coeffic', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
A pair of Fourier series coefficients. The first element
specifies a1 and b1, the second a2 and b2, etc. Any number
(from 0 up) of pairs may be given.

name:	Pair of Fourier coefficients"""
        self._metadata: dict = {'minOccurs': '0', 'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'a': 'required', 'b': 'required'}, 'children': {}}
        self.a: OM315Coeffic._A = self._A(xml_tree=xml_tree, parent=self)
        self.b: OM315Coeffic._B = self._B(xml_tree=xml_tree, parent=self)

    class _A(AttributeNode):
        """Generated class for 'a'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='a', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
a_n parameter of Fourier approximation to ln(EIR) for
some natural number n.

name:	a_n parameter of Fourier approximation to ln(EIR)"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _B(AttributeNode):
        """Generated class for 'b'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='b', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
b_n parameter of Fourier approximation to ln(EIR) for
some natural number n.

name:	b_n parameter of Fourier approximation to ln(EIR)"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM316MonthlyValues(Node):
    """Generated class for 'monthlyValues'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='monthlyValues', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of seasonality from monthly values. Multiple
smoothing methods are possible (see smoothing attribute).
List should contain twelve entries: January to December.

name:	List of monthly values"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': ['value']}, 'attributes': {'smoothing': 'required'}, 'children': {'value': {'minOccurs': '12', 'maxOccurs': '12'}}}
        self.smoothing: OM316MonthlyValues._Smoothing = self._Smoothing(xml_tree=xml_tree, parent=self)
        self._value: OM317Value | None = None

    @property
    def value(self) -> 'OM317Value':
        """Initialize 'value'."""
        if self._value is None:
            self._value = OM317Value(xml_tree=self.xml_tree, parent=self)
        return self._value

    class _Smoothing(AttributeNode):
        """Generated class for 'smoothing'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='smoothing', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
How the monthly values are converted into a daily
sequence of values:
1) none: no smoothing (step function)
2) Fourier: a Fourier series (with terms up to a2/b2)
is fit to the sequence of monthly values and used to
generate a smoothed list of daily values.

name:	Smoothing function"""
            self._metadata: dict = {'use': 'required', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['none', 'fourier']}, 'type': 'xs:string'}


class OM317Value(ElementNode):
    """Generated class for 'value'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Monthly value

units:	(see "seasonality input" parameter)
name:	Monthly value"""
        self._metadata: dict = {'minOccurs': '12', 'maxOccurs': '12', 'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM318DailyValues(Node):
    """Generated class for 'dailyValues'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='dailyValues', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Description of seasonality from daily values.
List should contain 365 entries: 1st January to 31st December.

name:	List of daily values"""
        self._metadata: dict = {'children_metadata': {'ordered': 'sequence', 'order': ['value']}, 'attributes': {}, 'children': {'value': {'minOccurs': '12', 'maxOccurs': '12'}}}
        self._value: OM317Value | None = None

    @property
    def value(self) -> 'OM317Value':
        """Initialize 'value'."""
        if self._value is None:
            self._value = OM317Value(xml_tree=self.xml_tree, parent=self)
        return self._value


class OM319Value(ElementNode):
    """Generated class for 'value'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Daily value

units:	(see "seasonality input" parameter)
name:	Daily value"""
        self._metadata: dict = {'minOccurs': '1', 'maxOccurs': 'unbounded', 'type': 'xs:double', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {}, 'children': {}}


class OM320Mosq(Node):
    """Generated class for 'mosq'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosq', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Parameters describing the feeding cycle and human
mosquito interaction of a single species of anopheles mosquito.

name:	Mosquito feeding cycle parameters"""
        self._metadata: dict = {'children_metadata': {'ordered': 'all', 'order': ['mosqRestDuration', 'extrinsicIncubationPeriod', 'mosqLaidEggsSameDayProportion', 'mosqSeekingDuration', 'mosqSurvivalFeedingCycleProbability', 'availability', 'mosqProbBiting', 'mosqProbFindRestSite', 'mosqProbResting', 'mosqProbOvipositing', 'mosqHumanBloodIndex']}, 'attributes': {'minInfectedThreshold': 'required'}, 'children': {'mosqRestDuration': {'minOccurs': '1', 'maxOccurs': '1'}, 'extrinsicIncubationPeriod': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosqLaidEggsSameDayProportion': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosqSeekingDuration': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosqSurvivalFeedingCycleProbability': {'minOccurs': '1', 'maxOccurs': '1'}, 'availability': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosqProbBiting': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosqProbFindRestSite': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosqProbResting': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosqProbOvipositing': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosqHumanBloodIndex': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.minInfectedThreshold: OM320Mosq._MinInfectedThreshold = self._MinInfectedThreshold(xml_tree=xml_tree, parent=self)
        self._mosqRestDuration: OM321MosqRestDuration | None = None
        self._extrinsicIncubationPeriod: OM322ExtrinsicIncubationPeriod | None = None
        self._mosqLaidEggsSameDayProportion: OM323MosqLaidEggsSameDayProportion | None = None
        self._mosqSeekingDuration: OM324MosqSeekingDuration | None = None
        self._mosqSurvivalFeedingCycleProbability: OM325MosqSurvivalFeedingCycleProbability | None = None
        self._availability: OM326Availability | None = None
        self._mosqProbBiting: OM327MosqProbBiting | None = None
        self._mosqProbFindRestSite: OM328MosqProbFindRestSite | None = None
        self._mosqProbResting: OM329MosqProbResting | None = None
        self._mosqProbOvipositing: OM330MosqProbOvipositing | None = None
        self._mosqHumanBloodIndex: OM331MosqHumanBloodIndex | None = None

    @property
    def mosqRestDuration(self) -> 'OM321MosqRestDuration':
        """Initialize 'mosqRestDuration'."""
        if self._mosqRestDuration is None:
            self._mosqRestDuration = OM321MosqRestDuration(xml_tree=self.xml_tree, parent=self)
        return self._mosqRestDuration

    @property
    def extrinsicIncubationPeriod(self) -> 'OM322ExtrinsicIncubationPeriod':
        """Initialize 'extrinsicIncubationPeriod'."""
        if self._extrinsicIncubationPeriod is None:
            self._extrinsicIncubationPeriod = OM322ExtrinsicIncubationPeriod(xml_tree=self.xml_tree, parent=self)
        return self._extrinsicIncubationPeriod

    @property
    def mosqLaidEggsSameDayProportion(self) -> 'OM323MosqLaidEggsSameDayProportion':
        """Initialize 'mosqLaidEggsSameDayProportion'."""
        if self._mosqLaidEggsSameDayProportion is None:
            self._mosqLaidEggsSameDayProportion = OM323MosqLaidEggsSameDayProportion(xml_tree=self.xml_tree, parent=self)
        return self._mosqLaidEggsSameDayProportion

    @property
    def mosqSeekingDuration(self) -> 'OM324MosqSeekingDuration':
        """Initialize 'mosqSeekingDuration'."""
        if self._mosqSeekingDuration is None:
            self._mosqSeekingDuration = OM324MosqSeekingDuration(xml_tree=self.xml_tree, parent=self)
        return self._mosqSeekingDuration

    @property
    def mosqSurvivalFeedingCycleProbability(self) -> 'OM325MosqSurvivalFeedingCycleProbability':
        """Initialize 'mosqSurvivalFeedingCycleProbability'."""
        if self._mosqSurvivalFeedingCycleProbability is None:
            self._mosqSurvivalFeedingCycleProbability = OM325MosqSurvivalFeedingCycleProbability(xml_tree=self.xml_tree, parent=self)
        return self._mosqSurvivalFeedingCycleProbability

    @property
    def availability(self) -> 'OM326Availability':
        """Initialize 'availability'."""
        if self._availability is None:
            self._availability = OM326Availability(xml_tree=self.xml_tree, parent=self)
        return self._availability

    @property
    def mosqProbBiting(self) -> 'OM327MosqProbBiting':
        """Initialize 'mosqProbBiting'."""
        if self._mosqProbBiting is None:
            self._mosqProbBiting = OM327MosqProbBiting(xml_tree=self.xml_tree, parent=self)
        return self._mosqProbBiting

    @property
    def mosqProbFindRestSite(self) -> 'OM328MosqProbFindRestSite':
        """Initialize 'mosqProbFindRestSite'."""
        if self._mosqProbFindRestSite is None:
            self._mosqProbFindRestSite = OM328MosqProbFindRestSite(xml_tree=self.xml_tree, parent=self)
        return self._mosqProbFindRestSite

    @property
    def mosqProbResting(self) -> 'OM329MosqProbResting':
        """Initialize 'mosqProbResting'."""
        if self._mosqProbResting is None:
            self._mosqProbResting = OM329MosqProbResting(xml_tree=self.xml_tree, parent=self)
        return self._mosqProbResting

    @property
    def mosqProbOvipositing(self) -> 'OM330MosqProbOvipositing':
        """Initialize 'mosqProbOvipositing'."""
        if self._mosqProbOvipositing is None:
            self._mosqProbOvipositing = OM330MosqProbOvipositing(xml_tree=self.xml_tree, parent=self)
        return self._mosqProbOvipositing

    @property
    def mosqHumanBloodIndex(self) -> 'OM331MosqHumanBloodIndex':
        """Initialize 'mosqHumanBloodIndex'."""
        if self._mosqHumanBloodIndex is None:
            self._mosqHumanBloodIndex = OM331MosqHumanBloodIndex(xml_tree=self.xml_tree, parent=self)
        return self._mosqHumanBloodIndex

    class _MinInfectedThreshold(AttributeNode):
        """Generated class for 'minInfectedThreshold'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='minInfectedThreshold', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
If less than this many mosquitoes remain infected, transmission is interrupted.
name:	Mininum infected threshold for mosquitos
min:	0"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM321MosqRestDuration(Node):
    """Generated class for 'mosqRestDuration'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqRestDuration', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
name:Duration of the resting period of the vector (days);
units:	Days
name:	Duration of the resting period of the vector"""
        self._metadata: dict = {'type': 'om:IntValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM321MosqRestDuration._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An integer value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM322ExtrinsicIncubationPeriod(Node):
    """Generated class for 'extrinsicIncubationPeriod'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='extrinsicIncubationPeriod', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
name:Extrinsic incubation period (days)
units:	Days
name:	Extrinsic incubation period"""
        self._metadata: dict = {'type': 'om:IntValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM322ExtrinsicIncubationPeriod._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An integer value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM323MosqLaidEggsSameDayProportion(Node):
    """Generated class for 'mosqLaidEggsSameDayProportion'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqLaidEggsSameDayProportion', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Proportion of mosquitoes host seeking on same day as ovipositing
units:	Proportion
name:	Proportion of mosquitoes host seeking on same day as ovipositing"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM323MosqLaidEggsSameDayProportion._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM324MosqSeekingDuration(Node):
    """Generated class for 'mosqSeekingDuration'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqSeekingDuration', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Duration of the host-seeking period of the vector (days)
units:	Days
name:	Duration of the host-seeking period of the vector"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM324MosqSeekingDuration._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM325MosqSurvivalFeedingCycleProbability(Node):
    """Generated class for 'mosqSurvivalFeedingCycleProbability'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqSurvivalFeedingCycleProbability', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that the mosquito survives the feeding cycle
units:	Proportion
name:	Probability that the mosquito survives the feeding cycle"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM325MosqSurvivalFeedingCycleProbability._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM326Availability(Node):
    """Generated class for 'availability'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='availability', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Optionally, entomological availability rate may be sampled per-human from a
distribution. The distribution and coefficient of variability may be set here.
The mean rate is calculated based on other parameters and not set directly.
If no attributes are specified or distr="const" or CV="0" then there will be
no heterogeneity.

name:	Human availability rate heterogeneity
Type:
A parameter with optional heterogeneity.
The mean cannot be specified (unless this type is extended).
Optionally, a distribution ("distr") and coefficient of variation ("CV") may be specified.

name:	Sampled value (log normal)"""
        self._metadata: dict = {'type': 'om:SampledValueCV', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'CV': 'optional', 'distr': 'optional', 'variance': 'optional'}, 'children': {}}
        self.CV: OM326Availability._CV = self._CV(xml_tree=xml_tree, parent=self)
        self.distr: OM326Availability._Distr = self._Distr(xml_tree=xml_tree, parent=self)
        self.variance: OM326Availability._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _CV(AttributeNode):
        """Generated class for 'CV'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='CV', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The (linear) coefficient of variation.
This value must be specified when a (non-constant) distribution is used. 
Note: since version 46, variance can be used instead.
Note that specifying CV="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}

    class _Distr(AttributeNode):
        """Generated class for 'distr'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='distr', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
To allow heterogeneity, a distribution must be specified.
Valid options are as follows.
"const": no variation or sampling. Specifying distr="const" has the
same effect as not specifying distr at all.
"lognormal": the parameter is sampled from a log-normal distribution.
Note that the "mean" and "CV" values are linear (arithmetic) properties
of the distribution and not log-space properties.

name:	Distribution"""
            self._metadata: dict = {'use': 'optional', 'default': 'const', 'children_metadata': {'ordered': None, 'order': []}, 'restrictions': {'enumeration': ['const', 'lognormal', 'gamma']}, 'type': 'xs:string'}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The variance parameter of the distirbution.
This value can be specified when a (non-constant) distribution is used.
Note that specifying variance="0" has the same effect as distr="const" and
disables sampling of this parameter, even if distr is not "const". 

name:	Coefficient of variation
units:	unitless"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'optional', 'children_metadata': {'ordered': None, 'order': []}}


class OM327MosqProbBiting(Node):
    """Generated class for 'mosqProbBiting'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqProbBiting', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Probability that the mosquito succesfully bites chosen host
name:	Probability that the mosquito succesfully bites chosen host
Type:
Parameters of a normal distribution, provided as mean and variance.
Variates are sampled from Be(,) where  and  are determined from the
mean and variance as follows: let v be the variance and c=mean/(1-mean).
Then we set =c and =((c+1)v - c)/((c+1)v).

name:	Log-normal parameters"""
        self._metadata: dict = {'type': 'om:BetaMeanSample', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'variance': 'required'}, 'children': {}}
        self.mean: OM327MosqProbBiting._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.variance: OM327MosqProbBiting._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The mean of the beta distribution (must be in the open range (0,1)).

units:	none
name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The standard deviation of variates.

units:	none
name:	variance"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM328MosqProbFindRestSite(Node):
    """Generated class for 'mosqProbFindRestSite'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqProbFindRestSite', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Probability that the mosquito escapes host and finds a resting place after biting
name:	Probability that the mosquito escapes host and finds a resting place after biting
Type:
Parameters of a normal distribution, provided as mean and variance.
Variates are sampled from Be(,) where  and  are determined from the
mean and variance as follows: let v be the variance and c=mean/(1-mean).
Then we set =c and =((c+1)v - c)/((c+1)v).

name:	Log-normal parameters"""
        self._metadata: dict = {'type': 'om:BetaMeanSample', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'variance': 'required'}, 'children': {}}
        self.mean: OM328MosqProbFindRestSite._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.variance: OM328MosqProbFindRestSite._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The mean of the beta distribution (must be in the open range (0,1)).

units:	none
name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The standard deviation of variates.

units:	none
name:	variance"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM329MosqProbResting(Node):
    """Generated class for 'mosqProbResting'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqProbResting', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Probability of mosquito successfully resting after finding a resting site
name:	Probability of mosquito successfully resting after finding a resting site
Type:
Parameters of a normal distribution, provided as mean and variance.
Variates are sampled from Be(,) where  and  are determined from the
mean and variance as follows: let v be the variance and c=mean/(1-mean).
Then we set =c and =((c+1)v - c)/((c+1)v).

name:	Log-normal parameters"""
        self._metadata: dict = {'type': 'om:BetaMeanSample', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'mean': 'required', 'variance': 'required'}, 'children': {}}
        self.mean: OM329MosqProbResting._Mean = self._Mean(xml_tree=xml_tree, parent=self)
        self.variance: OM329MosqProbResting._Variance = self._Variance(xml_tree=xml_tree, parent=self)

    class _Mean(AttributeNode):
        """Generated class for 'mean'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='mean', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The mean of the beta distribution (must be in the open range (0,1)).

units:	none
name:	mean"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Variance(AttributeNode):
        """Generated class for 'variance'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='variance', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
The standard deviation of variates.

units:	none
name:	variance"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM330MosqProbOvipositing(Node):
    """Generated class for 'mosqProbOvipositing'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqProbOvipositing', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability of a mosquito successfully laying eggs given that it has rested
name:	Probability of a mosquito successfully laying eggs given that it has rested"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM330MosqProbOvipositing._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM331MosqHumanBloodIndex(Node):
    """Generated class for 'mosqHumanBloodIndex'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqHumanBloodIndex', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The proportion of resting mosquitoes which fed on human blood during the last feed.
units:	Proportion
name:	Human blood index"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM331MosqHumanBloodIndex._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM332LifeCycle(Node):
    """Generated class for 'lifeCycle'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='lifeCycle', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Parameters describing the life-cycle of this species of mosquito

name:	Mosquito life cycle parameters"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'all', 'order': ['eggStage', 'larvalStage', 'pupalStage', 'femaleEggsLaidByOviposit']}, 'attributes': {'estimatedLarvalResources': ''}, 'children': {'eggStage': {'minOccurs': '1', 'maxOccurs': '1'}, 'larvalStage': {'minOccurs': '1', 'maxOccurs': '1'}, 'pupalStage': {'minOccurs': '1', 'maxOccurs': '1'}, 'femaleEggsLaidByOviposit': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.estimatedLarvalResources: OM332LifeCycle._EstimatedLarvalResources = self._EstimatedLarvalResources(xml_tree=xml_tree, parent=self)
        self._eggStage: OM333EggStage | None = None
        self._larvalStage: OM334LarvalStage | None = None
        self._pupalStage: OM336PupalStage | None = None
        self._femaleEggsLaidByOviposit: OM337FemaleEggsLaidByOviposit | None = None

    @property
    def eggStage(self) -> 'OM333EggStage':
        """Initialize 'eggStage'."""
        if self._eggStage is None:
            self._eggStage = OM333EggStage(xml_tree=self.xml_tree, parent=self)
        return self._eggStage

    @property
    def larvalStage(self) -> 'OM334LarvalStage':
        """Initialize 'larvalStage'."""
        if self._larvalStage is None:
            self._larvalStage = OM334LarvalStage(xml_tree=self.xml_tree, parent=self)
        return self._larvalStage

    @property
    def pupalStage(self) -> 'OM336PupalStage':
        """Initialize 'pupalStage'."""
        if self._pupalStage is None:
            self._pupalStage = OM336PupalStage(xml_tree=self.xml_tree, parent=self)
        return self._pupalStage

    @property
    def femaleEggsLaidByOviposit(self) -> 'OM337FemaleEggsLaidByOviposit':
        """Initialize 'femaleEggsLaidByOviposit'."""
        if self._femaleEggsLaidByOviposit is None:
            self._femaleEggsLaidByOviposit = OM337FemaleEggsLaidByOviposit(xml_tree=self.xml_tree, parent=self)
        return self._femaleEggsLaidByOviposit

    class _EstimatedLarvalResources(AttributeNode):
        """Generated class for 'estimatedLarvalResources'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='estimatedLarvalResources', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An estimate of mean annual availability of resources to larvae.
Used to get the resource usage fitting algorithm going; if the
algorithm fails to fit the resource availability then tweaking
this parameter may help. In other cases tweaking this parameter
shouldn't be necessary.
Default value is 10 (1e8). Units are arbitrary but must be the same as
those used by the resourceUsage parameter.

units:	 see resourceUsage
name:	Estimate of larval resources
units:	X"""
            self._metadata: dict = {'type': 'xs:double', 'default': '1e8', 'children_metadata': {'ordered': None, 'order': []}}


class OM333EggStage(Node):
    """Generated class for 'eggStage'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='eggStage', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Parameters for the egg stage of development

name:	Egg stage
Type:
Parameters associated with a mosquito development stage.

name:	Mosquito development-stage parameters"""
        self._metadata: dict = {'type': 'om:MosqStage', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'duration': 'required', 'survival': 'required'}, 'children': {}}
        self.duration: OM333EggStage._Duration = self._Duration(xml_tree=xml_tree, parent=self)
        self.survival: OM333EggStage._Survival = self._Survival(xml_tree=xml_tree, parent=self)

    class _Duration(AttributeNode):
        """Generated class for 'duration'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='duration', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Duration of the stage (i.e. length of time mosquito is an
egg/larva/pupa).

units:	 Days
 name:	Duration"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Survival(AttributeNode):
        """Generated class for 'survival'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='survival', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Probability that mosquito survives this size (probability of egg
hatching, a larva becoming a pupa or a pupa emerging as an adult,
at the start of that stage).

units:	Proportion
 name:	Probability of survival"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM334LarvalStage(Node):
    """Generated class for 'larvalStage'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='larvalStage', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Parameters associated with a mosquito development stage.

name:	Mosquito development-stage parameters
Base Type:
Parameters associated with a mosquito development stage.

name:	Mosquito development-stage parameters"""
        self._metadata: dict = {'children_metadata': {'ordered': None, 'order': []}, 'type': 'om:MosqStage', 'attributes': {'duration': 'required', 'survival': 'required'}, 'children': {}}
        self.duration: OM334LarvalStage._Duration = self._Duration(xml_tree=xml_tree, parent=self)
        self.survival: OM334LarvalStage._Survival = self._Survival(xml_tree=xml_tree, parent=self)

    class _Duration(AttributeNode):
        """Generated class for 'duration'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='duration', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Element:
Duration of the stage (i.e. length of time mosquito is an
egg/larva/pupa).

units:	 Days
 name:	Duration
Type:
Duration of the stage (i.e. length of time mosquito is an
egg/larva/pupa).

units:	 Days
 name:	Duration"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Survival(AttributeNode):
        """Generated class for 'survival'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='survival', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Element:
Probability that mosquito survives this size (probability of egg
hatching, a larva becoming a pupa or a pupa emerging as an adult,
at the start of that stage).

units:	Proportion
 name:	Probability of survival
Type:
Probability that mosquito survives this size (probability of egg
hatching, a larva becoming a pupa or a pupa emerging as an adult,
at the start of that stage).

units:	Proportion
 name:	Probability of survival"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM335Daily(Node):
    """Generated class for 'daily'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='daily', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
List of parameters which apply during the larval
stage of development. List length must equal stage
duration, with first item corresponding to first
24 hours after hatching, second item to hours
24-48, and so on.

name:	Daily development"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'resourceUsage': 'required', 'effectCompetition': 'required'}, 'children': {}}
        self.resourceUsage: OM335Daily._ResourceUsage = self._ResourceUsage(xml_tree=xml_tree, parent=self)
        self.effectCompetition: OM335Daily._EffectCompetition = self._EffectCompetition(xml_tree=xml_tree, parent=self)

    class _ResourceUsage(AttributeNode):
        """Generated class for 'resourceUsage'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='resourceUsage', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Resource usage during larval stage of development.
Units are arbitrary.

name:	Resource usage
units:	X"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _EffectCompetition(AttributeNode):
        """Generated class for 'effectCompetition'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='effectCompetition', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Effect of competition over resources on development.

name:	Effect of competition
units:	none"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM336PupalStage(Node):
    """Generated class for 'pupalStage'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='pupalStage', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Element:
Parameters for the pupal stage of development

name:	Pupal stage
Type:
Parameters associated with a mosquito development stage.

name:	Mosquito development-stage parameters"""
        self._metadata: dict = {'type': 'om:MosqStage', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'duration': 'required', 'survival': 'required'}, 'children': {}}
        self.duration: OM336PupalStage._Duration = self._Duration(xml_tree=xml_tree, parent=self)
        self.survival: OM336PupalStage._Survival = self._Survival(xml_tree=xml_tree, parent=self)

    class _Duration(AttributeNode):
        """Generated class for 'duration'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='duration', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Duration of the stage (i.e. length of time mosquito is an
egg/larva/pupa).

units:	 Days
 name:	Duration"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}

    class _Survival(AttributeNode):
        """Generated class for 'survival'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='survival', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Probability that mosquito survives this size (probability of egg
hatching, a larva becoming a pupa or a pupa emerging as an adult,
at the start of that stage).

units:	Proportion
 name:	Probability of survival"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM337FemaleEggsLaidByOviposit(Node):
    """Generated class for 'femaleEggsLaidByOviposit'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='femaleEggsLaidByOviposit', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The total number of female eggs laid by a female mosquito at
the conclusion to a feeding cycle, after feeding on an
unprotected human (non-human hosts and protected humans
use a multiplication factor to adjust this number for
mosquitoes feeding on them).

units:	 Eggs per feeding cycle
 name:	Eggs laid by ovipositing mosquito"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM337FemaleEggsLaidByOviposit._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM338SimpleMPD(Node):
    """Generated class for 'simpleMPD'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='simpleMPD', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Parameters describing the simple mosquito population dynamics model.
This is a simpler version of the life-cycle model, requiring less
parameters and with much simpler initialisation.

name:	Simple Mosq-Pop-Dynamics parameters"""
        self._metadata: dict = {'minOccurs': '0', 'children_metadata': {'ordered': 'all', 'order': ['developmentDuration', 'developmentSurvival', 'femaleEggsLaidByOviposit']}, 'attributes': {}, 'children': {'developmentDuration': {'minOccurs': '1', 'maxOccurs': '1'}, 'developmentSurvival': {'minOccurs': '1', 'maxOccurs': '1'}, 'femaleEggsLaidByOviposit': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self._developmentDuration: OM339DevelopmentDuration | None = None
        self._developmentSurvival: OM340DevelopmentSurvival | None = None
        self._femaleEggsLaidByOviposit: OM337FemaleEggsLaidByOviposit | None = None

    @property
    def developmentDuration(self) -> 'OM339DevelopmentDuration':
        """Initialize 'developmentDuration'."""
        if self._developmentDuration is None:
            self._developmentDuration = OM339DevelopmentDuration(xml_tree=self.xml_tree, parent=self)
        return self._developmentDuration

    @property
    def developmentSurvival(self) -> 'OM340DevelopmentSurvival':
        """Initialize 'developmentSurvival'."""
        if self._developmentSurvival is None:
            self._developmentSurvival = OM340DevelopmentSurvival(xml_tree=self.xml_tree, parent=self)
        return self._developmentSurvival

    @property
    def femaleEggsLaidByOviposit(self) -> 'OM337FemaleEggsLaidByOviposit':
        """Initialize 'femaleEggsLaidByOviposit'."""
        if self._femaleEggsLaidByOviposit is None:
            self._femaleEggsLaidByOviposit = OM337FemaleEggsLaidByOviposit(xml_tree=self.xml_tree, parent=self)
        return self._femaleEggsLaidByOviposit


class OM339DevelopmentDuration(Node):
    """Generated class for 'developmentDuration'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='developmentDuration', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Duration from egg laying to emergence in days.

units:	 Days
 name:	Duration
 min:	1"""
        self._metadata: dict = {'type': 'om:IntValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM339DevelopmentDuration._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
An integer value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:int', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM340DevelopmentSurvival(Node):
    """Generated class for 'developmentSurvival'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='developmentSurvival', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that mosquito survives from the egg being laid to emergence,
given no resouce limitations (no density constraints).

units:	Proportion
 name:	Probability of survival
 min:	0
 max:	1"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM340DevelopmentSurvival._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM341FemaleEggsLaidByOviposit(Node):
    """Generated class for 'femaleEggsLaidByOviposit'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='femaleEggsLaidByOviposit', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
The total number of female eggs laid by a female
mosquito at the conclusion to a feeding cycle.

units:	 Eggs per feeding cycle
 name:	Eggs laid by ovipositing mosquito"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM341FemaleEggsLaidByOviposit._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM342NonHumanHosts(Node):
    """Generated class for 'nonHumanHosts'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='nonHumanHosts', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Non human host parameters, per type of host (must
match up with non-species-specific parameters).
min:	0
 name:	Alternative (non-human) host paramters"""
        self._metadata: dict = {'maxOccurs': 'unbounded', 'minOccurs': '0', 'children_metadata': {'ordered': 'all', 'order': ['mosqRelativeEntoAvailability', 'mosqProbBiting', 'mosqProbFindRestSite', 'mosqProbResting', 'hostFecundityFactor']}, 'attributes': {'name': 'required'}, 'children': {'mosqRelativeEntoAvailability': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosqProbBiting': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosqProbFindRestSite': {'minOccurs': '1', 'maxOccurs': '1'}, 'mosqProbResting': {'minOccurs': '1', 'maxOccurs': '1'}, 'hostFecundityFactor': {'minOccurs': '1', 'maxOccurs': '1'}}}
        self.name: OM342NonHumanHosts._Name = self._Name(xml_tree=xml_tree, parent=self)
        self._mosqRelativeEntoAvailability: OM343MosqRelativeEntoAvailability | None = None
        self._mosqProbBiting: OM249MosqProbBiting | None = None
        self._mosqProbFindRestSite: OM250MosqProbFindRestSite | None = None
        self._mosqProbResting: OM251MosqProbResting | None = None
        self._hostFecundityFactor: OM252HostFecundityFactor | None = None

    @property
    def mosqRelativeEntoAvailability(self) -> 'OM343MosqRelativeEntoAvailability':
        """Initialize 'mosqRelativeEntoAvailability'."""
        if self._mosqRelativeEntoAvailability is None:
            self._mosqRelativeEntoAvailability = OM343MosqRelativeEntoAvailability(xml_tree=self.xml_tree, parent=self)
        return self._mosqRelativeEntoAvailability

    @property
    def mosqProbBiting(self) -> 'OM249MosqProbBiting':
        """Initialize 'mosqProbBiting'."""
        if self._mosqProbBiting is None:
            self._mosqProbBiting = OM249MosqProbBiting(xml_tree=self.xml_tree, parent=self)
        return self._mosqProbBiting

    @property
    def mosqProbFindRestSite(self) -> 'OM250MosqProbFindRestSite':
        """Initialize 'mosqProbFindRestSite'."""
        if self._mosqProbFindRestSite is None:
            self._mosqProbFindRestSite = OM250MosqProbFindRestSite(xml_tree=self.xml_tree, parent=self)
        return self._mosqProbFindRestSite

    @property
    def mosqProbResting(self) -> 'OM251MosqProbResting':
        """Initialize 'mosqProbResting'."""
        if self._mosqProbResting is None:
            self._mosqProbResting = OM251MosqProbResting(xml_tree=self.xml_tree, parent=self)
        return self._mosqProbResting

    @property
    def hostFecundityFactor(self) -> 'OM252HostFecundityFactor':
        """Initialize 'hostFecundityFactor'."""
        if self._hostFecundityFactor is None:
            self._hostFecundityFactor = OM252HostFecundityFactor(xml_tree=self.xml_tree, parent=self)
        return self._hostFecundityFactor

    class _Name(AttributeNode):
        """Generated class for 'name'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='name', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
Identifier for this category of non-human hosts
name:	Identifier for this category of non-human hosts"""
            self._metadata: dict = {'type': 'xs:string', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM343MosqRelativeEntoAvailability(Node):
    """Generated class for 'mosqRelativeEntoAvailability'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqRelativeEntoAvailability', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Relative availability of the population of non-human hosts of
type i to other non-human hosts; the sum of this across all
non-human hosts must be 1.

units:	Proportion
 name:	Relative availability of non-human host (_i)"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM343MosqRelativeEntoAvailability._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM344MosqProbBiting(Node):
    """Generated class for 'mosqProbBiting'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqProbBiting', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability of mosquito successfully biting host
units:	Proportion
name:	Probability of mosquito successfully biting host"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM344MosqProbBiting._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM345MosqProbFindRestSite(Node):
    """Generated class for 'mosqProbFindRestSite'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqProbFindRestSite', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability that the mosquito escapes host and finds a resting place after biting
units:	Proportion
name:	Probability that the mosquito escapes host and finds a resting place after biting"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM345MosqProbFindRestSite._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM346MosqProbResting(Node):
    """Generated class for 'mosqProbResting'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='mosqProbResting', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Probability of mosquito successfully resting after finding a resting site
units:	Proportion
name:	Probability of mosquito successfully resting after finding a resting site"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM346MosqProbResting._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}


class OM347HostFecundityFactor(Node):
    """Generated class for 'hostFecundityFactor'."""

    def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
        super().__init__(node_name='hostFecundityFactor', xml_tree=xml_tree, om_version=47)
        self._parent: Node | None = parent
        self._doc: str = """
Multiplicative factor for the number of fertile eggs laid by a
mosquito after biting this type of host, relative to an unprotected human.

units:	Proportion
name:	Relative fecundity of biting mosquitoes"""
        self._metadata: dict = {'type': 'om:DoubleValue', 'minOccurs': '0', 'children_metadata': {'ordered': None, 'order': []}, 'attributes': {'value': 'required'}, 'children': {}}
        self.value: OM347HostFecundityFactor._Value = self._Value(xml_tree=xml_tree, parent=self)

    class _Value(AttributeNode):
        """Generated class for 'value'."""

        def __init__(self, xml_tree: etree._ElementTree, parent: Node | None = None) -> None:
            super().__init__(node_name='value', xml_tree=xml_tree, om_version=47)
            self._parent: Node | None = parent
            self._doc: str = """
A double-precision floating-point value.
name:	Input parameter value
exposed:	false"""
            self._metadata: dict = {'type': 'xs:double', 'use': 'required', 'children_metadata': {'ordered': None, 'order': []}}
