#!/usr/bin/env python3

"""Provide the base classes for the autogenerated OpenMalaria XML classes.

Defined are separate classes for attributes and elements which inherit from a common
base. The classes provide methods to manipulate the XML tree.

"""

import os

from lxml import etree


class Node:
    """A class used as a base for XML nodes.

    This class is inherited by the classes `ElementNode` and `AttributeNode`.

    Parameters
    ----------
    node_name : str
      The name of the current node.

    xml_tree : etree.ElementTree
      The XML tree.

    om_version : int or str
      Stores the targeted OpenMalaria schema version.

    parent : Node, default None
      The parent XML node as a class.

    Attributes
    ----------
    node_name : str
      Stores the name of the current node.

    xml_tree : etree.ElementTree
      Stores the XML tree.

    See Also
    --------
    ElementNode : A derived class for XML element nodes.
    AttributeNode : A derived class for XML attribute nodes.

    Notes
    -----
    Private Attributes
    ~~~~~~~~~~~~~~~~~~
    _doc : str
      Stores documentation of current XML element or attribute.

    _last_added_child : etree.Element, default None
      Stores the last added child node.

    _metadata : dict
      Stores metadata about the XML element or attribute.

    _namespaces : dict
      Dictionary containing the XML namespaces.

    _om_version : str
      Stores the targeted OpenMalaria schema version.

    _parent : Node, default None
      Stores the parent XML node.

    _types_dict : dict
      Contains XML <-> Python type mappings.

    """

    def __init__(
        self,
        node_name: str,
        xml_tree: etree._ElementTree,
        om_version: str | int,
        parent: "Node | None" = None,
    ) -> None:
        self.node_name = node_name
        self.xml_tree = xml_tree
        self._parent = parent
        self._om_version = str(om_version)
        self._namespaces: dict = {
            "om": "http://openmalaria.org/schema/scenario_" + self._om_version,
            "xs": "http://www.w3.org/2001/XMLSchema",
        }
        self._last_added_child: etree._Element | None = None
        self._types_dict: dict = {
            "xs:string": str,
            "xs:int": int,
            "xs:boolean": bool,
            "xs:integer": int,
            "xs:double": (float, int),
        }
        self._metadata: dict = {}
        self._doc: str = ""

    def _node_path(self) -> list[str]:
        """Build full path of the current node.

        Returns
        -------
        list[str] :
          Returns a list of node names.
        """
        path = []
        node = self
        while node is not None:
            path.append(node.node_name)
            node = node._parent
        return path[::-1]

    def _is_repeatable(self) -> bool:
        """Check if current node can be repeated.

        A node is repeatable if the metadata contains ``maxOccurs`` equal to
        ``unbounded`` or greater than ``1``.

        Returns
        -------
        bool :
          Returns True if the current node can be repeated.

        """
        return (
            self._metadata.get("maxOccurs", "1") == "unbounded"
            or int(self._metadata.get("maxOccurs", "1")) > 1
        )

    def add(self) -> None:
        """Add a new instance of the current node under the parent.

        This method only works, if multiple instances of the current node are allowed.

        Raises
        ------
        AttributeError
          * If the current node is not repeatable.
          * If the current node does not have a parent.

        See Also
        --------
        _is_repeatable

        """
        # NOTE 2024-07-19: I would prefer if the method is only exposed if
        #   _is_repeatable evaluates to true.
        # Verify that the current node is repeatable.
        if not self._is_repeatable():
            try:
                raise AttributeError("Cannot use .add() on non-repeatable nodes.")
            except Exception as e:
                e.add_note(
                    f"Use {".".join(self._node_path()[1:])}._is_repeatable() "
                    f"or {".".join(self._node_path()[1:])}.help() "
                    "to verify if the node is repeatable."
                )
                raise

        # Get the root of the stored XML tree
        xml_root = self.xml_tree.getroot()

        # Create the path to the current node. The first node should always be
        # "scenario" and is ignored. Then, iterate over the node path ...
        for node in self._node_path()[1:]:
            # ... and find it in the XML
            next_root = xml_root.find(f"./{node}", namespaces=self._namespaces)
            # If we found something, set it as the active XML root
            if next_root is not None and node is not self.node_name:
                xml_root = next_root
            # Otherwise, create a new XML node and set that as the active
            # XML root
            else:
                next_root = etree.SubElement(xml_root, f"{node}")
                xml_root = next_root

        # Set the active root as the active child, thus set() can act on it.
        if self._parent is None:
            raise AttributeError("Parent is None. Cannot set _last_added_child.")
        else:
            self._parent._last_added_child = xml_root

    def select(self, value: str | None = None, **kwargs) -> None:
        """Select node based on text value and/or attribute name-value pairs.

        If the search returns a single node, it will be set as the last active child,
        thus `set` can work on it.
        Otherwise, a warning will be displayed along the matches.

        Parameters
        ----------
        value : str or None, default None
          Text value to match.

        kwargs :
          Attribute name=value pairs.

        """
        xml_root = self.xml_tree.getroot()

        # Build current node XPath
        x_path = f"./{"/".join(self._node_path()[1:])}"

        # Append filter for attributes
        for k, v in kwargs.items():
            x_path = x_path + f"[@{k}={v!r}]"
        # Append filter for text value
        if value is not None:
            x_path = x_path + f"[text()={value!r}]"

        # Find matches
        candidates = xml_root.xpath(x_path, namespaces=self._namespaces)

        # If we have one match, use it as active child
        if candidates is not None and len(candidates) == 1:
            xml_root = candidates[0]
            if self._parent is not None and self._is_repeatable():
                self._parent._last_added_child = xml_root
        # If we have multiple matches, print a warning plus results
        elif candidates is not None and len(candidates) > 1:
            print("Warning: Found multiple matches. Please refine search.")
            for candidate in candidates:
                # Remove noise
                xml_string = etree.tostring(candidate, pretty_print=True).decode()
                xml_string = xml_string.replace(
                    ' xmlns:om="http://openmalaria.org/schema/scenario_44"', ""
                )
                xml_string = xml_string.replace(
                    ' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"', ""
                )
                print(xml_string.strip())
        else:
            print("Could not find matching nodes.")

    def from_xml(self, xml: str) -> None:
        """Read directly from XML and add or replace current node.

        This method reads a raw XML string and checks if the current node and the one
        from `xml` have the identical tag. Upon success, it will replace the current
        node with the parsed content.

        Parameters
        ----------
        xml : str
          Input XML as a string.

        Raises
        ------
        AttributeError
          If the current node does not have a parent.
        RuntimeError
          If the node names do not match.

        """
        # Get the root of the stored XML tree
        xml_root = self.xml_tree.getroot()

        # Create the path to the current node. The first node should always be
        # "scenario" and is ignored. Then, iterate over the node path ...
        for node in self._node_path()[1:]:
            # ... and find it in the XML
            next_root = xml_root.find(f"./{node}", namespaces=self._namespaces)
            # If we found something, set it as the active XML root
            if next_root is not None:
                xml_root = next_root
            # Otherwise, create a new XML node and set that as the active
            # XML root
            else:
                next_root = etree.SubElement(xml_root, f"{node}")
                xml_root = next_root

        # Parse new node
        if os.path.isfile(xml):
            new_node = etree.parse(xml).getroot()
        else:
            new_node = etree.fromstring(xml)

        if new_node.tag != self.node_name:
            try:
                raise RuntimeError("Node names do not match")
            except Exception as e:
                e.add_note(
                    f"Old node name: {self.node_name} != "
                    f"New node name: {new_node.tag}"
                )
                raise

        parent = xml_root.getparent()
        if parent is None:
            raise AttributeError("Current node does not have a parent")

        # Replace the current node
        parent.replace(xml_root, new_node)

    def clear(self) -> None:
        """Remove all subnodes under current node."""
        xml_root = self.xml_tree.getroot()

        # Check if element exists and if not, build it
        node_path = self._node_path()[1:]
        # Construct the XPath to navigate to the correct node
        existing_node = xml_root.find(
            f"{'./' + '/'.join(node_path)}", namespaces=self._namespaces
        )
        if existing_node is not None:
            existing_node.clear()
        else:
            print(f"Nothing found under {'./' + '/'.join(node_path)}")

    def _get_max_name(self, el_list: list, lvl: int = 0) -> tuple[int, int]:
        """TODO."""
        max_len: int = 0
        max_lvl: int = 0
        for el in el_list:
            if isinstance(el, list):
                rec_len, rec_lvl = self._get_max_name(el, lvl=lvl + 1)
                if rec_len > max_len:
                    max_len = rec_len
                    max_lvl = rec_lvl
            else:
                if len(el) > max_len:
                    max_len = len(el)
                    max_lvl = lvl
        return max_len, max_lvl

    def _display_children(
        self,
        children: dict,
        children_metadata: dict,
        indent: int = 0,
        prefix: str = "| ",
        choice: bool = False,
        max_width: int = 1,
        max_lvl: int = 0,
    ):
        """TODO."""
        if children_metadata["ordered"] == "sequence":
            print(
                "{}{}".format(
                    "\nChildren " if indent == 0 else "",
                    " " * indent * 2 + "(In this order):",
                )
            )
        else:
            print(
                "{}{}".format(
                    "\nChildren " if indent == 0 else "",
                    " " * indent * 2 + "(In any order):",
                )
            )

        for child in children_metadata["order"]:
            if isinstance(child, list):
                if not choice:
                    print("{}{}".format(" " * (indent + 1) * 2, "Exactly one of"))
                    new_indent = indent + 2
                    new_prefix = prefix + " " * new_indent + "| "
                else:
                    new_indent = indent
                    new_prefix = prefix
                self._display_children(
                    children,
                    {"ordered": children_metadata["ordered"], "order": child},
                    indent=new_indent,
                    prefix=new_prefix,
                    choice=True,
                    max_width=max_width,
                    max_lvl=max_lvl,
                )
            else:
                min_occ, max_occ = (
                    int(x) if x.isdigit() else x
                    for x in [
                        children[child].get(attr) for attr in ["minOccurs", "maxOccurs"]
                    ]
                )
                if min_occ == 0 and max_occ == 1:
                    occ_text = "optional (zero or one)"
                elif min_occ == 0 and max_occ == "unbounded":
                    occ_text = "any number (zero or more)"
                elif min_occ == 1 and max_occ == "unbounded":
                    occ_text = "at least one"
                elif min_occ > 1 and max_occ > 1:
                    occ_text = "two or more occurrences"
                else:
                    occ_text = "required (one)"
                print(
                    "{0:{width}}\t{1}".format(
                        prefix + " " * (indent * 2) + child
                        if max_lvl > 0
                        else prefix + child,
                        occ_text,
                        width=max_width,
                    )
                )

    def help(self) -> None:
        """Print documentation of current node."""
        print(self._doc)
        if bool(self._metadata.get("attributes", {})):
            print("\nAttributes:")
            max_width, _ = self._get_max_name(
                self._metadata.get("attributes", {}).keys()
            )
            for attr_key, attr_value in self._metadata.get("attributes", {}).items():
                print(
                    "{0:{width}}\t{1}".format(
                        attr_key,
                        attr_value if attr_value else "optional",
                        width=max_width,
                    )
                )

        if bool(self._metadata.get("children", {})):
            max_width, max_lvl = self._get_max_name(
                self._metadata["children_metadata"]["order"]
            )
            self._display_children(
                self._metadata.get("children", {}),
                self._metadata["children_metadata"],
                max_width=max_width,
                max_lvl=max_lvl,
            )

        if bool(self._metadata.get("type", {})):
            print(f"\nType: {self._metadata.get("type", "").replace("xs:", "")}")

        if bool(self._metadata.get("restrictions", {})):
            print(
                f"\nValue restricted to: {self._metadata["restrictions"].get("enumeration", [])}"
            )

        if bool(self._metadata.get("default", {})):
            print(f"\nDefault value: {self._metadata.get("default", "")}")

    def view(self) -> None:
        """Display the XML string of the current node."""
        if self._parent:
            xml_root = self.xml_tree.getroot()
            current_node = xml_root.findall(
                f"{'./' + '/'.join(self._node_path()[1:])}", namespaces=self._namespaces
            )
            for node in current_node:
                xml_string = etree.tostring(node, pretty_print=True).decode()
                xml_string = xml_string.replace(
                    ' xmlns:om="http://openmalaria.org/schema/scenario_44"', ""
                )
                xml_string = xml_string.replace(
                    ' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"', ""
                )
                print(xml_string.strip())
        else:
            xml_string = etree.tostring(self.xml_tree, pretty_print=True).decode()
            print(xml_string.strip())


class ElementNode(Node):
    """A class used as a base for XML element nodes.

    This class inherits from `Node`.

    See Also
    --------
    Node : The parent class for XML element nodes.
    """

    def set(self, value: str | int | bool | float) -> None:
        """Set the text value of an element node.

        This method will verify the type of `value` and check if the parent node is
        repeatable. It will work on non-repeatable nodes directly, whereas for
        repeatable ones it will try to get the last active node.

        Parameters
        ----------
        value : str or int or bool or float
          Text value to set.

        Raises
        ------
        TypeError
          If the given `value` does not match the expected type.

        AttributeError
          * If the current node does not have a parent.
          * If the current node does not have a grandparent.
          * If the grandparent of the current node does not have an active child.

        See Also
        --------
        _is_repeatable

        """
        value_type = self._metadata.get("type", "unknown")
        if value_type == "unknown":
            print("Could not validate value type, trying to set it anyway.")
        else:
            if not isinstance(value, self._types_dict[value_type]):
                raise TypeError(
                    f"{value} is not a {self._types_dict[value_type]} but a {type(value)}"
                )

        # Get the root of the stored XML tree
        xml_root = self.xml_tree.getroot()

        # Because we are setting an element node, we first check if it is repeatable.
        if self._is_repeatable():
            # If so, we will get the parent's active child to set it, given that the
            # parent exists.
            if self._parent is None:
                try:
                    raise AttributeError("Parent is None.")
                except Exception as e:
                    e.add_note(
                        f"Make sure you using {".".join(self._node_path()[1:])}.add() "
                        "on a node with a parent."
                    )
                    raise

            if self._parent._last_added_child is not None:
                xml_root = self._parent._last_added_child

            #  Otherwise we will raise an error.
            else:
                try:
                    raise AttributeError(
                        "No active child found for "
                        f"{".".join(self._parent._node_path()[1:])}"
                    )
                except Exception as e:
                    e.add_note(
                        f"Use {".".join(self._node_path()[1:])}.add()"
                        f" before {".".join(self._node_path()[1:])}.set()."
                    )
                    raise

        # If the current node is not repeatable, we can simply proceed and set the
        # value.
        else:
            # Iterate over the path elements ...
            for node in self._node_path()[1:][:-1]:
                # ... and find it in the XML
                next_root = xml_root.find(f"./{node}", namespaces=self._namespaces)
                # If we found something, set it as the active XML root
                if next_root is not None:
                    xml_root = next_root
                # Otherwise, create a new XML node and set it as the active XML root
                else:
                    # Add new node
                    next_root = etree.SubElement(xml_root, f"{node}")
                    xml_root = next_root

        # Assign the value to the element node
        xml_root.text = str(value)

    def update(self, old: str, new: str | int | bool | float, **kwargs):
        """Update the text value of an element node.

        Parameters
        ----------
        old : str
          Old text value to match.

        new : str or int or bool or float
          New text value to set.

        kwargs :
          Attribute name=value pairs.

        See Also
        --------
        select

        """
        self.select(old, **kwargs)
        self.set(new)


class AttributeNode(Node):
    """A class used as a base for XML attribute nodes.

    This class inherits from `Node`.

    See Also
    --------
    Node : The parent class for XML nodes.
    """

    def set(self, value: str | int | bool | float) -> None:
        """Set the value of an attribute node.

        This method will verify the type of `value` and check if the parent node is
        repeatable. It will work on non-repeatable nodes directly, whereas for
        repeatable ones it will try to get the last active node.

        Parameters
        ----------
        value : str | int | bool | float
          Attribute value to set.

        Raises
        ------
        TypeError
          If the given `value` does not match the expected type.

        AttributeError
          * If the current node does not have a parent.
          * If the current node does not have a grandparent.
          * If the grandparent of the current node does not have an active child.

        See Also
        --------
        _is_repeatable

        """
        value_type = self._metadata.get("type", "unknown")
        if value_type == "unknown":
            print("Could not validate value type, trying to set it anyway.")
        else:
            if not isinstance(value, self._types_dict[value_type]):
                raise TypeError(
                    f"{value} is not a {self._types_dict[value_type]} but a {type(value)}"
                )

        # Get the root of the stored XML tree
        xml_root = self.xml_tree.getroot()

        # Because we are setting an attribute node, we first check if the parent
        # exists and then if it is repeatable.
        if self._parent is None:
            try:
                raise AttributeError("Parent is None.")
            except Exception as e:
                e.add_note(
                    f"Make sure you using {".".join(self._node_path()[1:])}.add() "
                    "on a node with a parent."
                )
                raise

        if self._parent._is_repeatable():
            # If so, we will get the grandparent's active child to set it, given
            # that the grandparent exists.
            if self._parent._parent is None:
                try:
                    raise AttributeError("Grandparent is None.")
                except Exception as e:
                    e.add_note(
                        f"Make sure you using {".".join(self._node_path()[1:])}.add() "
                        "on a node with a grandparent."
                    )
                    raise

            if self._parent._parent._last_added_child is not None:
                xml_root = self._parent._parent._last_added_child

            #  Otherwise we will raise an error.
            else:
                try:
                    raise AttributeError(
                        "No active child found for "
                        f"{".".join(self._parent._parent._node_path()[1:])}"
                    )
                except Exception as e:
                    e.add_note(
                        f"Use {".".join(self._parent._node_path()[1:])}.add()"
                        f" before {".".join(self._node_path()[1:])}.set()."
                    )
                    raise

        # If the parent is not repeatable, we can simply proceed and set the
        # value.
        else:
            # Iterate over the path elements ...
            for node in self._node_path()[1:][:-1]:
                # ... and find it in the XML
                next_root = xml_root.find(f"./{node}", namespaces=self._namespaces)
                # If we found something, set it as the active XML root
                if next_root is not None:
                    xml_root = next_root
                # Otherwise, create a new XML node and set that as the active
                # XML root
                else:
                    # Add new node
                    next_root = etree.SubElement(xml_root, f"{node}")
                    xml_root = next_root

        # Assign the value to the attribute
        xml_root.set(self.node_name, str(value))

    def update(self, new: str | int | bool | float, value: str | None = None, **kwargs):
        """Update the value of an attribute node.

        Parameters
        ----------
        new : str or int or bool or float
          New attribute value to set.

        value : str or None, default None
          Text value to match.

        kwargs :
          Attribute name=value pairs.

        See Also
        --------
        select

        """
        # We select the parent node of the attribute and make it active
        if self._parent is not None:
            self._parent.select(value, **kwargs)
            self.set(new)
